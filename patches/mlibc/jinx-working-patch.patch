diff --git mlibc-clean/abis/ironclad/fcntl.h mlibc-workdir/abis/ironclad/fcntl.h
index 3147478..8f3749f 100644
--- mlibc-clean/abis/ironclad/fcntl.h
+++ mlibc-workdir/abis/ironclad/fcntl.h
@@ -10,6 +10,7 @@
 #define O_CLOEXEC   (1 << 3)
 #define O_NOFOLLOW  (1 << 4)
 #define O_NONBLOCK  (1 << 5)
+#define O_CLOFORK   (1 << 6)
 
 /* Flags emulated by userland, we just have to make sure they dont overlap with */
 /* kernel flags. */
@@ -34,6 +35,7 @@
 
 /* Fcntl flags. */
 #define FD_CLOEXEC   1
+#define FD_CLOFORK   2
 #define F_DUPFD 1
 #define F_DUPFD_CLOEXEC 2
 #define F_GETFD      3
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..232c229 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -13,36 +13,28 @@ bool charset::is_ascii_superset() {
 bool charset::is_alpha(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alpha() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_digit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= '0' && c <= '9';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_digit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_xdigit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_xdigit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_alnum(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alnum() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -55,63 +47,49 @@ bool charset::is_punct(codepoint c) {
 				|| c == '@'
 				|| c == '[' || c == '\\' || c == ']' || c == '^' || c == '_' || c == '`'
 				|| c == '{' || c == '|' || c == '}' || c == '~';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_punct() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_graph(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x21 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_graph() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_blank(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_blank() is not implemented"
-				" for the full Unicode charset " << c << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_space(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_space() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -119,9 +97,7 @@ codepoint charset::to_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'A' && c <= 'Z')
 			return c - 'A' + 'a';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_lower() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
@@ -129,9 +105,7 @@ codepoint charset::to_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'a' && c <= 'z')
 			return c - 'a' + 'A';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_upper() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
diff --git mlibc-clean/options/posix/generic/posix_locale.cpp mlibc-workdir/options/posix/generic/posix_locale.cpp
index f19e623..811b46f 100644
--- mlibc-clean/options/posix/generic/posix_locale.cpp
+++ mlibc-workdir/options/posix/generic/posix_locale.cpp
@@ -25,7 +25,7 @@ void freelocale(locale_t) {
 
 locale_t uselocale(locale_t) {
 	if(!uselocale_seen) {
-		mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
+		//mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
 		uselocale_seen = true;
 	}
 	return nullptr;
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 54c96d8..b4c6bef 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -534,7 +534,7 @@ long double strtold_l(const char *__restrict__, char ** __restrict__, locale_t)
 }
 
 float strtof_l(const char *__restrict__ nptr, char **__restrict__ endptr, locale_t) {
-	mlibc::infoLogger() << "mlibc: strtof_l ignores locales" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: strtof_l ignores locales" << frg::endlog;
 	return strtof(nptr, endptr);
 }
 
diff --git mlibc-clean/options/posix/generic/sys-uio.cpp mlibc-workdir/options/posix/generic/sys-uio.cpp
index 0dff9d4..cdebf00 100644
--- mlibc-clean/options/posix/generic/sys-uio.cpp
+++ mlibc-workdir/options/posix/generic/sys-uio.cpp
@@ -41,7 +41,7 @@ ssize_t writev(int fd, const struct iovec *iovs, int iovc) {
 	}
 
 	// TODO: this implementation is not safe to use in signal contexts
-	mlibc::infoLogger() << "mlibc: falling back to signal-unsafe writev implementation!" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: falling back to signal-unsafe writev implementation!" << frg::endlog;
 	size_t bytes = 0;
 	for(int i = 0; i < iovc; i++) {
 		if(SSIZE_MAX - bytes < iovs[i].iov_len) {
diff --git mlibc-clean/options/posix/include/fcntl.h mlibc-workdir/options/posix/include/fcntl.h
index 49c42e5..2222258 100644
--- mlibc-clean/options/posix/include/fcntl.h
+++ mlibc-workdir/options/posix/include/fcntl.h
@@ -41,7 +41,6 @@ int creat(const char *__path, mode_t __mode);
 int fallocate(int __fd, int __mode, off_t __offset, off_t __len);
 int fcntl(int __fd, int __command, ...);
 int open(const char *__path, int __flags, ...);
-int open64(const char *__path, int __flags, ...);
 int openat(int __dirfd, const char *__path, int __flags, ...);
 int posix_fadvise(int __fd, off_t __offset, off_t __size, int __advice);
 int posix_fallocate(int __fd, off_t __offset, off_t __size);
diff --git mlibc-clean/options/posix/include/sys/stat.h mlibc-workdir/options/posix/include/sys/stat.h
index 98f1d2a..e648292 100644
--- mlibc-clean/options/posix/include/sys/stat.h
+++ mlibc-workdir/options/posix/include/sys/stat.h
@@ -19,11 +19,9 @@ int chmod(const char *__pathname, mode_t __mode);
 int fchmod(int __fd, mode_t __mode);
 int fchmodat(int __fd, const char *__pathname, mode_t __mode, int __flags);
 int fstat(int __fd, struct stat *__result);
-int fstat64(int __fd, struct stat64 *__result);
 int fstatat(int __fd, const char *__restrict __pathname, struct stat *__restrict __buf, int __flags);
 int futimens(int __fd, const struct timespec __times[2]);
 int lstat(const char *__restrict __pathname, struct stat *__restrict __buf);
-int lstat64(const char *__restrict __pathname, struct stat64 *__restrict __buf);
 int mkdir(const char *__pathname, mode_t __mode);
 int mkdirat(int __dirfd, const char *__pathname, mode_t __mode);
 int mkfifo(const char *__pathname, mode_t __mode);
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index 18b2bfa..82b45d4 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -1025,7 +1025,7 @@ int sys_shutdown(int sockfd, int how) {
 
 int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value) {
 	(void)which; (void)new_value; (void)old_value;
-	return ENOSYS;
+	return 0;
 }
 
 int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
@@ -1097,6 +1097,11 @@ int sys_sigsuspend(const sigset_t *set) {
 	return sys_ppoll(NULL, 0, NULL, set, NULL);
 }
 
+int sys_sigpending(sigset_t *set) {
+	*set = 0;
+	return 0;
+}
+
 int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
 		fd_set *except_set, const struct timespec *timeout,
 		const sigset_t *sigmask, int *num_events) {
@@ -1430,6 +1435,34 @@ int sys_mkfifoat(int dirfd, const char *path, mode_t mode) {
 	return sys_mknodat(dirfd, path, S_IFIFO | mode, 0);
 }
 
+int sys_openpt(int oflags, int *fd) {
+	int sfd, e;
+
+	if (e = sys_openpty(fd, &sfd, NULL, NULL, NULL); e) {
+		return e;
+	}
+    sys_close(sfd);
+
+	int fdflags = 0;
+    if (oflags & O_CLOEXEC) {
+    	fdflags |= FD_CLOEXEC;
+    }
+    if (oflags & O_CLOFORK) {
+        fdflags |= FD_CLOFORK;
+    }
+    if (fdflags) {
+        fcntl(*fd, F_SETFD, fdflags);
+    }
+
+	// We ignore non O_RDWR passed in oflags since that doesnt bond well with
+	// the openpty interface.
+    if (!(oflags & O_NOCTTY)) {
+        ioctl(*fd, TIOCSCTTY);
+    }
+
+    return e;
+}
+
 int sys_unlockpt(int fd) {
 	int unlock = 0;
 	return sys_ioctl(fd, TIOCSPTLCK, &unlock, NULL);
