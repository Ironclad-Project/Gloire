diff -urN --no-dereference mlibc-clean/abis/ironclad/errno.h mlibc-workdir/abis/ironclad/errno.h
--- mlibc-clean/abis/ironclad/errno.h
+++ mlibc-workdir/abis/ironclad/errno.h
@@ -120,6 +120,7 @@
 #define EBADE 1114
 #define EHWPOISON 1115
 #define EBADRQC 1116
+#define EPROGMISMATCH 1117
 
 #define EIEIO 1524152434
 
diff -urN --no-dereference mlibc-clean/meson.build mlibc-workdir/meson.build
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -239,6 +239,7 @@
 elif host_machine.system() == 'ironclad'
 	rtld_include_dirs += include_directories('sysdeps/ironclad/include')
 	libc_include_dirs += include_directories('sysdeps/ironclad/include')
+	internal_conf.set10('MLIBC_MMAP_ALLOCATE_DSO', true)
 	subdir('sysdeps/ironclad')
 elif host_machine.system() == 'keyronex'
 	rtld_include_dirs += include_directories('sysdeps/keyronex/include')
@@ -284,11 +285,13 @@
 linux_option = get_option('linux_option').require(sysdep_supported_options.get('linux')).allowed()
 glibc_option = get_option('glibc_option').require(sysdep_supported_options.get('glibc')).allowed()
 bsd_option = get_option('bsd_option').require(sysdep_supported_options.get('bsd')).allowed()
+nvmm_option = get_option('nvmm_option').require(sysdep_supported_options.get('nvmm')).allowed()
 
 mlibc_conf.set10('__MLIBC_POSIX_OPTION', posix_option)
 mlibc_conf.set10('__MLIBC_LINUX_OPTION', linux_option)
 mlibc_conf.set10('__MLIBC_GLIBC_OPTION', glibc_option)
 mlibc_conf.set10('__MLIBC_BSD_OPTION', bsd_option)
+mlibc_conf.set10('__MLIBC_NVMM_OPTION', nvmm_option)
 mlibc_conf.set10('__MLIBC_SYSDEP_HAS_BITS_SYSCALL_H', provides_bits_syscall_h)
 
 rtld_include_dirs += include_directories('options/ansi/include')
@@ -351,6 +354,11 @@
 	libc_include_dirs += include_directories('options/bsd/include')
 endif
 
+if nvmm_option
+	rtld_include_dirs += include_directories('options/nvmm/include')
+	libc_include_dirs += include_directories('options/nvmm/include')
+endif
+
 rtld_include_dirs += include_directories('options/elf/include')
 libc_include_dirs += include_directories('options/elf/include')
 libc_include_dirs += include_directories('.')
@@ -445,6 +453,7 @@
 subdir('options/glibc')
 subdir('options/linux')
 subdir('options/bsd')
+subdir('options/nvmm')
 
 rtlib_deps = []
 
@@ -560,6 +569,7 @@
 summary_info += {'Linux option': get_option('linux_option')}
 summary_info += {'glibc option': get_option('glibc_option')}
 summary_info += {'BSD option': get_option('bsd_option')}
+summary_info += {'NVMM option': get_option('nvmm_option')}
 summary_info += {'debug allocator': get_option('debug_allocator')}
 summary_info += {'libgcc dependency': libgcc_dependency}
 summary(summary_info, bool_yn: true, section: 'mlibc options')
diff -urN --no-dereference mlibc-clean/meson_options.txt mlibc-workdir/meson_options.txt
--- mlibc-clean/meson_options.txt
+++ mlibc-workdir/meson_options.txt
@@ -6,6 +6,7 @@
 option('linux_option', type: 'feature', value : 'auto')
 option('glibc_option', type: 'feature', value : 'auto')
 option('bsd_option', type: 'feature', value : 'auto')
+option('nvmm_option', type: 'feature', value : 'auto')
 option('libgcc_dependency', type : 'boolean', value : true)
 option('linux_kernel_headers', type: 'string', value : '')
 option('default_library_paths', type: 'array', value: [])
diff -urN --no-dereference mlibc-clean/mlibc-config.h.in mlibc-workdir/mlibc-config.h.in
--- mlibc-clean/mlibc-config.h.in
+++ mlibc-workdir/mlibc-config.h.in
@@ -2,6 +2,7 @@
 #define _MLIBC_CONFIG_H
 
 #mesondefine __MLIBC_BSD_OPTION
+#mesondefine __MLIBC_NVMM_OPTION
 #mesondefine __MLIBC_POSIX_OPTION
 #mesondefine __MLIBC_LINUX_OPTION
 #mesondefine __MLIBC_GLIBC_OPTION
diff -urN --no-dereference mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -13,36 +13,28 @@
 bool charset::is_alpha(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alpha() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_digit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= '0' && c <= '9';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_digit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_xdigit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_xdigit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_alnum(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alnum() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -55,63 +47,49 @@
 				|| c == '@'
 				|| c == '[' || c == '\\' || c == ']' || c == '^' || c == '_' || c == '`'
 				|| c == '{' || c == '|' || c == '}' || c == '~';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_punct() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_graph(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x21 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_graph() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_blank(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_blank() is not implemented"
-				" for the full Unicode charset " << c << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_space(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_space() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -119,9 +97,7 @@
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'A' && c <= 'Z')
 			return c - 'A' + 'a';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_lower() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
@@ -129,9 +105,7 @@
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'a' && c <= 'z')
 			return c - 'a' + 'A';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_upper() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
diff -urN --no-dereference mlibc-clean/options/nvmm/generic/nvmm.cpp mlibc-workdir/options/nvmm/generic/nvmm.cpp
--- mlibc-clean/options/nvmm/generic/nvmm.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/generic/nvmm.cpp
@@ -0,0 +1,222 @@
+#include <stdint.h>
+#include <stddef.h>
+#include <nvmm.h>
+#include <errno.h>
+#include <bits/ensure.h>
+#include <mlibc/nvmm-sysdeps.hpp>
+
+int nvmm_init(void) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_init, -1);
+	if (int e = mlibc::sys_nvmm_init(); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_root_init(void) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_root_init, -1);
+	if (int e = mlibc::sys_nvmm_root_init(); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_capability(struct nvmm_capability *cap) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_capability, -1);
+	if (int e = mlibc::sys_nvmm_capability(cap); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_machine_create(struct nvmm_machine *machine) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_machine_create, -1);
+	if (int e = mlibc::sys_nvmm_machine_create(machine); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_machine_destroy(struct nvmm_machine *machine) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_machine_destroy, -1);
+	if (int e = mlibc::sys_nvmm_machine_destroy(machine); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_machine_configure(struct nvmm_machine *machine, uint64_t machine_conf, void *ptr) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_machine_configure, -1);
+	if (int e = mlibc::sys_nvmm_machine_configure(machine, machine_conf, ptr); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_create(struct nvmm_machine *machine, nvmm_cpuid_t cpu_id, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_create, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_create(machine, cpu_id, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_destroy(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_destroy, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_destroy(machine, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_configure(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu, uint64_t vcpu_conf, void *ptr) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_configure, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_configure(machine, vcpu, vcpu_conf, ptr); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_setstate(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu, uint64_t state) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_setstate, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_setstate(machine, vcpu, state); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_getstate(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu, uint64_t state) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_getstate, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_getstate(machine, vcpu, state); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_inject(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_inject, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_inject(machine, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_run(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_run, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_run(machine, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_gpa_map(struct nvmm_machine *machine, uintptr_t hva, gpaddr_t start_page, size_t size, int prot) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_gpa_map, -1);
+	if (int e = mlibc::sys_nvmm_gpa_map(machine, hva, start_page, size, prot); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_gpa_unmap(struct nvmm_machine *machine, uintptr_t hva, gpaddr_t start_page, size_t size) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_gpa_unmap, -1);
+	if (int e = mlibc::sys_nvmm_gpa_unmap(machine, hva, start_page, size); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_hva_map(struct nvmm_machine *machine, uintptr_t hva, size_t size) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_hva_map, -1);
+	if (int e = mlibc::sys_nvmm_hva_map(machine, hva, size); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_hva_unmap(struct nvmm_machine *machine, uintptr_t hva, size_t size) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_hva_unmap, -1);
+	if (int e = mlibc::sys_nvmm_hva_unmap(machine, hva, size); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_gva_to_gpa(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu, gvaddr_t gva, gpaddr_t *gpa, nvmm_prot_t *prot) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_gva_to_gpa, -1);
+	if (int e = mlibc::sys_nvmm_gva_to_gpa(machine, vcpu, gva, gpa, prot); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_gpa_to_hva(struct nvmm_machine *machine, gpaddr_t gpa, uintptr_t *hva, nvmm_prot_t *prot) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_gpa_to_hva, -1);
+	if (int e = mlibc::sys_nvmm_gpa_to_hva(machine, gpa, hva, prot); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_assist_io(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_assist_io, -1);
+	if (int e = mlibc::sys_nvmm_assist_io(machine, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_assist_mem(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_assist_mem, -1);
+	if (int e = mlibc::sys_nvmm_assist_mem(machine, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_ctl(int a, void *b, size_t c) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_ctl, -1);
+	if (int e = mlibc::sys_nvmm_ctl(a, b, c); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_dump(struct nvmm_machine *machine, struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_dump, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_dump(machine, vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
+
+int nvmm_vcpu_stop(struct nvmm_vcpu *vcpu) {
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_nvmm_vcpu_stop, -1);
+	if (int e = mlibc::sys_nvmm_vcpu_stop(vcpu); e) {
+		errno = e;
+		return -1;
+	}
+	return 0;
+}
diff -urN --no-dereference mlibc-clean/options/nvmm/include/mlibc/nvmm-sysdeps.hpp mlibc-workdir/options/nvmm/include/mlibc/nvmm-sysdeps.hpp
--- mlibc-clean/options/nvmm/include/mlibc/nvmm-sysdeps.hpp	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/include/mlibc/nvmm-sysdeps.hpp
@@ -0,0 +1,37 @@
+#ifndef MLIBC_NVMM_SYSDEPS
+#define MLIBC_NVMM_SYSDEPS
+
+#include <stdint.h>
+#include <stddef.h>
+#include <nvmm.h>
+
+namespace [[gnu::visibility("hidden")]] mlibc {
+
+[[gnu::weak]] int sys_nvmm_init(void);
+[[gnu::weak]] int sys_nvmm_root_init(void);
+[[gnu::weak]] int sys_nvmm_capability(struct nvmm_capability *);
+[[gnu::weak]] int sys_nvmm_machine_create(struct nvmm_machine *);
+[[gnu::weak]] int sys_nvmm_machine_destroy(struct nvmm_machine *);
+[[gnu::weak]] int sys_nvmm_machine_configure(struct nvmm_machine *, uint64_t, void *);
+[[gnu::weak]] int sys_nvmm_vcpu_create(struct nvmm_machine *, nvmm_cpuid_t, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_vcpu_destroy(struct nvmm_machine *, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_vcpu_configure(struct nvmm_machine *, struct nvmm_vcpu *, uint64_t, void *);
+[[gnu::weak]] int sys_nvmm_vcpu_setstate(struct nvmm_machine *, struct nvmm_vcpu *, uint64_t);
+[[gnu::weak]] int sys_nvmm_vcpu_getstate(struct nvmm_machine *, struct nvmm_vcpu *, uint64_t);
+[[gnu::weak]] int sys_nvmm_vcpu_inject(struct nvmm_machine *, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_vcpu_run(struct nvmm_machine *, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_gpa_map(struct nvmm_machine *, uintptr_t, gpaddr_t, size_t, int);
+[[gnu::weak]] int sys_nvmm_gpa_unmap(struct nvmm_machine *, uintptr_t, gpaddr_t, size_t);
+[[gnu::weak]] int sys_nvmm_hva_map(struct nvmm_machine *, uintptr_t, size_t);
+[[gnu::weak]] int sys_nvmm_hva_unmap(struct nvmm_machine *, uintptr_t, size_t);
+[[gnu::weak]] int sys_nvmm_gva_to_gpa(struct nvmm_machine *, struct nvmm_vcpu *, gvaddr_t, gpaddr_t *, nvmm_prot_t *);
+[[gnu::weak]] int sys_nvmm_gpa_to_hva(struct nvmm_machine *, gpaddr_t, uintptr_t *, nvmm_prot_t *);
+[[gnu::weak]] int sys_nvmm_assist_io(struct nvmm_machine *, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_assist_mem(struct nvmm_machine *, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_ctl(int, void *, size_t);
+[[gnu::weak]] int sys_nvmm_vcpu_dump(struct nvmm_machine *, struct nvmm_vcpu *);
+[[gnu::weak]] int sys_nvmm_vcpu_stop(struct nvmm_vcpu *);
+
+} // namespace mlibc
+
+#endif // MLIBC_NVMM_SYSDEPS
diff -urN --no-dereference mlibc-clean/options/nvmm/include/nvmm.h mlibc-workdir/options/nvmm/include/nvmm.h
--- mlibc-clean/options/nvmm/include/nvmm.h	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/include/nvmm.h
@@ -0,0 +1,146 @@
+/*	$NetBSD: nvmm.h,v 1.19 2021/04/06 08:40:17 reinoud Exp $	*/
+
+/*
+ * Copyright (c) 2018-2020 Maxime Villard, m00nbsd.net
+ * All rights reserved.
+ *
+ * This code is part of the NVMM hypervisor.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LIBNVMM_H_
+#define _LIBNVMM_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <nvmm_dev.h>
+#include <nvmm_ioctl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define NVMM_USER_VERSION	2
+
+/*
+ * Version 1 - Initial release in NetBSD 9.0.
+ * Version 2 - Added nvmm_vcpu::stop.
+ */
+
+struct nvmm_io;
+struct nvmm_mem;
+
+struct nvmm_assist_callbacks {
+	void (*io)(struct nvmm_io *);
+	void (*mem)(struct nvmm_mem *);
+};
+
+struct nvmm_machine {
+	nvmm_machid_t machid;
+	struct nvmm_comm_page **pages;
+	void *areas; /* opaque */
+};
+
+struct nvmm_vcpu {
+	nvmm_cpuid_t cpuid;
+	struct nvmm_assist_callbacks cbs;
+	struct nvmm_vcpu_state *state;
+	struct nvmm_vcpu_event *event;
+	struct nvmm_vcpu_exit *exit;
+	volatile int *stop;
+};
+
+struct nvmm_io {
+	struct nvmm_machine *mach;
+	struct nvmm_vcpu *vcpu;
+	uint16_t port;
+	bool in;
+	size_t size;
+	uint8_t *data;
+};
+
+struct nvmm_mem {
+	struct nvmm_machine *mach;
+	struct nvmm_vcpu *vcpu;
+	gpaddr_t gpa;
+	bool write;
+	size_t size;
+	uint8_t *data;
+};
+
+#define NVMM_VCPU_CONF_CALLBACKS	NVMM_VCPU_CONF_LIBNVMM_BEGIN
+
+#define NVMM_PROT_READ		0x01
+#define NVMM_PROT_WRITE		0x02
+#define NVMM_PROT_EXEC		0x04
+#define NVMM_PROT_USER		0x08
+#define NVMM_PROT_ALL		0x0F
+typedef uint64_t nvmm_prot_t;
+
+#ifndef __MLIBC_ABI_ONLY
+
+int nvmm_init(void);
+int nvmm_root_init(void);
+
+int nvmm_capability(struct nvmm_capability *);
+
+int nvmm_machine_create(struct nvmm_machine *);
+int nvmm_machine_destroy(struct nvmm_machine *);
+int nvmm_machine_configure(struct nvmm_machine *, uint64_t, void *);
+
+int nvmm_vcpu_create(struct nvmm_machine *, nvmm_cpuid_t, struct nvmm_vcpu *);
+int nvmm_vcpu_destroy(struct nvmm_machine *, struct nvmm_vcpu *);
+int nvmm_vcpu_configure(struct nvmm_machine *, struct nvmm_vcpu *, uint64_t,
+    void *);
+int nvmm_vcpu_setstate(struct nvmm_machine *, struct nvmm_vcpu *, uint64_t);
+int nvmm_vcpu_getstate(struct nvmm_machine *, struct nvmm_vcpu *, uint64_t);
+int nvmm_vcpu_inject(struct nvmm_machine *, struct nvmm_vcpu *);
+int nvmm_vcpu_run(struct nvmm_machine *, struct nvmm_vcpu *);
+
+int nvmm_gpa_map(struct nvmm_machine *, uintptr_t, gpaddr_t, size_t, int);
+int nvmm_gpa_unmap(struct nvmm_machine *, uintptr_t, gpaddr_t, size_t);
+int nvmm_hva_map(struct nvmm_machine *, uintptr_t, size_t);
+int nvmm_hva_unmap(struct nvmm_machine *, uintptr_t, size_t);
+
+int nvmm_gva_to_gpa(struct nvmm_machine *, struct nvmm_vcpu *, gvaddr_t, gpaddr_t *,
+    nvmm_prot_t *);
+int nvmm_gpa_to_hva(struct nvmm_machine *, gpaddr_t, uintptr_t *,
+    nvmm_prot_t *);
+
+int nvmm_assist_io(struct nvmm_machine *, struct nvmm_vcpu *);
+int nvmm_assist_mem(struct nvmm_machine *, struct nvmm_vcpu *);
+
+int nvmm_ctl(int, void *, size_t);
+
+int nvmm_vcpu_dump(struct nvmm_machine *, struct nvmm_vcpu *);
+
+int nvmm_vcpu_stop(struct nvmm_vcpu *);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LIBNVMM_H_ */
diff -urN --no-dereference mlibc-clean/options/nvmm/include/nvmm_dev.h mlibc-workdir/options/nvmm/include/nvmm_dev.h
--- mlibc-clean/options/nvmm/include/nvmm_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/include/nvmm_dev.h
@@ -0,0 +1,116 @@
+/*	$NetBSD: nvmm.h,v 1.16 2021/03/26 15:59:53 reinoud Exp $	*/
+
+/*
+ * Copyright (c) 2018-2020 Maxime Villard, m00nbsd.net
+ * All rights reserved.
+ *
+ * This code is part of the NVMM hypervisor.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _NVMM_H_
+#define _NVMM_H_
+
+#include <sys/types.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef uint64_t	gpaddr_t;
+typedef uint64_t	gvaddr_t;
+
+typedef uint32_t	nvmm_machid_t;
+typedef uint32_t	nvmm_cpuid_t;
+
+#if defined(__x86_64__)
+#include <nvmm_x86.h>
+#endif
+
+#define NVMM_KERN_VERSION		2
+
+/*
+ * Version 1 - Initial release in NetBSD 9.0.
+ * Version 2 - Added nvmm_vcpu::stop.
+ */
+
+struct nvmm_capability {
+	uint32_t version;
+	uint32_t state_size;
+	uint32_t max_machines;
+	uint32_t max_vcpus;
+	uint64_t max_ram;
+	struct nvmm_cap_md arch;
+};
+
+/* Machine configuration slots. */
+#define NVMM_MACH_CONF_LIBNVMM_BEGIN	0
+#define NVMM_MACH_CONF_MI_BEGIN		100
+#define NVMM_MACH_CONF_MD_BEGIN		200
+#define NVMM_MACH_CONF_MD(op)		(op - NVMM_MACH_CONF_MD_BEGIN)
+
+/* VCPU configuration slots. */
+#define NVMM_VCPU_CONF_LIBNVMM_BEGIN	0
+#define NVMM_VCPU_CONF_MI_BEGIN		100
+#define NVMM_VCPU_CONF_MD_BEGIN		200
+#define NVMM_VCPU_CONF_MD(op)		(op - NVMM_VCPU_CONF_MD_BEGIN)
+
+struct nvmm_comm_page {
+	/* State. */
+	uint64_t state_wanted;
+	uint64_t state_cached;
+	uint64_t state_commit;
+	struct nvmm_vcpu_state state;
+
+	/* Event. */
+	bool event_commit;
+	struct nvmm_vcpu_event event;
+
+	/* Race-free exit from nvmm_vcpu_run() without signals. */
+	volatile int stop;
+};
+
+/*
+ * Bits 20:27 -> machid
+ * Bits 12:19 -> cpuid
+ */
+#define NVMM_COMM_OFF(machid, cpuid)	\
+	((((uint64_t)machid & 0xFFULL) << 20) | (((uint64_t)cpuid & 0xFFULL) << 12))
+
+#define NVMM_COMM_MACHID(off)		\
+	((off >> 20) & 0xFF)
+
+#define NVMM_COMM_CPUID(off)		\
+	((off >> 12) & 0xFF)
+
+#ifdef _KERNEL
+/* At most one page, for the NVMM_COMM_* macros. */
+CTASSERT(sizeof(struct nvmm_comm_page) <= PAGE_SIZE);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -urN --no-dereference mlibc-clean/options/nvmm/include/nvmm_ioctl.h mlibc-workdir/options/nvmm/include/nvmm_ioctl.h
--- mlibc-clean/options/nvmm/include/nvmm_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/include/nvmm_ioctl.h
@@ -0,0 +1,166 @@
+/*	$NetBSD: nvmm_ioctl.h,v 1.12 2020/09/08 16:58:38 maxv Exp $	*/
+
+/*
+ * Copyright (c) 2018-2020 Maxime Villard, m00nbsd.net
+ * All rights reserved.
+ *
+ * This code is part of the NVMM hypervisor.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _NVMM_IOCTL_H_
+#define _NVMM_IOCTL_H_
+
+#include <sys/ioccom.h>
+#include <nvmm_dev.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct nvmm_ioc_capability {
+	struct nvmm_capability cap;
+};
+
+struct nvmm_ioc_machine_create {
+	nvmm_machid_t machid;
+};
+
+struct nvmm_ioc_machine_destroy {
+	nvmm_machid_t machid;
+};
+
+struct nvmm_ioc_machine_configure {
+	nvmm_machid_t machid;
+	uint64_t op;
+	void *conf;
+};
+
+struct nvmm_ioc_vcpu_create {
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+};
+
+struct nvmm_ioc_vcpu_destroy {
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+};
+
+struct nvmm_ioc_vcpu_configure {
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+	uint64_t op;
+	void *conf;
+};
+
+struct nvmm_ioc_vcpu_setstate {
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+};
+
+struct nvmm_ioc_vcpu_getstate {
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+};
+
+struct nvmm_ioc_vcpu_inject {
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+};
+
+struct nvmm_ioc_vcpu_run {
+	/* input */
+	nvmm_machid_t machid;
+	nvmm_cpuid_t cpuid;
+	/* output */
+	struct nvmm_vcpu_exit exit;
+};
+
+struct nvmm_ioc_hva_map {
+	nvmm_machid_t machid;
+	uintptr_t hva;
+	size_t size;
+	int flags;
+};
+
+struct nvmm_ioc_hva_unmap {
+	nvmm_machid_t machid;
+	uintptr_t hva;
+	size_t size;
+	int flags;
+};
+
+struct nvmm_ioc_gpa_map {
+	nvmm_machid_t machid;
+	uintptr_t hva;
+	gpaddr_t gpa;
+	size_t size;
+	int prot;
+};
+
+struct nvmm_ioc_gpa_unmap {
+	nvmm_machid_t machid;
+	gpaddr_t gpa;
+	size_t size;
+};
+
+struct nvmm_ctl_mach_info {
+	/* input */
+	nvmm_machid_t machid;
+	/* output */
+	uint32_t nvcpus;
+	uint64_t nram;
+	pid_t pid;
+	time_t time;
+};
+
+struct nvmm_ioc_ctl {
+	int op;
+#define NVMM_CTL_MACH_INFO	0
+
+	void *data;
+	size_t size;
+};
+
+#define NVMM_IOC_CAPABILITY		_IOR ('N',  0, struct nvmm_ioc_capability)
+#define NVMM_IOC_MACHINE_CREATE		_IOWR('N',  1, struct nvmm_ioc_machine_create)
+#define NVMM_IOC_MACHINE_DESTROY	_IOW ('N',  2, struct nvmm_ioc_machine_destroy)
+#define NVMM_IOC_MACHINE_CONFIGURE	_IOW ('N',  3, struct nvmm_ioc_machine_configure)
+#define NVMM_IOC_VCPU_CREATE		_IOW ('N',  4, struct nvmm_ioc_vcpu_create)
+#define NVMM_IOC_VCPU_DESTROY		_IOW ('N',  5, struct nvmm_ioc_vcpu_destroy)
+#define NVMM_IOC_VCPU_CONFIGURE		_IOW ('N',  6, struct nvmm_ioc_vcpu_configure)
+#define NVMM_IOC_VCPU_SETSTATE		_IOW ('N',  7, struct nvmm_ioc_vcpu_setstate)
+#define NVMM_IOC_VCPU_GETSTATE		_IOW ('N',  8, struct nvmm_ioc_vcpu_getstate)
+#define NVMM_IOC_VCPU_INJECT		_IOW ('N',  9, struct nvmm_ioc_vcpu_inject)
+#define NVMM_IOC_VCPU_RUN		_IOWR('N', 10, struct nvmm_ioc_vcpu_run)
+#define NVMM_IOC_GPA_MAP		_IOW ('N', 11, struct nvmm_ioc_gpa_map)
+#define NVMM_IOC_GPA_UNMAP		_IOW ('N', 12, struct nvmm_ioc_gpa_unmap)
+#define NVMM_IOC_HVA_MAP		_IOW ('N', 13, struct nvmm_ioc_hva_map)
+#define NVMM_IOC_HVA_UNMAP		_IOW ('N', 14, struct nvmm_ioc_hva_unmap)
+#define NVMM_IOC_CTL			_IOW ('N', 20, struct nvmm_ioc_ctl)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NVMM_IOCTL_H_ */
diff -urN --no-dereference mlibc-clean/options/nvmm/include/nvmm_x86.h mlibc-workdir/options/nvmm/include/nvmm_x86.h
--- mlibc-clean/options/nvmm/include/nvmm_x86.h	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/include/nvmm_x86.h
@@ -0,0 +1,338 @@
+/*	$NetBSD: nvmm_x86.h,v 1.21 2021/03/26 15:59:53 reinoud Exp $	*/
+
+/*
+ * Copyright (c) 2018-2020 Maxime Villard, m00nbsd.net
+ * All rights reserved.
+ *
+ * This code is part of the NVMM hypervisor.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _NVMM_X86_H_
+#define _NVMM_X86_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* -------------------------------------------------------------------------- */
+
+#ifndef ASM_NVMM
+
+struct nvmm_x86_exit_memory {
+	int prot;
+	gpaddr_t gpa;
+	uint8_t inst_len;
+	uint8_t inst_bytes[15];
+};
+
+struct nvmm_x86_exit_io {
+	bool in;
+	uint16_t port;
+	int8_t seg;
+	uint8_t address_size;
+	uint8_t operand_size;
+	bool rep;
+	bool str;
+	uint64_t npc;
+};
+
+struct nvmm_x86_exit_rdmsr {
+	uint32_t msr;
+	uint64_t npc;
+};
+
+struct nvmm_x86_exit_wrmsr {
+	uint32_t msr;
+	uint64_t val;
+	uint64_t npc;
+};
+
+struct nvmm_x86_exit_insn {
+	uint64_t npc;
+};
+
+struct nvmm_x86_exit_invalid {
+	uint64_t hwcode;
+};
+
+/* Generic. */
+#define NVMM_VCPU_EXIT_NONE		0x0000000000000000ULL
+#define NVMM_VCPU_EXIT_STOPPED		0xFFFFFFFFFFFFFFFEULL
+#define NVMM_VCPU_EXIT_INVALID		0xFFFFFFFFFFFFFFFFULL
+/* x86: operations. */
+#define NVMM_VCPU_EXIT_MEMORY		0x0000000000000001ULL
+#define NVMM_VCPU_EXIT_IO		0x0000000000000002ULL
+/* x86: changes in VCPU state. */
+#define NVMM_VCPU_EXIT_SHUTDOWN		0x0000000000001000ULL
+#define NVMM_VCPU_EXIT_INT_READY	0x0000000000001001ULL
+#define NVMM_VCPU_EXIT_NMI_READY	0x0000000000001002ULL
+#define NVMM_VCPU_EXIT_HALTED		0x0000000000001003ULL
+#define NVMM_VCPU_EXIT_TPR_CHANGED	0x0000000000001004ULL
+/* x86: instructions. */
+#define NVMM_VCPU_EXIT_RDMSR		0x0000000000002000ULL
+#define NVMM_VCPU_EXIT_WRMSR		0x0000000000002001ULL
+#define NVMM_VCPU_EXIT_MONITOR		0x0000000000002002ULL
+#define NVMM_VCPU_EXIT_MWAIT		0x0000000000002003ULL
+#define NVMM_VCPU_EXIT_CPUID		0x0000000000002004ULL
+
+struct nvmm_x86_exit {
+	uint64_t reason;
+	union {
+		struct nvmm_x86_exit_memory mem;
+		struct nvmm_x86_exit_io io;
+		struct nvmm_x86_exit_rdmsr rdmsr;
+		struct nvmm_x86_exit_wrmsr wrmsr;
+		struct nvmm_x86_exit_insn insn;
+		struct nvmm_x86_exit_invalid inv;
+	} u;
+	struct {
+		uint64_t rflags;
+		uint64_t cr8;
+		uint64_t int_shadow:1;
+		uint64_t int_window_exiting:1;
+		uint64_t nmi_window_exiting:1;
+		uint64_t evt_pending:1;
+		uint64_t rsvd:60;
+	} exitstate;
+};
+
+#define NVMM_VCPU_EVENT_EXCP	0
+#define NVMM_VCPU_EVENT_INTR	1
+
+struct nvmm_x86_event {
+	u_int type;
+	uint8_t vector;
+	union {
+		struct {
+			uint64_t error;
+		} excp;
+	} u;
+};
+
+struct nvmm_cap_md {
+	uint64_t mach_conf_support;
+
+	uint64_t vcpu_conf_support;
+#define NVMM_CAP_ARCH_VCPU_CONF_CPUID	__BIT(0)
+#define NVMM_CAP_ARCH_VCPU_CONF_TPR	__BIT(1)
+
+	uint64_t xcr0_mask;
+	uint32_t mxcsr_mask;
+	uint32_t conf_cpuid_maxops;
+	uint64_t rsvd[6];
+};
+
+#endif
+
+/* -------------------------------------------------------------------------- */
+
+/*
+ * Segment state indexes. We use X64 as naming convention, not to confuse with
+ * X86 which originally implied 32bit.
+ */
+
+/* Segments. */
+#define NVMM_X64_SEG_ES			0
+#define NVMM_X64_SEG_CS			1
+#define NVMM_X64_SEG_SS			2
+#define NVMM_X64_SEG_DS			3
+#define NVMM_X64_SEG_FS			4
+#define NVMM_X64_SEG_GS			5
+#define NVMM_X64_SEG_GDT		6
+#define NVMM_X64_SEG_IDT		7
+#define NVMM_X64_SEG_LDT		8
+#define NVMM_X64_SEG_TR			9
+#define NVMM_X64_NSEG			10
+
+/* General Purpose Registers. */
+#define NVMM_X64_GPR_RAX		0
+#define NVMM_X64_GPR_RCX		1
+#define NVMM_X64_GPR_RDX		2
+#define NVMM_X64_GPR_RBX		3
+#define NVMM_X64_GPR_RSP		4
+#define NVMM_X64_GPR_RBP		5
+#define NVMM_X64_GPR_RSI		6
+#define NVMM_X64_GPR_RDI		7
+#define NVMM_X64_GPR_R8			8
+#define NVMM_X64_GPR_R9			9
+#define NVMM_X64_GPR_R10		10
+#define NVMM_X64_GPR_R11		11
+#define NVMM_X64_GPR_R12		12
+#define NVMM_X64_GPR_R13		13
+#define NVMM_X64_GPR_R14		14
+#define NVMM_X64_GPR_R15		15
+#define NVMM_X64_GPR_RIP		16
+#define NVMM_X64_GPR_RFLAGS		17
+#define NVMM_X64_NGPR			18
+
+/* Control Registers. */
+#define NVMM_X64_CR_CR0			0
+#define NVMM_X64_CR_CR2			1
+#define NVMM_X64_CR_CR3			2
+#define NVMM_X64_CR_CR4			3
+#define NVMM_X64_CR_CR8			4
+#define NVMM_X64_CR_XCR0		5
+#define NVMM_X64_NCR			6
+
+/* Debug Registers. */
+#define NVMM_X64_DR_DR0			0
+#define NVMM_X64_DR_DR1			1
+#define NVMM_X64_DR_DR2			2
+#define NVMM_X64_DR_DR3			3
+#define NVMM_X64_DR_DR6			4
+#define NVMM_X64_DR_DR7			5
+#define NVMM_X64_NDR			6
+
+/* MSRs. */
+#define NVMM_X64_MSR_EFER		0
+#define NVMM_X64_MSR_STAR		1
+#define NVMM_X64_MSR_LSTAR		2
+#define NVMM_X64_MSR_CSTAR		3
+#define NVMM_X64_MSR_SFMASK		4
+#define NVMM_X64_MSR_KERNELGSBASE	5
+#define NVMM_X64_MSR_SYSENTER_CS	6
+#define NVMM_X64_MSR_SYSENTER_ESP	7
+#define NVMM_X64_MSR_SYSENTER_EIP	8
+#define NVMM_X64_MSR_PAT		9
+#define NVMM_X64_MSR_TSC		10
+#define NVMM_X64_NMSR			11
+
+#ifndef ASM_NVMM
+
+#include <sys/types.h>
+#include <nvmm_x86_cpu_extended_state.h>
+
+struct nvmm_x64_state_seg {
+	uint16_t selector;
+	struct {		/* hidden */
+		uint16_t type:4;
+		uint16_t s:1;
+		uint16_t dpl:2;
+		uint16_t p:1;
+		uint16_t avl:1;
+		uint16_t l:1;
+		uint16_t def:1;
+		uint16_t g:1;
+		uint16_t rsvd:4;
+	} attrib;
+	uint32_t limit;		/* hidden */
+	uint64_t base;		/* hidden */
+};
+
+struct nvmm_x64_state_intr {
+	uint64_t int_shadow:1;
+	uint64_t int_window_exiting:1;
+	uint64_t nmi_window_exiting:1;
+	uint64_t evt_pending:1;
+	uint64_t rsvd:60;
+};
+
+/* Flags. */
+#define NVMM_X64_STATE_SEGS	0x01
+#define NVMM_X64_STATE_GPRS	0x02
+#define NVMM_X64_STATE_CRS	0x04
+#define NVMM_X64_STATE_DRS	0x08
+#define NVMM_X64_STATE_MSRS	0x10
+#define NVMM_X64_STATE_INTR	0x20
+#define NVMM_X64_STATE_FPU	0x40
+#define NVMM_X64_STATE_ALL	\
+	(NVMM_X64_STATE_SEGS | NVMM_X64_STATE_GPRS | NVMM_X64_STATE_CRS | \
+	 NVMM_X64_STATE_DRS | NVMM_X64_STATE_MSRS | NVMM_X64_STATE_INTR | \
+	 NVMM_X64_STATE_FPU)
+
+struct nvmm_x64_state {
+	struct nvmm_x64_state_seg segs[NVMM_X64_NSEG];
+	uint64_t gprs[NVMM_X64_NGPR];
+	uint64_t crs[NVMM_X64_NCR];
+	uint64_t drs[NVMM_X64_NDR];
+	uint64_t msrs[NVMM_X64_NMSR];
+	struct nvmm_x64_state_intr intr;
+	struct fxsave fpu;
+};
+
+#define NVMM_VCPU_CONF_CPUID	NVMM_VCPU_CONF_MD_BEGIN
+#define NVMM_VCPU_CONF_TPR	(NVMM_VCPU_CONF_MD_BEGIN + 1)
+
+struct nvmm_vcpu_conf_cpuid {
+	/* The options. */
+	uint32_t mask:1;
+	uint32_t exit:1;
+	uint32_t rsvd:30;
+
+	/* The leaf. */
+	uint32_t leaf;
+
+	/* The params. */
+	union {
+		struct {
+			struct {
+				uint32_t eax;
+				uint32_t ebx;
+				uint32_t ecx;
+				uint32_t edx;
+			} set;
+			struct {
+				uint32_t eax;
+				uint32_t ebx;
+				uint32_t ecx;
+				uint32_t edx;
+			} del;
+		} mask;
+	} u;
+};
+
+struct nvmm_vcpu_conf_tpr {
+	uint32_t exit_changed:1;
+	uint32_t rsvd:31;
+};
+
+#define nvmm_vcpu_exit		nvmm_x86_exit
+#define nvmm_vcpu_event		nvmm_x86_event
+#define nvmm_vcpu_state		nvmm_x64_state
+
+#ifdef _KERNEL
+#define NVMM_X86_MACH_NCONF	0
+#define NVMM_X86_VCPU_NCONF	2
+struct nvmm_x86_cpuid_mask {
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+};
+extern const struct nvmm_x64_state nvmm_x86_reset_state;
+extern const struct nvmm_x86_cpuid_mask nvmm_cpuid_00000001;
+extern const struct nvmm_x86_cpuid_mask nvmm_cpuid_00000007;
+extern const struct nvmm_x86_cpuid_mask nvmm_cpuid_80000001;
+extern const struct nvmm_x86_cpuid_mask nvmm_cpuid_80000007;
+extern const struct nvmm_x86_cpuid_mask nvmm_cpuid_80000008;
+bool nvmm_x86_pat_validate(uint64_t);
+#endif
+
+#endif /* ASM_NVMM */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _NVMM_X86_H_ */
diff -urN --no-dereference mlibc-clean/options/nvmm/include/nvmm_x86_cpu_extended_state.h mlibc-workdir/options/nvmm/include/nvmm_x86_cpu_extended_state.h
--- mlibc-clean/options/nvmm/include/nvmm_x86_cpu_extended_state.h	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/include/nvmm_x86_cpu_extended_state.h
@@ -0,0 +1,337 @@
+/*	$NetBSD: cpu_extended_state.h,v 1.19 2025/04/24 01:50:39 riastradh Exp $	*/
+
+#ifndef _X86_CPU_EXTENDED_STATE_H_
+#define _X86_CPU_EXTENDED_STATE_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define __packed __attribute__((packed))
+#define __aligned(x) __attribute__((aligned(x)))
+#ifdef __cplusplus
+#  define __CTASSERT(x) static_assert(x)
+#  define __CTASSERT_NOLINT(x) static_assert(x)
+#else
+#  define __CTASSERT(x) _Static_assert(x)
+#  define __CTASSERT_NOLINT(x) _Static_assert(x)
+#endif
+#define __BIT(n) (1 << (n))
+#define __LOWEST_SET_BIT(__mask) ((((__mask) - 1) & (__mask)) ^ (__mask))
+#define __SHIFTOUT(__x, __mask) (((__x) & (__mask)) / __LOWEST_SET_BIT(__mask))
+#define __SHIFTIN(__x, __mask) ((__x) * __LOWEST_SET_BIT(__mask))
+
+/*
+ * This file contains definitions of structures that match the memory layouts
+ * used on x86 processors to save floating point registers and other extended
+ * cpu states.
+ *
+ * This includes registers (etc) used by SSE/SSE2/SSE3/SSSE3/SSE4 and the later
+ * AVX instructions.
+ *
+ * The definitions are such that any future 'extended state' should be handled,
+ * provided the kernel doesn't need to know the actual contents.
+ *
+ * The actual structures the cpu accesses must be aligned to 16 bytes for FXSAVE
+ * and 64 for XSAVE. The types aren't aligned because copies do not need extra
+ * alignment.
+ *
+ * The slightly different layout saved by the i387 fsave is also defined.
+ * This is only normally written by pre Pentium II type cpus that don't
+ * support the fxsave instruction.
+ *
+ * Associated save instructions:
+ * FNSAVE:   Saves x87 state in 108 bytes (original i387 layout). Then
+ *           reinitializes the fpu.
+ * FSAVE:    Encodes to FWAIT followed by FNSAVE.
+ * FXSAVE:   Saves the x87 state and XMM (aka SSE) registers to the first
+ *           448 (max) bytes of a 512 byte area. This layout does not match
+ *           that written by FNSAVE.
+ * XSAVE:    Uses the same layout for the x87 and XMM registers, followed by
+ *           a 64byte header and separate save areas for additional extended
+ *           cpu states. The x87 state is always saved, the others
+ *           conditionally.
+ * XSAVEOPT: Same as XSAVE but only writes the registers blocks that have
+ *           been modified.
+ */
+
+/*
+ * Layout for code/data pointers relating to FP exceptions. Marked 'packed'
+ * because they aren't always 64bit aligned. Since the x86 cpu supports
+ * misaligned accesses it isn't worth avoiding the 'packed' attribute.
+ */
+union fp_addr {
+	uint64_t fa_64;	/* Linear address for 64bit systems */
+	struct {
+		uint32_t fa_off;	/* linear address for 32 bit */
+		uint16_t fa_seg;	/* code/data (etc) segment */
+		uint16_t fa_opcode;	/* last opcode (sometimes) */
+	} fa_32;
+} __packed __aligned(4);
+
+/* The x87 registers are 80 bits */
+struct fpacc87 {
+	uint64_t f87_mantissa;	/* mantissa */
+	uint16_t f87_exp_sign;	/* exponent and sign */
+} __packed __aligned(2);
+
+/* The x87 registers padded out to 16 bytes for fxsave */
+struct fpaccfx {
+	struct fpacc87 r __aligned(16);
+};
+
+/* The SSE/SSE2 registers are 128 bits */
+struct xmmreg {
+	uint8_t xmm_bytes[16];
+};
+
+/* The AVX registers are 256 bits, but the low bits are the xmmregs */
+struct ymmreg {
+	uint8_t ymm_bytes[16];
+};
+
+/* The AVX-512 registers are 512 bits but the low bits are in xmmregs
+ * and ymmregs */
+struct zmmreg {
+	uint8_t zmm_bytes[32];
+};
+
+/* 512-bit ZMM register. */
+struct hi16_zmmreg {
+	uint8_t zmm_bytes[64];
+};
+
+/*
+ * Floating point unit registers (FSAVE instruction).
+ *
+ * The s87_ac[] and fx_87_ac[] are relative to the stack top. The 'tag word'
+ * contains 2 bits per register and refers to absolute register numbers.
+ *
+ * The cpu sets the tag values 0b01 (zero) and 0b10 (special) when a value
+ * is loaded. The software need only set 0b00 (used) and 0xb11 (unused).
+ * The fxsave 'Abridged tag word' in inverted.
+ */
+struct save87 {
+	uint16_t s87_cw __aligned(4);	/* control word */
+	uint16_t s87_sw __aligned(4);	/* status word  */
+	uint16_t s87_tw __aligned(4);	/* tag word */
+	union fp_addr s87_ip;		/* floating point instruction pointer */
+#define s87_opcode s87_ip.fa_32.fa_opcode	/* opcode last executed (11bits) */
+	union fp_addr s87_dp;		/* floating operand offset */
+	struct fpacc87 s87_ac[8];	/* accumulator contents */
+};
+__CTASSERT_NOLINT(sizeof(struct save87) == 108);
+
+/*
+ * FPU/MMX/SSE/SSE2 context (FXSAVE instruction).
+ */
+struct fxsave {
+	uint16_t fx_cw;		/* FPU Control Word */
+	uint16_t fx_sw;		/* FPU Status Word */
+	uint8_t fx_tw;		/* FPU Tag Word (abridged) */
+	uint8_t fx_zero;	/* zero */
+	uint16_t fx_opcode;	/* FPU Opcode */
+	union fp_addr fx_ip;	/* FPU Instruction Pointer */
+	union fp_addr fx_dp;	/* FPU Data pointer */
+	uint32_t fx_mxcsr;	/* MXCSR Register State */
+	uint32_t fx_mxcsr_mask;
+	struct fpaccfx fx_87_ac[8];	/* 8 x87 registers */
+	struct xmmreg fx_xmm[16];	/* XMM regs (8 in 32bit modes) */
+	uint8_t fx_rsvd[96];
+} __aligned(16);
+__CTASSERT_NOLINT(sizeof(struct fxsave) == 512);
+
+/*
+ * For XSAVE, a 64byte header follows the fxsave data.
+ */
+struct xsave_header {
+	uint8_t xsh_fxsave[512];	/* struct fxsave */
+	uint64_t xsh_xstate_bv;		/* bitmap of saved sub structures */
+	uint64_t xsh_xcomp_bv;		/* bitmap of compact sub structures */
+	uint8_t xsh_rsrvd[8];		/* must be zero */
+	uint8_t xsh_reserved[40];	/* best if zero */
+};
+__CTASSERT(sizeof(struct xsave_header) == 512 + 64);
+
+/*
+ * The ymm save area actually follows the xsave_header.
+ */
+struct xsave_ymm {
+	struct ymmreg xs_ymm[16];	/* High bits of YMM registers */
+};
+__CTASSERT(sizeof(struct xsave_ymm) == 256);
+
+/*
+ * AVX-512: opmask state.
+ */
+struct xsave_opmask {
+	uint64_t xs_k[8];			/* k0..k7 registers. */
+};
+__CTASSERT(sizeof(struct xsave_opmask) == 64);
+
+/*
+ * AVX-512: ZMM_Hi256 state.
+ */
+struct xsave_zmm_hi256 {
+	struct zmmreg xs_zmm[16];	/* High bits of zmm0..zmm15 registers. */
+};
+__CTASSERT(sizeof(struct xsave_zmm_hi256) == 512);
+
+/*
+ * AVX-512: Hi16_ZMM state.
+ */
+struct xsave_hi16_zmm {
+	struct hi16_zmmreg xs_hi16_zmm[16];	/* zmm16..zmm31 registers. */
+};
+__CTASSERT(sizeof(struct xsave_hi16_zmm) == 1024);
+
+/*
+ * Structure used to hold all interesting data from XSAVE, in predictable form.
+ * Note that this structure can have new members added to the end.
+ */
+struct xstate {
+	/*
+	 * The two following fields are bitmaps of XSAVE components.  They can be
+	 * matched against XCR0_* constants from <machine/specialreg.h>).
+	 */
+	/*
+	 * XSAVE/XRSTOR RFBM parameter.
+	 *
+	 * PT_GETXSTATE: 1 indicates that the respective XSAVE component is
+	 * supported and has been enabled for saving.  0 indicates that it is not
+	 * supported by the platform or kernel.
+	 *
+	 * PT_SETXSTATE: 1 indicates that the respective XSAVE component should
+	 * be updated to the value of respective field (or reset if xs_xsave_bv
+	 * bit is 0).  0 indicates that it should be left intact.  It is an error
+	 * to enable bits that are not supported by the platform or kernel.
+	 */
+	uint64_t xs_rfbm;
+	/*
+	 * XSAVE/XRSTOR xstate header.
+	 *
+	 * PT_GETXSTATE: 1 indicates that the respective XSAVE component has been
+	 * saved.  0 indicates that it had been in its CPU-defined initial value
+	 * at the time of saving (i.e. was not used by the program).
+	 *
+	 * PT_SETXSTATE: 1 indicates that the respective XSAVE component (if present
+	 * in xs_rfbm) should be set to the values in respective field.  0 indicates
+	 * that it should be reset to CPU-defined initial value.
+	 */
+	uint64_t xs_xstate_bv;
+
+	/* legacy FXSAVE area (used for x87 & SSE state) */
+	struct fxsave xs_fxsave;
+	/* AVX state: high bits of ymm0..ymm15 registers */
+	struct xsave_ymm xs_ymm_hi128;
+	/* AVX-512: opmask */
+	struct xsave_opmask xs_opmask;
+	/* AVX-512: high bits of zmm0..zmm15 registers */
+	struct xsave_zmm_hi256 xs_zmm_hi256;
+	/* AVX-512: whole zmm16..zmm31 registers */
+	struct xsave_hi16_zmm xs_hi16_zmm;
+};
+
+/*
+ * The following union is placed at the end of the pcb.
+ * It is defined this way to separate the definitions and to
+ * minimise the number of union/struct selectors.
+ * NB: Some userspace stuff (eg firefox) uses it to parse ucontext.
+ * NB: This is not actually the largest possible save space;
+ *     x86_fpu_save_size may be larger.
+ */
+union savefpu {
+	struct save87 sv_87;
+	struct fxsave sv_xmm;
+#ifdef _KERNEL
+	struct xsave_header sv_xsave_hdr;
+#endif
+};
+
+/*
+ * 80387 control and status word bits
+ *
+ * The only reference I can find to bits 0x40 and 0x80 in the control word
+ * is for the Weitek 1167/3167.
+ * I (dsl) can't find why the default word has 0x40 set.
+ *
+ * A stack error is signalled as an INVOP that also sets STACK_FAULT
+ * (other INVOP do not clear STACK_FAULT).
+ */
+/* Interrupt masks (set masks interrupt) and status bits */
+#define EN_SW_INVOP		0x0001  /* Invalid operation */
+#define EN_SW_DENORM		0x0002  /* Denormalized operand */
+#define EN_SW_ZERODIV		0x0004  /* Divide by zero */
+#define EN_SW_OVERFLOW		0x0008  /* Overflow */
+#define EN_SW_UNDERFLOW		0x0010  /* Underflow */
+#define EN_SW_PRECLOSS		0x0020  /* Loss of precision */
+/* Status word bits (reserved in control word) */
+#define EN_SW_STACK_FAULT	0x0040	/* Stack under/overflow */
+#define EN_SW_ERROR_SUMMARY	0x0080	/* Unmasked error has occurred */
+/* Control bits (badly named) */
+#define EN_SW_CTL_PREC		0x0300	/* Precision control */
+#define EN_SW_PREC_24		0x0000	/* Single precision */
+#define EN_SW_PREC_53		0x0200	/* Double precision */
+#define EN_SW_PREC_64		0x0300	/* Extended precision */
+#define EN_SW_CTL_ROUND		0x0c00	/* Rounding control */
+#define EN_SW_ROUND_EVEN	0x0000	/* Round to nearest even */
+#define EN_SW_ROUND_DOWN	0x0400	/* Round towards minus infinity */
+#define EN_SW_ROUND_UP		0x0800	/* Round towards plus infinity */
+#define EN_SW_ROUND_ZERO	0x0c00	/* Round towards zero (truncates) */
+#define EN_SW_CTL_INF		0x1000	/* Infinity control, not used  */
+
+/*
+ * The standard 0x87 control word from finit is 0x37F, giving:
+ *	round to nearest
+ *	64-bit precision
+ *	all exceptions masked.
+ *
+ * NetBSD used to select:
+ *	round to nearest
+ *	53-bit precision
+ *	all exceptions masked.
+ * Stating: 64-bit precision often gives bad results with high level
+ * languages because it makes the results of calculations depend on whether
+ * intermediate values are stored in memory or in FPU registers.
+ * Also some 'pathological divisions' give an error in the LSB because
+ * the value is first rounded up when the 64bit mantissa is generated,
+ * and then again when it is truncated to 53 bits.
+ *
+ * However the C language explicitly allows the extra precision.
+ */
+#define	__INITIAL_NPXCW__	0x037f
+/* Modern NetBSD uses the default control word.. */
+#define	__NetBSD_NPXCW__	__INITIAL_NPXCW__
+/* NetBSD before 6.99.26 forced IEEE double precision. */
+#define	__NetBSD_COMPAT_NPXCW__	0x127f
+/* FreeBSD leaves some exceptions unmasked as well. */
+#define	__FreeBSD_NPXCW__	0x1272
+/* Linux just uses the default control word. */
+#define	__Linux_NPXCW__		__INITIAL_NPXCW__
+
+/*
+ * The default MXCSR value at reset is 0x1f80, IA-32 Instruction
+ * Set Reference, pg. 3-369.
+ *
+ * The low 6 bits of the mxcsr are the fp status bits (same order as x87).
+ * Bit 6 is 'denormals are zero' (speeds up calculations).
+ * Bits 7-16 are the interrupt mask bits (same order, 1 to mask).
+ * Bits 13 and 14 are rounding control.
+ * Bit 15 is 'flush to zero' - affects underflow.
+ * Bits 16-31 must be zero.
+ *
+ * The safe MXCSR is fit for constant-time use, e.g. in crypto.  Some
+ * CPU instructions take input- dependent time if an exception status
+ * bit is not set; __SAFE_MXCSR__ has the exception status bits all set
+ * already to mitigate this.  See:
+ * https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/mxcsr-configuration-dependent-timing.html
+ */
+#define	__INITIAL_MXCSR__	0x1f80
+#define	__INITIAL_MXCSR_MASK__	0xffbf
+#define	__SAFE_MXCSR__		0x1fbf
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _X86_CPU_EXTENDED_STATE_H_ */
diff -urN --no-dereference mlibc-clean/options/nvmm/meson.build mlibc-workdir/options/nvmm/meson.build
--- mlibc-clean/options/nvmm/meson.build	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/nvmm/meson.build
@@ -0,0 +1,17 @@
+if not nvmm_option
+	subdir_done()
+endif
+
+libc_sources += files(
+	'generic/nvmm.cpp',
+)
+
+if not no_headers
+	install_headers(
+		'include/nvmm.h',
+		'include/nvmm_dev.h',
+		'include/nvmm_ioctl.h',
+		'include/nvmm_x86.h',
+		'include/nvmm_x86_cpu_extended_state.h',
+	)
+endif
diff -urN --no-dereference mlibc-clean/options/posix/generic/posix_locale.cpp mlibc-workdir/options/posix/generic/posix_locale.cpp
--- mlibc-clean/options/posix/generic/posix_locale.cpp
+++ mlibc-workdir/options/posix/generic/posix_locale.cpp
@@ -25,7 +25,7 @@
 
 locale_t uselocale(locale_t) {
 	if(!uselocale_seen) {
-		mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
+		//mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
 		uselocale_seen = true;
 	}
 	return nullptr;
diff -urN --no-dereference mlibc-clean/options/posix/generic/sys-shm.cpp mlibc-workdir/options/posix/generic/sys-shm.cpp
--- mlibc-clean/options/posix/generic/sys-shm.cpp
+++ mlibc-workdir/options/posix/generic/sys-shm.cpp
@@ -4,6 +4,7 @@
 #include <bits/ensure.h>
 #include <mlibc/debug.hpp>
 #include <mlibc/posix-sysdeps.hpp>
+#include <sys/syscall.h>
 
 void *shmat(int shmid, const void *shmaddr, int shmflg) {
 	void *ret;
@@ -17,11 +18,7 @@
 
 int shmctl(int shmid, int cmd, struct shmid_ds *buf) {
 	int ret;
-	auto sysdep = MLIBC_CHECK_OR_ENOSYS(mlibc::sys_shmctl, -1);
-	if(int e = sysdep(&ret, shmid, cmd, buf); e) {
-		errno = e;
-		return -1;
-	}
+	SYSCALL3(SYSCALL_SHMCTL, shmid, cmd, buf);
 	return ret;
 }
 
diff -urN --no-dereference mlibc-clean/options/posix/generic/unistd.cpp mlibc-workdir/options/posix/generic/unistd.cpp
--- mlibc-clean/options/posix/generic/unistd.cpp
+++ mlibc-workdir/options/posix/generic/unistd.cpp
@@ -1208,13 +1208,13 @@
 	/* deferring to fork as implementing vfork correctly requires assembly
 	 * to handle not mucking up the stack
 	 */
-	if(!mlibc::sys_fork) {
+	if(!mlibc::sys_vfork) {
 		MLIBC_MISSING_SYSDEP();
 		errno = ENOSYS;
 		return -1;
 	}
 
-	if(int e = mlibc::sys_fork(&child); e) {
+	if(int e = mlibc::sys_vfork(&child); e) {
 		errno = e;
 		return -1;
 	}
diff -urN --no-dereference mlibc-clean/options/posix/include/mlibc/posix-sysdeps.hpp mlibc-workdir/options/posix/include/mlibc/posix-sysdeps.hpp
--- mlibc-clean/options/posix/include/mlibc/posix-sysdeps.hpp
+++ mlibc-workdir/options/posix/include/mlibc/posix-sysdeps.hpp
@@ -100,6 +100,7 @@
 [[gnu::weak]] void sys_yield();
 [[gnu::weak]] int sys_sleep(time_t *secs, long *nanos);
 [[gnu::weak]] int sys_fork(pid_t *child);
+[[gnu::weak]] int sys_vfork(pid_t *child);
 [[gnu::weak]] int sys_execve(const char *path, char *const argv[], char *const envp[]);
 [[gnu::weak]] int sys_pselect(int num_fds, fd_set *read_set, fd_set *write_set,
 		fd_set *except_set, const struct timespec *timeout, const sigset_t *sigmask, int *num_events);
diff -urN --no-dereference mlibc-clean/options/posix/include/sys/ioccom.h mlibc-workdir/options/posix/include/sys/ioccom.h
--- mlibc-clean/options/posix/include/sys/ioccom.h	1970-01-01 01:00:00.000000000 +0100
+++ mlibc-workdir/options/posix/include/sys/ioccom.h
@@ -0,0 +1,82 @@
+/*	$NetBSD: ioccom.h,v 1.13 2019/05/26 10:21:33 hannken Exp $	*/
+
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioccom.h	8.3 (Berkeley) 1/9/95
+ */
+
+#ifndef	_SYS_IOCCOM_H_
+#define	_SYS_IOCCOM_H_
+
+/*
+ * Ioctl's have the command encoded in the lower word, and the size of
+ * any in or out parameters in the upper word.  The high 3 bits of the
+ * upper word are used to encode the in/out status of the parameter.
+ *
+ *	 31 29 28                     16 15            8 7             0
+ *	+---------------------------------------------------------------+
+ *	| I/O | Parameter Length        | Command Group | Command       |
+ *	+---------------------------------------------------------------+
+ */
+#define	IOCPARM_MASK	0x1fff		/* parameter length, at most 13 bits */
+#define	IOCPARM_SHIFT	16
+#define	IOCGROUP_SHIFT	8
+#define	IOCPARM_LEN(x)	(((x) >> IOCPARM_SHIFT) & IOCPARM_MASK)
+#define	IOCBASECMD(x)	((x) & ~(IOCPARM_MASK << IOCPARM_SHIFT))
+#define	IOCGROUP(x)	(((x) >> IOCGROUP_SHIFT) & 0xff)
+
+#define	IOCPARM_MAX	NBPG	/* max size of ioctl args, mult. of NBPG */
+				/* no parameters */
+#define	IOC_VOID	(unsigned long)0x20000000
+				/* copy parameters out */
+#define	IOC_OUT		(unsigned long)0x40000000
+				/* copy parameters in */
+#define	IOC_IN		(unsigned long)0x80000000
+				/* copy parameters in and out */
+#define	IOC_INOUT	(IOC_IN|IOC_OUT)
+				/* mask for IN/OUT/VOID */
+#define	IOC_DIRMASK	(unsigned long)0xe0000000
+
+#define	_IOC(inout, group, num, len) \
+    ((inout) | (((len) & IOCPARM_MASK) << IOCPARM_SHIFT) | \
+    ((group) << IOCGROUP_SHIFT) | (num))
+#define	_IO(g,n)	_IOC(IOC_VOID,	(g), (n), 0)
+#define	_IOR(g,n,t)	_IOC(IOC_OUT,	(g), (n), sizeof(t))
+#define	_IOW(g,n,t)	_IOC(IOC_IN,	(g), (n), sizeof(t))
+/* this should be _IORW, but stdio got there first */
+#define	_IOWR(g,n,t)	_IOC(IOC_INOUT,	(g), (n), sizeof(t))
+
+#define IOCSNPRINTF(buf, len, cmd) \
+    snprintf((buf), (len), "_IO%s%s('%c', %hhu)", \
+	(((cmd) >> 30) & 1) ? "R" : "", \
+	(((cmd) >> 30) & 2) ? "W" : "", \
+	(char)IOCGROUP(cmd), (unsigned char)(cmd))
+		
+
+#endif /* !_SYS_IOCCOM_H_ */
diff -urN --no-dereference mlibc-clean/options/posix/meson.build mlibc-workdir/options/posix/meson.build
--- mlibc-clean/options/posix/meson.build
+++ mlibc-workdir/options/posix/meson.build
@@ -127,6 +127,7 @@
 	install_headers(
 		'include/sys/fcntl.h',
 		'include/sys/file.h',
+		'include/sys/ioccom.h',
 		'include/sys/ipc.h',
 		'include/sys/mman.h',
 		'include/sys/msg.h',
diff -urN --no-dereference mlibc-clean/options/rtld/generic/linker.cpp mlibc-workdir/options/rtld/generic/linker.cpp
--- mlibc-clean/options/rtld/generic/linker.cpp
+++ mlibc-workdir/options/rtld/generic/linker.cpp
@@ -521,6 +521,7 @@
 		return LinkerError::outOfMemory;
 	}
 
+	mlibc::sys_vm_unmap(mappedAddr, highest_address - object->baseAddress);
 	object->baseAddress = reinterpret_cast<uintptr_t>(mappedAddr);
 #else
 	object->baseAddress = libraryBase;
diff -urN --no-dereference mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -20,18 +20,18 @@
 #include <stdbool.h>
 #include <stddef.h>
 
+#ifdef __x86_64__
+#include <nvmm.h>
+#endif
+
 extern "C" void __mlibc_sigret(void);
 
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-#ifdef __MLIBC_DEBUG
 	ssize_t unused;
-	sys_write(2, message, strlen(message), &unused);
-	sys_write(2, "\n", 1, &unused);
-#else
-	(void)message;
-#endif
+	sys_write(1, message, strlen(message), &unused);
+	sys_write(1, "\n", 1, &unused);
 }
 
 void sys_libc_panic() {
@@ -157,7 +157,7 @@
 int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
 	ssize_t ret;
 	int errno;
-	SYSCALL3(SYSCALL_READ, fd, buf, count);
+	SYSCALL5(SYSCALL_READ, fd, buf, count, 0, 0);
 	*bytes_read = ret;
 	return errno;
 }
@@ -165,7 +165,7 @@
 int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
 	ssize_t ret;
 	int errno;
-	SYSCALL3(SYSCALL_WRITE, fd, buf, count);
+	SYSCALL5(SYSCALL_WRITE, fd, buf, count, 0, 0);
 	*bytes_written = ret;
 	return errno;
 }
@@ -173,7 +173,7 @@
 int sys_pread(int fd, void *buf, size_t n, off_t off, ssize_t *bytes_read) {
 	ssize_t ret;
 	int errno;
-	SYSCALL4(SYSCALL_PREAD, fd, buf, n, off);
+	SYSCALL5(SYSCALL_READ, fd, buf, n, off, 1);
 	*bytes_read = ret;
 	return errno;
 }
@@ -181,7 +181,7 @@
 int sys_pwrite(int fd, const void *buf, size_t n, off_t off, ssize_t *bytes_written) {
 	ssize_t ret;
 	int errno;
-	SYSCALL4(SYSCALL_WRITE, fd, buf, n, off);
+	SYSCALL5(SYSCALL_WRITE, fd, buf, n, off, 1);
 	*bytes_written = ret;
 	return errno;
 }
@@ -329,9 +329,10 @@
 }
 
 int sys_getsid(pid_t pid, pid_t *sid) {
-	//  STUB.
-	(void)pid; (void)sid;
-	return 0;
+	int ret, errno;
+	SYSCALL1(SYSCALL_GETSID, pid);
+	*sid = ret;
+	return errno;
 }
 
 pid_t sys_getpid() {
@@ -408,10 +409,16 @@
 }
 
 int sys_getpgid(pid_t pid, pid_t *pgid) {
-	(void)pid;
-	// FIXME: Stub needed by mlibc.
-	*pgid = 0;
-	return 0;
+	int ret, errno;
+	SYSCALL1(SYSCALL_GETPGID, pid);
+	*pgid = ret;
+	return errno;
+}
+
+int sys_setpgid(pid_t pid, pid_t pgid) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_SETPGID, pid, pgid);
+	return errno;
 }
 
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
@@ -433,7 +440,24 @@
 	pid_t ret;
 	int errno;
 
-	SYSCALL0(SYSCALL_FORK);
+	SYSCALL1(SYSCALL_FORK, 0);
+
+	if (ret == -1) {
+		return errno;
+	}
+
+	if (child != NULL) {
+		*child = ret;
+	}
+
+	return 0;
+}
+
+int sys_vfork(pid_t *child) {
+	pid_t ret;
+	int errno;
+
+	SYSCALL1(SYSCALL_FORK, 1);
 
 	if (ret == -1) {
 		return errno;
@@ -485,12 +509,6 @@
 	return errno;
 }
 
-int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid;
-	(void)pgid;
-	return 0;
-}
-
 int sys_ttyname(int fd, char *buff, size_t size) {
 	int ret, errno;
 	SYSCALL3(SYSCALL_TTYNAME, fd, buff, size);
@@ -542,13 +560,6 @@
 int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
 	int ret, errno;
 
-	if (request == TIOCGPGRP) {
-		*result = 0;
-		return 0;
-	} else if (request == TIOCSPGRP) {
-		return 0;
-	}
-
 	SYSCALL3(SYSCALL_IOCTL, fd, request, arg);
 
 	if (ret == -1) {
@@ -842,8 +853,10 @@
 }
 
 int sys_setsid(pid_t *sid) {
-	(void)sid;
-	return 0;
+	int ret, errno;
+	SYSCALL0(SYSCALL_SETSID);
+	*sid = ret;
+	return errno;
 }
 
 #ifndef MLIBC_BUILDING_RTLD
@@ -865,7 +878,7 @@
 
 int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
 	 int ret, errno;
-	 SYSCALL5(SYSCALL_CREATE_THREAD, (uintptr_t)__mlibc_thread_entry, 0, stack, tcb, 1);
+	 SYSCALL4(SYSCALL_CREATE_THREAD, (uintptr_t)__mlibc_thread_entry, 0, stack, tcb);
 
 	 if (ret == -1) {
 		  return errno;
@@ -1240,6 +1253,9 @@
 			} else {
 				return EFAULT;
 			}
+		case _SC_THREAD_STACK_MIN:
+			*rret = 0x1000;
+			return 0;
 		default:
 			return EINVAL;
 	}
@@ -1486,5 +1502,145 @@
 	return 0;
 }
 
+#ifdef __x86_64__
+int sys_nvmm_init(void) {
+	return 0;
+}
+
+int sys_nvmm_root_init(void) {
+	return 0;
+}
+
+int sys_nvmm_capability(struct nvmm_capability *caps) {
+	int ret, errno;
+	SYSCALL1(SYSCALL_NVMM_CAPABILITY, caps);
+	return errno;
+}
+
+int sys_nvmm_machine_create(struct nvmm_machine *machine) {
+	int ret, errno;
+	SYSCALL1(SYSCALL_NVMM_MACHINE_CREATE, machine);
+	return errno;
+}
+
+int sys_nvmm_machine_destroy(struct nvmm_machine *machine) {
+	int ret, errno;
+	SYSCALL1(SYSCALL_NVMM_MACHINE_DEL, machine);
+	return errno;
+}
+
+int sys_nvmm_machine_configure(struct nvmm_machine *machine, uint64_t op, void *arg) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_NVMM_MACHINE_CONF, machine, op, arg);
+	return errno;
+}
+
+int sys_nvmm_vcpu_create(struct nvmm_machine *machine, nvmm_cpuid_t cpuid, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_NVMM_VCPU_CREATE, machine, cpuid, cpu);
+	return errno;
+}
+
+int sys_nvmm_vcpu_destroy(struct nvmm_machine *machine, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_NVMM_VCPU_DESTROY, machine, cpu);
+	return errno;
+}
+
+int sys_nvmm_vcpu_configure(struct nvmm_machine *machine, struct nvmm_vcpu *cpu, uint64_t op, void *arg) {
+	int ret, errno;
+	SYSCALL4(SYSCALL_NVMM_VCPU_CONF, machine, cpu, op, arg);
+	return errno;
+}
+
+int sys_nvmm_vcpu_setstate(struct nvmm_machine *machine, struct nvmm_vcpu *cpu, uint64_t op) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_NVMM_VCPU_SETSTATE, machine, cpu, op);
+	return errno;
+}
+
+int sys_nvmm_vcpu_getstate(struct nvmm_machine *machine, struct nvmm_vcpu *cpu, uint64_t op) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_NVMM_VCPU_GETSTATE, machine, cpu, op);
+	return errno;
+}
+
+int sys_nvmm_vcpu_inject(struct nvmm_machine *machine, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_NVMM_VCPU_INJECT, machine, cpu);
+	return errno;
+}
+
+int sys_nvmm_vcpu_run(struct nvmm_machine *machine, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_NVMM_VCPU_RUN, machine, cpu);
+	return errno;
+}
+
+int sys_nvmm_gpa_map(struct nvmm_machine *machine, uintptr_t hva, gpaddr_t gpa, size_t size, int prot) {
+	int ret, errno;
+	SYSCALL5(SYSCALL_NVMM_GPA_MAP, machine, hva, gpa, size, prot);
+	return errno;
+}
+
+int sys_nvmm_gpa_unmap(struct nvmm_machine *machine, uintptr_t hva, gpaddr_t gpa, size_t size) {
+	int ret, errno;
+	SYSCALL4(SYSCALL_NVMM_GPA_UNMAP, machine, hva, gpa, size);
+	return errno;
+}
+
+int sys_nvmm_hva_map(struct nvmm_machine *machine, uintptr_t hva, size_t size) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_NVMM_HVA_MAP, machine, hva, size);
+	return errno;
+}
+
+int sys_nvmm_hva_unmap(struct nvmm_machine *machine, uintptr_t hva, size_t size) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_NVMM_HVA_UNMAP, machine, hva, size);
+	return errno;
+}
+
+int sys_nvmm_gva_to_gpa(struct nvmm_machine *machine, struct nvmm_vcpu *cpu, gvaddr_t gva, gpaddr_t *gpa, nvmm_prot_t *prot) {
+	int ret, errno;
+	SYSCALL5(SYSCALL_NVMM_GVA2GPA, machine, cpu, gva, gpa, prot);
+	return errno;
+}
+
+int sys_nvmm_gpa_to_hva(struct nvmm_machine *machine, gpaddr_t gpa, uintptr_t *hva, nvmm_prot_t *prot) {
+	int ret, errno;
+	SYSCALL4(SYSCALL_NVMM_GPA2HVA, machine, gpa, hva, prot);
+	return errno;
+}
+
+int sys_nvmm_assist_io(struct nvmm_machine *machine, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_NVMM_ASSIST_IO, machine, cpu);
+	return errno;
+}
+
+int sys_nvmm_assist_mem(struct nvmm_machine *machine, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_NVMM_ASSIST_IO, machine, cpu);
+	return errno;
+}
+
+int sys_nvmm_ctl(int, void *, size_t) {
+	return 0;
+}
+
+int sys_nvmm_vcpu_dump(struct nvmm_machine *machine, struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_NVMM_VCPU_DUMP, machine, cpu);
+	return errno;
+}
+
+int sys_nvmm_vcpu_stop(struct nvmm_vcpu *cpu) {
+	int ret, errno;
+	SYSCALL1(SYSCALL_NVMM_VCPU_STOP, cpu);
+	return errno;
+}
+#endif
+
 #endif
 } // namespace mlibc
diff -urN --no-dereference mlibc-clean/sysdeps/ironclad/include/asm/ioctls.h mlibc-workdir/sysdeps/ironclad/include/asm/ioctls.h
--- mlibc-clean/sysdeps/ironclad/include/asm/ioctls.h
+++ mlibc-workdir/sysdeps/ironclad/include/asm/ioctls.h
@@ -97,6 +97,7 @@
 #define TIOCPKT_NOSTOP           16
 #define TIOCPKT_DOSTOP           32
 #define TIOCPKT_IOCTL            64
-#define TIOCSER_TEMT	            0x01
+#define TIOCSER_TEMT	         0x01
+#define DEV_UUID                 0x9821
 
 #endif /* _ASM_IOCTLS_H */
diff -urN --no-dereference mlibc-clean/sysdeps/ironclad/include/linux/kvm.h mlibc-workdir/sysdeps/ironclad/include/linux/kvm.h
--- mlibc-clean/sysdeps/ironclad/include/linux/kvm.h
+++ mlibc-workdir/sysdeps/ironclad/include/linux/kvm.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,146 +0,0 @@
-#ifndef _LINUX_KVM_H
-#define _LINUX_KVM_H
-
-#include <stddef.h>
-
-// KVM version supported by Ironclad.
-#define KVM_API_VERSION 12
-
-// System ioctls (to /dev/kvm).
-#define KVM_GET_API_VERSION             1
-#define KVM_CREATE_VM                   2
-#define KVM_GET_MSR_INDEX_LIST          3
-#define KVM_CHECK_EXTENSION             4
-#define KVM_GET_VCPU_MMAP_SIZE          5
-#define KVM_MEMORY_ENCRYPT_REG_REGION   6
-#define KVM_MEMORY_ENCRYPT_UNREG_REGION 7
-
-// VM ioctls.
-#define KVM_CREATE_VCPU            8
-#define KVM_GET_DIRTY_LOG          9
-#define KVM_MEMORY_ENCRYPT_OP      10
-#define KVM_SET_USER_MEMORY_REGION 11
-
-// VCPU ioctls.
-#define KVM_RUN             12
-#define KVM_GET_REGS        13
-#define KVM_SET_REGS        14
-#define KVM_GET_SREGS       15
-#define KVM_SET_SREGS       16
-#define KVM_TRANSLATE       17
-#define KVM_INTERRUPT       18
-#define KVM_GET_MSRS        19
-#define KVM_SET_MSRS        20
-#define KVM_SET_CPUID       21
-#define KVM_SET_SIGNAL_MASK 22
-#define KVM_GET_FPU         23
-#define KVM_SET_FPU         24
-
-// KVM extensions the kernel supports that can be querried with
-// KVM_CHECK_EXTENSION.
-#define KVM_CAP_USER_MEMORY 1
-#define KVM_CAP_NR_VCPUS    2
-
-// Structure to get from KVM_GET_MSR_INDEX_LIST.
-struct kvm_msr_list {
-   uint32_t nmsrs; /* number of msrs in entries */
-   uint32_t indices[0];
-} __attribute__((packed));
-
-// Structure to use for KVM_MEMORY_ENCRYPT_REG_REGION
-struct kvm_enc_region {
-   uint64_t addr;
-   uint64_t size;
-} __attribute__((packed));
-
-// Structure for KVM_GET_DIRTY_LOG.
-struct kvm_dirty_log {
-   uint32_t slot;
-   uint32_t padding;
-   void *dirty_bitmap;
-} __attribute__((packed));
-
-// Memory structure to pass to KVM_SET_USER_MEMORY_REGION.
-#define KVM_MEM_READONLY (1 << 1)
-struct kvm_userspace_mem_region {
-   uint32_t slot;
-   uint32_t flags;
-   uint64_t guest_phys_addr;
-   uint64_t memory_size;
-   uint64_t userspace_addr;
-} __attribute__((packed));
-
-// Structure for x86's KVM_GET_REGS/KVM_SET_REGS
-struct kvm_regs {
-   uint64_t rax, rbx, rcx, rdx;
-   uint64_t rsi, rdi, rsp, rbp;
-   uint64_t r8,  r9,  r10, r11;
-   uint64_t r12, r13, r14, r15;
-   uint64_t rip, rflags;
-} __attribute__((packed));
-
-// Structure for KVM_TRANSLATE.
-struct kvm_translation {
-   uint64_t linear_address;
-   uint64_t physical_address;
-   uint8_t  valid;
-   uint8_t  writeable;
-   uint8_t  usermode;
-   uint8_t  pad[5];
-} __attribute__((packed));
-
-// Structure for KVM_INTERRUPT.
-struct kvm_interrupt {
-   uint32_t irq;
-} __attribute__((packed));
-
-// Structure for KVM_GET_MSRS/KVM_SET_MSRS.
-struct kvm_msrs {
-   uint32_t nmsrs;
-   struct kvm_msr_entry entries[0];
-} __attribute__((packed));
-
-struct kvm_msr_entry {
-   uint32_t index;
-   uint32_t reserved;
-   uint64_t data;
-} __attribute__((packed));
-
-// Structure for KVM_SET_CPUID.
-struct kvm_cpuid_entry {
-   uint32_t function;
-   uint32_t eax;
-   uint32_t ebx;
-   uint32_t ecx;
-   uint32_t edx;
-   uint32_t padding;
-} __attribute__((packed));
-
-struct kvm_cpuid {
-   uint32_t nent;
-   uint32_t padding;
-   struct kvm_cpuid_entry entries[0];
-} __attribute__((packed));
-
-// Structure for KVM_SET_SIGNAL_MASK.
-struct kvm_signal_mask {
-   uint32_t len;
-   uint8_t sigset[0];
-} __attribute__((packed));
-
-// Structure for x86's KVM_GET_FPU / KVM_SET_FPU.
-struct kvm_fpu {
-   uint8_t  fpr[8][16];
-   uint16_t fcw;
-   uint16_t fsw;
-   uint8_t  ftwx;  /* in fxsave format */
-   uint8_t  pad1;
-   uint16_t last_opcode;
-   uint64_t last_ip;
-   uint64_t last_dp;
-   uint8_t  xmm[16][16];
-   uint32_t mxcsr;
-   uint32_t pad2;
-} __attribute__((packed));
-
-#endif /* _LINUX_KVM_H */
diff -urN --no-dereference mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -31,13 +31,14 @@
 #define SYSCALL_CHDIR                19
 #define SYSCALL_IOCTL                20
 #define SYSCALL_SCHED_YIELD          21
-#define SYSCALL_DELETE_TCLUSTER      22
+#define SYSCALL_GET_MIN_PRIO         22
 #define SYSCALL_PIPE                 23
 #define SYSCALL_GETUID               24
 #define SYSCALL_RENAME               25
 #define SYSCALL_LISTPROCS            26
+#define SYSCALL_GETSID               27
 #define SYSCALL_GETTID               28
-#define SYSCALL_MANAGE_TCLUSTER      29
+#define SYSCALL_GET_MAX_PRIO         29
 #define SYSCALL_FCNTL                30
 #define SYSCALL_EXIT_THREAD          31
 #define SYSCALL_GETENTROPY           32
@@ -72,8 +73,8 @@
 #define SYSCALL_UMASK                61
 #define SYSCALL_REBOOT               62
 #define SYSCALL_FCHOWN               63
-#define SYSCALL_PREAD                64
-#define SYSCALL_PWRITE               65
+#define SYSCALL_GETPGID              64
+#define SYSCALL_SETPGID              65
 #define SYSCALL_GETSOCKNAME          66
 #define SYSCALL_GETPEERNAME          67
 #define SYSCALL_SHUTDOWN             68
@@ -85,8 +86,8 @@
 #define SYSCALL_SENDTO               74
 #define SYSCALL_CONFIG_NETINTER      75
 #define SYSCALL_UTIMES               76
-#define SYSCALL_CREATE_TCLUSTER      77
-#define SYSCALL_SWITCH_TCLUSTER      78
+#define SYSCALL_GET_SCHEDULER        77
+#define SYSCALL_SET_SCHEDULER        78
 #define SYSCALL_SIGPROCMASK          79
 #define SYSCALL_SIGACTION            80
 #define SYSCALL_SEND_SIGNAL          81
@@ -115,7 +116,6 @@
 #define SYSCALL_LISTMOUNTS          104
 #define SYSCALL_UNAME               105
 #define SYSCALL_LISTTHREADS         106
-#define SYSCALL_LISTCLUSTERS        107
 #define SYSCALL_LISTNETINTER        108
 #define SYSCALL_DUMPLOGS            109
 #define SYSCALL_LISTFLOCKS          110
@@ -125,6 +125,28 @@
 #define SYSCALL_GETCPUINFO          114
 #define SYSCALL_SOCKETPAIR          115
 #define SYSCALL_MADVISE             116
+#define SYSCALL_NVMM_CAPABILITY     117
+#define SYSCALL_NVMM_MACHINE_CREATE 118
+#define SYSCALL_NVMM_MACHINE_DEL    119
+#define SYSCALL_NVMM_MACHINE_CONF   120
+#define SYSCALL_NVMM_VCPU_CREATE    121
+#define SYSCALL_NVMM_VCPU_DESTROY   122
+#define SYSCALL_NVMM_VCPU_CONF      123
+#define SYSCALL_NVMM_VCPU_SETSTATE  124
+#define SYSCALL_NVMM_VCPU_GETSTATE  125
+#define SYSCALL_NVMM_VCPU_INJECT    126
+#define SYSCALL_NVMM_VCPU_RUN       127
+#define SYSCALL_NVMM_GPA_MAP        128
+#define SYSCALL_NVMM_GPA_UNMAP      129
+#define SYSCALL_NVMM_HVA_MAP        130
+#define SYSCALL_NVMM_HVA_UNMAP      131
+#define SYSCALL_NVMM_GVA2GPA        132
+#define SYSCALL_NVMM_GPA2HVA        133
+#define SYSCALL_NVMM_ASSIST_IO      134
+#define SYSCALL_NVMM_ASSIST_MEM     135
+#define SYSCALL_NVMM_VCPU_DUMP      136
+#define SYSCALL_NVMM_VCPU_STOP      137
+#define SYSCALL_SETSID              138
 
 #if defined(__x86_64__)
 #define SYSCALL0(NUM) ({ \
diff -urN --no-dereference mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -3,6 +3,7 @@
 	'linux': false,
 	'glibc': true,
 	'bsd': true,
+	'nvmm': host_machine.cpu_family() == 'x86_64',
 }
 
 rtld_sources += files(
@@ -88,7 +89,6 @@
 
 	install_headers(
 		'include/linux/fb.h',
-		'include/linux/kvm.h',
 		subdir: 'linux'
 	)
 
