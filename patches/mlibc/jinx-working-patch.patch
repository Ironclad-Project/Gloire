diff --git mlibc-clean/abis/ironclad/fcntl.h mlibc-workdir/abis/ironclad/fcntl.h
index d1e9f02..0e60dd2 100644
--- mlibc-clean/abis/ironclad/fcntl.h
+++ mlibc-workdir/abis/ironclad/fcntl.h
@@ -8,6 +8,7 @@
 #define O_RDWR   3
 #define O_SEARCH 4
 #define O_EXEC   7
+#define O_CLOEXEC 16
 
 // This flags are stubs.
 #define O_APPEND 0x00008
@@ -21,7 +22,6 @@
 #define O_DSYNC 0x00800
 #define O_RSYNC 0x01000
 #define O_SYNC 0x02000
-#define O_CLOEXEC 0x04000
 #define O_PATH 0x08000
 #define O_LARGEFILE 0x10000
 #define O_NOATIME 0x20000
diff --git mlibc-clean/options/posix/generic/unistd-stubs.cpp mlibc-workdir/options/posix/generic/unistd-stubs.cpp
index e2c40ce..0a170e5 100644
--- mlibc-clean/options/posix/generic/unistd-stubs.cpp
+++ mlibc-workdir/options/posix/generic/unistd-stubs.cpp
@@ -684,8 +684,8 @@ unsigned long sysconf(int number) {
 			return mlibc::page_size;
 		case _SC_OPEN_MAX:
 			// TODO: actually return a proper value for _SC_OPEN_MAX
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns arbitrary value 256\e[39m" << frg::endlog;
-			return 256;
+			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns arbitrary value 100\e[39m" << frg::endlog;
+			return 100;
 		case _SC_PHYS_PAGES:
 			// TODO: actually return a proper value for _SC_PHYS_PAGES
 			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_PHYS_PAGES) returns arbitrary value 1024\e[39m" << frg::endlog;
diff --git mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S
new file mode 100644
index 0000000..911b078
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S
new file mode 100644
index 0000000..0187e50
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index d6dbca3..ad27735 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -10,18 +10,16 @@
 #include <string.h>
 #include <stdio.h>
 #include <sys/syscall.h>
+#include <sys/ironclad.h>
+#include <sched.h>
 
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-	/*
 	ssize_t unused;
 	char new_line = '\n';
 	sys_write(1, message, strlen(message), &unused);
 	sys_write(1, &new_line, 1, &unused);
-	*/
-	(void)message;
-	return;
 }
 
 void sys_libc_panic() {
@@ -39,7 +37,7 @@ void sys_exit(int status) {
 
 int sys_tcb_set(void *pointer) {
 	int ret, errno;
-	SYSCALL1(SYSCALL_SET_TCB, pointer);
+	SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
 	return errno;
 }
 
@@ -113,6 +111,16 @@ int sys_vm_unmap(void *pointer, size_t size) {
 	}
 }
 
+int sys_vm_protect(void *pointer, size_t size, int prot) {
+	int ret;
+	int errno;
+	SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
+	if (ret != 0) {
+		return errno;
+	}
+	return 0;
+}
+
 pid_t sys_getpid() {
 	pid_t ret;
 	int errno;
@@ -131,96 +139,61 @@ int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *old
 	(void)signum;
 	(void)act;
 	(void)oldact;
-	mlibc::infoLogger() << "sigaction() is a stub" << frg::endlog;
+	// FIXME: Stub.
 	return 0;
 }
 
 int sys_fcntl(int fd, int request, va_list args, int *result) {
-	(void)fd;
-	(void)request;
-	(void)args;
-	(void)result;
-	mlibc::infoLogger() << "fcntl() is a stub!" << frg::endlog;
-	return 0;
+	int ret, errno;
+	SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
+	*result = ret;
+	return errno;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
 	(void)how;
 	(void)set;
 	(void)retrieve;
-	mlibc::infoLogger() << "sigprocmask() is a stub!" << frg::endlog;
+	// FIXME: Stub.
 	return ENOSYS;
 }
 
-int sys_ttyname(int fd, char *buf, size_t size) {
-	(void)fd;
-	(void)buf;
-	(void)size;
-	mlibc::infoLogger() << "ttyname() is a stub!" << frg::endlog;
-	return ENOSYS;
-}
-
-int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid;
-	(void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
-	return 0;
-}
-
-int sys_pselect(int num_fds, fd_set *read_set, fd_set *write_set, fd_set *except_set,
-	const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
-	(void)num_fds;
-	(void)read_set;
-	(void)write_set;
-	(void)except_set;
-	(void)timeout;
-	(void)sigmask;
-	(void)num_events;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
-}
-
 int sys_isatty(int fd) {
-	(void)fd;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+	struct termios t;
+	if (sys_tcgetattr(fd, &t) == 0) {
+		return 0;
+	} else {
+		return ENOTTY;
+	}
 }
 
 uid_t sys_getuid() {
-	mlibc::infoLogger() << "getuid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 uid_t sys_geteuid() {
-	mlibc::infoLogger() << "geteuid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 gid_t sys_getgid() {
-	mlibc::infoLogger() << "getgid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 gid_t sys_getegid() {
-	mlibc::infoLogger() << "getegid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
 	(void)pid;
-	mlibc::infoLogger() << "getpgid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	*pgid = 0;
 	return 0;
 }
 
-int sys_clock_get(int clock, time_t *secs, long *nanos) {
-	(void)clock;
-	(void)secs;
-	(void)nanos;
-	mlibc::infoLogger() << "clock_get() is a stub" << frg::endlog;
-	return 0;
-}
-
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
 	int ret, errno;
 
@@ -234,17 +207,19 @@ int sys_execve(const char *path, char *const argv[], char *const envp[]) {
 }
 
 int sys_fork(pid_t *child) {
-    pid_t ret;
-    int errno;
+	pid_t ret;
+	int errno;
 
-    SYSCALL0(SYSCALL_FORK);
+	SYSCALL0(SYSCALL_FORK);
 
-    if (ret == -1) {
-        return errno;
-    }
+	if (ret == -1) {
+		return errno;
+	}
 
-    *child = ret;
-    return 0;
+	if (child != NULL) {
+		*child = ret;
+	}
+	return 0;
 }
 
 int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
@@ -452,8 +427,49 @@ int sys_futex_wake(int *pointer) {
 	__builtin_unreachable();
 }
 
+int sys_getentropy(void *buffer, size_t length) {
+	ssize_t ret;
+	int errno;
+	SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
+	return errno;
+}
+
 #ifndef MLIBC_BUILDING_RTDL
 
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+	switch (clock) {
+		case CLOCK_REALTIME: {
+			// Use the RTC interface, there is no native kernel entity.
+			// RTC gives true month and year, substract to make epoch.
+			int fd, ret;
+			struct rtc_time rtc;
+			struct tm tm;
+			if (sys_open("/dev/rtc", O_RDONLY, 0, &fd) ||
+				 sys_ioctl(fd, RTC_RD_TIME, &rtc, &ret))
+			{
+				return -1;
+			}
+			tm = {
+				.tm_sec  = rtc.tm_sec,
+				.tm_min  = rtc.tm_min,
+				.tm_hour = rtc.tm_hour,
+				.tm_mday = rtc.tm_mday,
+				.tm_mon  = rtc.tm_mon  - 1,
+				.tm_year = rtc.tm_year - 1900,
+				.tm_wday = rtc.tm_wday,
+				.tm_yday = rtc.tm_yday,
+				.tm_isdst = rtc.tm_isdst
+			};
+			*nanos = 0;
+			*secs  = mktime(&tm);
+			sys_close (fd);
+			return 0;
+		}
+		default:
+			return -1;
+	}
+}
+
 int sys_gethostname(char *buffer, size_t bufsize) {
 	struct utsname buf;
 	if (uname(&buf)) {
@@ -495,3 +511,70 @@ int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat
 
 #endif
 } // namespace mlibc
+
+#ifndef MLIBC_BUILDING_RTDL
+extern "C" {
+// Syscalls for ironclad.h
+int get_thread_sched(void) {
+	int ret, errn;
+	SYSCALL0(SYSCALL_GET_THREAD_SCHED);
+	errno = errn;
+	return ret;
+}
+
+int set_thread_sched(int flags) {
+	int ret, errn;
+	SYSCALL1(SYSCALL_SET_THREAD_SCHED, flags);
+	errno = errn;
+	return ret;
+}
+
+pid_t program_spawn(const char *path, char *const argv[], char *const envp[]) {
+	pid_t ret;
+	int errn;
+	SYSCALL3(SYSCALL_SPAWN, path, argv, envp);
+	errno = errn;
+	return ret;
+}
+
+int crypto_request(unsigned long request, void *argument) {
+	int ret;
+	int errn;
+	SYSCALL2(SYSCALL_CRYPTO_REQUEST, request, argument);
+	errno = errn;
+	return ret;
+}
+
+int set_mac_capabilities(unsigned long request) {
+	int ret;
+	int errn;
+	SYSCALL1(SYSCALL_SET_MAC_CAPABILITIES, request);
+	errno = errn;
+	return ret;
+}
+
+int lock_mac(void) {
+	int ret;
+	int errn;
+	SYSCALL0(SYSCALL_LOCK_MAC);
+	errno = errn;
+	return ret;
+}
+
+int add_mac_filter(struct mac_filter *filt) {
+	int ret;
+	int errn;
+	SYSCALL1(SYSCALL_ADD_MAC_FILTER, filt);
+	errno = errn;
+	return ret;
+}
+
+int set_mac_enforcement(unsigned long enforcement) {
+	int ret;
+	int errn;
+	SYSCALL1(SYSCALL_SET_MAC_ENFORCEMENT, enforcement);
+	errno = errn;
+	return ret;
+}
+}
+#endif
diff --git mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h mlibc-workdir/sysdeps/ironclad/include/sys/ironclad.h
index 89a3851..086c244 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/ironclad.h
@@ -3,6 +3,7 @@
 
 #include <stdint.h>
 #include <stdbool.h>
+#include <sys/types.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -11,16 +12,10 @@ extern "C" {
 #define FB_DIMENSIONS 1
 
 struct ironclad_fb_dimensions {
-	uint16_t width;
-	uint16_t height;
-	uint16_t pitch;
-	uint16_t bpp;
-	uint8_t  red_mask_size;
-	uint8_t  red_mask_shift;
-	uint8_t  green_mask_size;
-	uint8_t  green_mask_shift;
-	uint8_t  blue_mask_size;
-	uint8_t  blue_mask_shift;
+	uint32_t width;
+	uint32_t height;
+	uint32_t pitch;
+	uint8_t  bpp;
 };
 
 #define PS2MOUSE_2_1_SCALING     1
@@ -34,6 +29,74 @@ struct ironclad_mouse_data {
 	bool is_left;
 	bool is_right;
 };
+
+#define RTC_RD_TIME  1
+#define RTC_SET_TIME 2
+
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;     /* unused */
+	int tm_yday;     /* unused */
+	int tm_isdst;    /* unused */
+};
+
+// Syscalls declared on the documentation, but without libc equivalents.
+// Implemented in generic.cpp
+#define THREAD_RT     0b0001
+#define THREAD_MONO   0b0010
+#define THREAD_MLOCK  0b0100
+#define THREAD_BANNED 0b1000
+int get_thread_sched(void);
+int set_thread_sched(int flags);
+
+pid_t program_spawn(const char *path, char *const argv[], char *const envp[]);
+
+
+#define CRYPTO_AES128_ECB_ENCRYPT 0
+#define CRYPTO_AES128_ECB_DECRYPT 1
+#define CRYPTO_AES128_CBC_ENCRYPT 2
+#define CRYPTO_AES128_CBC_DECRYPT 3
+
+struct aes_data {
+   __int128 key;
+   __int128 iv;
+   void *data;
+   int length;
+};
+
+int crypto_request(unsigned long request, void *argument);
+
+#define MAC_EXIT_ITSELF   0b000001
+#define MAC_CREATE_OTHERS 0b000010
+#define MAC_CHANGE_SCHED  0b000100
+#define MAC_ACC_ENTROPY   0b001000
+#define MAC_ALLOC_MEM     0b010000
+#define MAC_DEALLOC_MEM   0b100000
+int set_mac_capabilities(unsigned long request);
+int lock_mac(void);
+
+#define MAC_FILTER_INC_FILES 0b0000001
+#define MAC_FILTER_INC_DIRS  0b0000010
+#define MAC_FILTER_R         0b0000100
+#define MAC_FILTER_W         0b0001000
+#define MAC_FILTER_EXEC      0b0010000
+struct mac_filter {
+    char    path[75];
+    int     length;
+    uint8_t perms;
+};
+int add_mac_filter(struct mac_filter *filt);
+
+#define MAC_DENY            0b001
+#define MAC_DENY_AND_SCREAM 0b010
+#define MAC_KILL            0b100
+int set_mac_enforcement(unsigned long enforcement);
+
 #ifdef __cplusplus
 }
 #endif
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index 28d233e..6685c97 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -49,7 +49,7 @@
 })
 
 #define SYSCALL_EXIT               0
-#define SYSCALL_SET_TCB            1
+#define SYSCALL_ARCH_PRCTL         1
 #define SYSCALL_OPEN               2
 #define SYSCALL_CLOSE              3
 #define SYSCALL_READ               4
@@ -76,5 +76,16 @@
 #define SYSCALL_DUP2              25
 #define SYSCALL_DUP3              26
 #define SYSCALL_ACCESS            27
+#define SYSCALL_GET_THREAD_SCHED  28
+#define SYSCALL_SET_THREAD_SCHED  29
+#define SYSCALL_FCNTL             30
+#define SYSCALL_SPAWN             31
+#define SYSCALL_GETRANDOM         32
+#define SYSCALL_MPROTECT          33
+#define SYSCALL_CRYPTO_REQUEST    34
+#define SYSCALL_SET_MAC_CAPABILITIES 35
+#define SYSCALL_LOCK_MAC             36
+#define SYSCALL_ADD_MAC_FILTER       37
+#define SYSCALL_SET_MAC_ENFORCEMENT  38
 
 #endif // _SYSCALL_H
diff --git mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
index 09c724d..fdf5b48 100644
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -69,5 +69,23 @@ if not headers_only
 		install: true,
 		install_dir: get_option('libdir')
 	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
 endif
 
