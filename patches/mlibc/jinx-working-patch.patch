diff --git mlibc-clean/abis/ironclad/termios.h mlibc-workdir/abis/ironclad/termios.h
index 42784b7..7102d94 100644
--- mlibc-clean/abis/ironclad/termios.h
+++ mlibc-workdir/abis/ironclad/termios.h
@@ -32,6 +32,9 @@ typedef unsigned int tcflag_t;
 #define IXOFF   0x0200
 #define IXON    0x0400
 #define PARMRK  0x0800
+#define ECHOCTL 0001000
+#define IMAXBEL 0020000
+#define ECHOKE  0004000
 
 // bitwise flags for c_oflag in struct termios
 #define OPOST   0x0001
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..1ce0414 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -2,8 +2,7 @@
 #include <bits/ensure.h>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..011d9c0 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -91,9 +91,9 @@ bool charset::is_space(codepoint c) {
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
+	/*if(c > 0x7F)
 		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+				" for the full Unicode charset" << frg::endlog;*/
 	return false;
 }
 
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 76b85dc..d267b53 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -483,9 +483,16 @@ int strcoll_l(const char *, const char *, locale_t) {
 	__builtin_unreachable();
 }
 
-int getloadavg(double *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+#include <sys/syscall.h>
+
+int getloadavg(double *samples, int nsample) {
+	int ret;
+	int samples2[3];
+	SYSCALL3(SYSCALL_SYSCONF, 19, samples2, sizeof(samples2));
+	for (int i = 0; i < 3; i++) {
+		samples[i] = samples2[i] / 100.0;
+	}
+	return 3;
 }
 
 char *secure_getenv(const char *name) {
diff --git mlibc-clean/options/posix/generic/sys-shm.cpp mlibc-workdir/options/posix/generic/sys-shm.cpp
index 3af7e90..a02d4a2 100644
--- mlibc-clean/options/posix/generic/sys-shm.cpp
+++ mlibc-workdir/options/posix/generic/sys-shm.cpp
@@ -2,23 +2,29 @@
 
 #include <bits/ensure.h>
 #include <mlibc/debug.hpp>
+#include <sys/syscall.h>
+#include <errno.h>
 
-void *shmat(int, const void *, int) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+void *shmat(int shmid, const void *shmaddr, int shmflg) {
+	void *ret;
+	SYSCALL3(SYSCALL_SHMAT, shmid, shmaddr, shmflg);
+	return ret;
 }
 
-int shmctl(int, int, struct shmid_ds *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+int shmctl(int shmid, int cmd, struct shmid_ds *buf) {
+	int ret;
+	SYSCALL3(SYSCALL_SHMCTL, shmid, cmd, buf);
+	return ret;
 }
 
-int shmdt(const void *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+int shmdt(const void *shmaddr) {
+	int ret;
+	SYSCALL1(SYSCALL_SHMDT, shmaddr);
+	return ret;
 }
 
-int shmget(key_t, size_t, int) {
-	mlibc::infoLogger() << "mlibc: shmget() is a no-op!" << frg::endlog;
-	return -1;
+int shmget(key_t key, size_t size, int shmflg) {
+	int ret;
+	SYSCALL3(SYSCALL_SHMGET, key, size, shmflg);
+	return ret;
 }
diff --git mlibc-clean/options/posix/include/fcntl.h mlibc-workdir/options/posix/include/fcntl.h
index 9983219..b43929d 100644
--- mlibc-clean/options/posix/include/fcntl.h
+++ mlibc-workdir/options/posix/include/fcntl.h
@@ -62,9 +62,6 @@ ssize_t vmsplice(int fd, const struct iovec *iov, size_t nr_segs, unsigned int f
 
 #define AT_NO_AUTOMOUNT 0x800
 
-#define F_SETPIPE_SZ 1031
-#define F_GETPIPE_SZ 1032
-
 #define FALLOC_FL_KEEP_SIZE 1
 #define FALLOC_FL_PUNCH_HOLE 2
 
diff --git mlibc-clean/options/posix/include/unistd.h mlibc-workdir/options/posix/include/unistd.h
index 6d11154..28fde4e 100644
--- mlibc-clean/options/posix/include/unistd.h
+++ mlibc-workdir/options/posix/include/unistd.h
@@ -94,103 +94,117 @@ extern "C" {
 
 // MISSING: _PC macros
 // For now, use the Linux ABI for _PC constants.
-#define _PC_LINK_MAX		0
-#define _PC_MAX_CANON		1
-#define _PC_MAX_INPUT		2
-#define _PC_NAME_MAX		3
-#define _PC_PATH_MAX		4
-#define _PC_PIPE_BUF		5
-#define _PC_CHOWN_RESTRICTED	6
-#define _PC_NO_TRUNC		7
-#define _PC_VDISABLE		8
+#define _PC_LINK_MAX    0
+#define _PC_MAX_CANON      1
+#define _PC_MAX_INPUT      2
+#define _PC_NAME_MAX    3
+#define _PC_PATH_MAX    4
+#define _PC_PIPE_BUF    5
+#define _PC_CHOWN_RESTRICTED  6
+#define _PC_NO_TRUNC    7
+#define _PC_VDISABLE    8
 
 #define _PC_FILESIZEBITS 9
 #define _PC_SYMLINK_MAX 10
 
-// MISSING: remaining _SC_macros
-#define _SC_ARG_MAX 0
-#define _SC_GETPW_R_SIZE_MAX 1
-#define _SC_PHYS_PAGES 2
-#define _SC_PAGE_SIZE 3
-#define _SC_PAGESIZE _SC_PAGE_SIZE
-#define _SC_OPEN_MAX 5
+// Kernel-supported ABI SC flags
+// TODO: This should be moved to its own abi but the mlibc people wont let
+// me do so without CBT.
+#define _SC_PAGESIZE         1
+#define _SC_OPEN_MAX         2
+#define _SC_HOST_NAME_MAX    3
+#define _SC_AVPHYS_PAGES     4
+#define _SC_PHYS_PAGES       5
 #define _SC_NPROCESSORS_ONLN 6
-#define _SC_GETGR_R_SIZE_MAX 7
-
-#define _SC_CHILD_MAX 8
-#define _SC_CLK_TCK 9
-#define _SC_NGROUPS_MAX 10
-#define _SC_VERSION 11
-#define _SC_SAVED_IDS 12
-#define _SC_JOB_CONTROL 13
-#define _SC_HOST_NAME_MAX 14
-#define _SC_LINE_MAX 15
-#define _SC_XOPEN_CRYPT 16
-#define _SC_NPROCESSORS_CONF 17
-#define _SC_SYMLOOP_MAX 18
-#define _SC_TTY_NAME_MAX 19
-#define _SC_RE_DUP_MAX 20
-
-#define _SC_ATEXIT_MAX 21
-#define _SC_LOGIN_NAME_MAX 22
-#define _SC_THREAD_DESTRUCTOR_ITERATIONS 23
-#define _SC_THREAD_KEYS_MAX 24
-#define _SC_THREAD_STACK_MIN 25
-#define _SC_THREAD_THREADS_MAX 26
-#define _SC_TZNAME_MAX 27
-#define _SC_ASYNCHRONOUS_IO 28
-#define _SC_FSYNC 29
-#define _SC_MAPPED_FILES 30
-#define _SC_MEMLOCK 31
-#define _SC_MEMLOCK_RANGE 32
-#define _SC_MEMORY_PROTECTION 33
-#define _SC_MESSAGE_PASSING 34
-#define _SC_PRIORITY_SCHEDULING 35
-#define _SC_REALTIME_SIGNALS 36
-#define _SC_SEMAPHORES 37
-#define _SC_SHARED_MEMORY_OBJECTS 38
-#define _SC_SYNCHRONIZED_IO 39
-#define _SC_THREADS 40
-#define _SC_THREAD_ATTR_STACKADDR 41
-#define _SC_THREAD_ATTR_STACKSIZE 42
-#define _SC_THREAD_PRIORITY_SCHEDULING 43
-#define _SC_THREAD_PRIO_INHERIT 44
-#define _SC_THREAD_PRIO_PROTECT 45
-#define _SC_THREAD_PROCESS_SHARED 46
-#define _SC_THREAD_SAFE_FUNCTIONS 47
-#define _SC_TIMERS 48
-#define _SC_TIMER_MAX 49
-#define _SC_2_CHAR_TERM 50
-#define _SC_2_C_BIND 51
-#define _SC_2_C_DEV 52
-#define _SC_2_FORT_DEV 53
-#define _SC_2_FORT_RUN 54
-#define _SC_2_LOCALEDEF 55
-#define _SC_2_SW_DEV 56
-#define _SC_2_UPE 57
-#define _SC_2_VERSION 58
-#define _SC_CLOCK_SELECTION 59
-#define _SC_CPUTIME 60
-#define _SC_THREAD_CPUTIME 61
-#define _SC_MONOTONIC_CLOCK 62
-#define _SC_READER_WRITER_LOCKS 63
-#define _SC_SPIN_LOCKS 64
-#define _SC_REGEXP 65
-#define _SC_SHELL 66
-#define _SC_SPAWN 67
-#define _SC_2_PBS 68
-#define _SC_2_PBS_ACCOUNTING 69
-#define _SC_2_PBS_LOCATE 70
-#define _SC_2_PBS_TRACK 71
-#define _SC_2_PBS_MESSAGE 72
-#define _SC_STREAM_MAX 73
-#define _SC_AIO_LISTIO_MAX 74
-#define _SC_AIO_MAX 75
-#define _SC_DELAYTIMER_MAX 76
-#define _SC_MQ_OPEN_MAX 77
-#define _SC_MQ_PRIO_MAX 78
-#define _SC_RTSIG_MAX 79
-#define _SC_SIGQUEUE_MAX 80
+#define _SC_TOTAL_PAGES      7
+#define _SC_LIST_PROCS       8
+#define _SC_LIST_MOUNTS      9
+#define _SC_UNAME            10
+#define _SC_CHILD_MAX        11
+#define _SC_LIST_THREADS     12
+#define _SC_LIST_CLUSTERS    13
+#define _SC_LIST_NETINTER    14
+#define _SC_DUMPLOGS         15
+#define _SC_NGROUPS_MAX      16
+#define _SC_SYMLOOP_MAX      17
+
+// SC Aliases
+#define _SC_PAGE_SIZE _SC_PAGESIZE
+
+// The rest of libc-emulated SC macros
+// MISSING: remaining _SC_macros
+#define _SC_ARG_MAX                      18
+#define _SC_GETPW_R_SIZE_MAX             19
+#define _SC_GETGR_R_SIZE_MAX             20
+#define _SC_CLK_TCK                      21
+#define _SC_VERSION                      22
+#define _SC_SAVED_IDS                    23
+#define _SC_JOB_CONTROL                  24
+#define _SC_LINE_MAX                     25
+#define _SC_XOPEN_CRYPT                  26
+#define _SC_NPROCESSORS_CONF             27
+#define _SC_TTY_NAME_MAX                 28
+#define _SC_RE_DUP_MAX                   29
+#define _SC_ATEXIT_MAX                   30
+#define _SC_LOGIN_NAME_MAX               31
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS 32
+#define _SC_THREAD_KEYS_MAX              33
+#define _SC_THREAD_STACK_MIN             34
+#define _SC_THREAD_THREADS_MAX           35
+#define _SC_TZNAME_MAX                   36
+#define _SC_ASYNCHRONOUS_IO              37
+#define _SC_FSYNC                        38
+#define _SC_MAPPED_FILES                 39
+#define _SC_MEMLOCK                      40
+#define _SC_MEMLOCK_RANGE                41
+#define _SC_MEMORY_PROTECTION            42
+#define _SC_MESSAGE_PASSING              43
+#define _SC_PRIORITY_SCHEDULING          44
+#define _SC_REALTIME_SIGNALS             45
+#define _SC_SEMAPHORES                   46
+#define _SC_SHARED_MEMORY_OBJECTS        47
+#define _SC_SYNCHRONIZED_IO              48
+#define _SC_THREADS                      49
+#define _SC_THREAD_ATTR_STACKADDR        50
+#define _SC_THREAD_ATTR_STACKSIZE        51
+#define _SC_THREAD_PRIORITY_SCHEDULING   52
+#define _SC_THREAD_PRIO_INHERIT          53
+#define _SC_THREAD_PRIO_PROTECT          54
+#define _SC_THREAD_PROCESS_SHARED        55
+#define _SC_THREAD_SAFE_FUNCTIONS        56
+#define _SC_TIMERS                       57
+#define _SC_TIMER_MAX                    58
+#define _SC_2_CHAR_TERM                  59
+#define _SC_2_C_BIND                     60
+#define _SC_2_C_DEV                      61
+#define _SC_2_FORT_DEV                   62
+#define _SC_2_FORT_RUN                   63
+#define _SC_2_LOCALEDEF                  64
+#define _SC_2_SW_DEV                     65
+#define _SC_2_UPE                        66
+#define _SC_2_VERSION                    67
+#define _SC_CLOCK_SELECTION              68
+#define _SC_CPUTIME                      69
+#define _SC_THREAD_CPUTIME               70
+#define _SC_MONOTONIC_CLOCK              71
+#define _SC_READER_WRITER_LOCKS          72
+#define _SC_SPIN_LOCKS                   73
+#define _SC_REGEXP                       74
+#define _SC_SHELL                        75
+#define _SC_SPAWN                        76
+#define _SC_2_PBS                        78
+#define _SC_2_PBS_ACCOUNTING             79
+#define _SC_2_PBS_LOCATE                 80
+#define _SC_2_PBS_TRACK                  81
+#define _SC_2_PBS_MESSAGE                82
+#define _SC_STREAM_MAX                   83
+#define _SC_AIO_LISTIO_MAX               84
+#define _SC_AIO_MAX                      85
+#define _SC_DELAYTIMER_MAX               86
+#define _SC_MQ_OPEN_MAX                  88
+#define _SC_MQ_PRIO_MAX                  89
+#define _SC_RTSIG_MAX                    90
+#define _SC_SIGQUEUE_MAX                 91
 
 #define STDERR_FILENO 2
 #define STDIN_FILENO 0
diff --git mlibc-clean/options/rtdl/generic/linker.cpp mlibc-workdir/options/rtdl/generic/linker.cpp
index a0f2bf5..4c3a8c6 100644
--- mlibc-clean/options/rtdl/generic/linker.cpp
+++ mlibc-workdir/options/rtdl/generic/linker.cpp
@@ -514,18 +514,25 @@ void ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
 
 				void *map_pointer;
 				if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
-						total_map_size, prot | PROT_WRITE,
+						total_map_size, PROT_WRITE,
 						MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
 					__ensure(!"sys_vm_map failed");
 
 				seekOrDie(fd, phdr->p_offset);
 				readExactlyOrDie(fd, reinterpret_cast<char *>(map_address) + misalign,
 						phdr->p_filesz);
+
+				if (prot & PROT_EXEC) {
+				   prot = PROT_READ | PROT_EXEC;
+			   }
+				if (mlibc::sys_vm_protect (reinterpret_cast<void *>(map_address),
+				      total_map_size, prot))
+				   __ensure(!"vm_protect not feeling all there");
 			#endif
 			// Take care of removing superfluous permissions.
-			if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
-				if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
-					mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
+			//if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
+			//	if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
+			//		mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
 		}else if(phdr->p_type == PT_TLS) {
 			object->tlsSegmentSize = phdr->p_memsz;
 			object->tlsAlignment = phdr->p_align;
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index 7136150..f037868 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -19,707 +19,771 @@
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-	ssize_t unused;
-	char new_line = '\n';
-	sys_write(2, message, strlen(message), &unused);
-	sys_write(2, &new_line, 1, &unused);
+   ssize_t unused;
+   char new_line = '\n';
+   sys_write(2, message, strlen(message), &unused);
+   sys_write(2, &new_line, 1, &unused);
 }
 
 void sys_libc_panic() {
-	ssize_t unused;
-	char const *message = "mlibc panicked unrecoverably\n";
-	sys_write(2, message, strlen(message), &unused);
-	sys_exit(1);
+   ssize_t unused;
+   char const *message = "mlibc panicked unrecoverably\n";
+   sys_write(2, message, strlen(message), &unused);
+   sys_exit(1);
 }
 
 void sys_exit(int status) {
-	int ret, errno;
-	SYSCALL1(SYSCALL_EXIT, status);
-	__builtin_unreachable();
+   int ret, errno;
+   SYSCALL1(SYSCALL_EXIT, status);
+   __builtin_unreachable();
 }
 
 int sys_tcb_set(void *pointer) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
+   return errno;
 }
 
 int sys_open(const char *path, int flags, mode_t mode, int *fd) {
-	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+   return sys_openat(AT_FDCWD, path, flags, mode, fd);
 }
 
 int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
-	int ret, errno;
-
-	int path_len = strlen (path);
-	SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
-	if (ret != -1 && (flags & O_EXCL)) {
-		 SYSCALL1(SYSCALL_CLOSE, ret);
-		 return EEXIST;
-	}
-
-	if (ret == -1 && (flags & O_CREAT)) {
-		 SYSCALL5(SYSCALL_MAKENODE, AT_FDCWD, path, path_len, mode, 0);
-		 if (ret == -1) {
-			  return errno;
-		 }
-		 SYSCALL4(SYSCALL_OPEN,	AT_FDCWD, path, path_len, flags);
-	} else if (ret != -1 && (flags & O_TRUNC)) {
-		// If the file cannot be truncated, dont sweat it, some software
-		// depends on some things being truncate-able that ironclad does not
-		// allow. For example, some devices.
-		sys_ftruncate(ret, 0);
-	} else if (ret != -1 && (flags & O_DIRECTORY)) {
-		struct stat st;
-		sys_stat(fsfd_target::fd, ret, NULL, 0, &st);
-		if (!S_ISDIR (st.st_mode)) {
-			ret	= -1;
-			errno = ENOTDIR;
-		}
-	}
-
-	*fd = ret;
-	return errno;
+   int ret, errno;
+
+   int path_len = strlen (path);
+   SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
+   if (ret != -1 && (flags & O_EXCL)) {
+       SYSCALL1(SYSCALL_CLOSE, ret);
+       return EEXIST;
+   }
+
+   if (ret == -1 && (flags & O_CREAT)) {
+       SYSCALL5(SYSCALL_MAKENODE, AT_FDCWD, path, path_len, mode, 0);
+       if (ret == -1) {
+           return errno;
+       }
+       SYSCALL4(SYSCALL_OPEN, AT_FDCWD, path, path_len, flags);
+   } else if (ret != -1 && (flags & O_TRUNC)) {
+      // If the file cannot be truncated, dont sweat it, some software
+      // depends on some things being truncate-able that ironclad does not
+      // allow. For example, some devices.
+      sys_ftruncate(ret, 0);
+   } else if (ret != -1 && (flags & O_DIRECTORY)) {
+      struct stat st;
+      sys_stat(fsfd_target::fd, ret, NULL, 0, &st);
+      if (!S_ISDIR (st.st_mode)) {
+         ret   = -1;
+         errno = ENOTDIR;
+      }
+   }
+
+   *fd = ret;
+   return errno;
 }
 
 int sys_open_dir(const char *path, int *handle) {
-	return sys_open(path, O_RDONLY | O_DIRECTORY, 0660, handle);
+   return sys_open(path, O_RDONLY | O_DIRECTORY, 0660, handle);
 }
 
 int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
-	size_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_GETDENTS, handle, buffer, max_size);
-	if (errno != 0) {
-		return errno;
-	} else {
-		*bytes_read = ret;
-		return 0;
-	}
+   size_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_GETDENTS, handle, buffer, max_size);
+   if (errno != 0) {
+      return errno;
+   } else {
+      *bytes_read = ret;
+      return 0;
+   }
 }
 
 void sys_thread_exit() {
-	 int ret, errno;
-	 SYSCALL0(SYSCALL_EXIT_THREAD);
-	 __builtin_unreachable();
+    int ret, errno;
+    SYSCALL0(SYSCALL_EXIT_THREAD);
+    __builtin_unreachable();
 }
 
 int sys_close(int fd) {
-	int ret, errno;
-	SYSCALL1(SYSCALL_CLOSE, fd);
-	return errno;
+   int ret, errno;
+   SYSCALL1(SYSCALL_CLOSE, fd);
+   return errno;
 }
 
 void sys_sync() {
-	int ret, errno;
-	SYSCALL0(SYSCALL_SYNC);
-	if (ret != 0) {
-		sys_libc_log("mlibc: sync failed");
-	}
+   int ret, errno;
+   SYSCALL0(SYSCALL_SYNC);
+   if (ret != 0) {
+      sys_libc_log("mlibc: sync failed");
+   }
 }
 
 int sys_fsync(int fd) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_FSYNC, fd, 0);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_FSYNC, fd, 0);
+   return errno;
 }
 
 int sys_fdatasync(int fd) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_FSYNC, fd, 1);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_FSYNC, fd, 1);
+   return errno;
 }
 
 int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
-	ssize_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_READ, fd, buf, count);
-	*bytes_read = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_READ, fd, buf, count);
+   *bytes_read = ret;
+   return errno;
 }
 
 int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
-	ssize_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_WRITE, fd, buf, count);
-	*bytes_written = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_WRITE, fd, buf, count);
+   *bytes_written = ret;
+   return errno;
 }
 
 int sys_pread(int fd, void *buf, size_t n, off_t off, ssize_t *bytes_read) {
-	ssize_t ret;
-	int errno;
-	SYSCALL4(SYSCALL_PREAD, fd, buf, n, off);
-	*bytes_read = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL4(SYSCALL_PREAD, fd, buf, n, off);
+   *bytes_read = ret;
+   return errno;
 }
 
 int sys_pwrite(int fd, const void *buf, size_t n, off_t off, ssize_t *bytes_written) {
-	ssize_t ret;
-	int errno;
-	SYSCALL4(SYSCALL_WRITE, fd, buf, n, off);
-	*bytes_written = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL4(SYSCALL_WRITE, fd, buf, n, off);
+   *bytes_written = ret;
+   return errno;
 }
 
 int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
-	ssize_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_SEEK, fd, offset, whence);
-	*new_offset = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_SEEK, fd, offset, whence);
+   *new_offset = ret;
+   return errno;
 }
 
 int sys_ftruncate (int fd, size_t size) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_TRUNCATE, fd, size);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_TRUNCATE, fd, size);
+   return errno;
 }
 
 int sys_flock(int fd, int options) {
-	struct flock lock;
-	lock.l_whence = SEEK_SET;
-	lock.l_start = 0;
-	lock.l_len = (off_t)((uint64_t)-1);
-	lock.l_pid = sys_getpid();
-
-	switch (options) {
-		case LOCK_SH:
-			lock.l_type = F_RDLCK;
-			break;
-		case LOCK_EX:
-			lock.l_type = F_WRLCK;
-			break;
-		case LOCK_UN:
-			lock.l_type = F_UNLCK;
-			break;
-		default:
-			return -1;
-	}
-
-	int ret, errno;
-	SYSCALL3(SYSCALL_FCNTL, fd, F_SETLK, &lock);
-	return errno;
+   //  XXX: Shouldnt this use F_SETLKW and F_SETLK only when LOCK_NB ?
+   struct flock lock;
+   lock.l_whence = SEEK_SET;
+   lock.l_start = 0;
+   lock.l_len = (off_t)((uint64_t)-1);
+   lock.l_pid = sys_getpid();
+
+   switch (options & ~(LOCK_NB)) {
+      case LOCK_SH:
+         lock.l_type = F_RDLCK;
+         break;
+      case LOCK_EX:
+         lock.l_type = F_WRLCK;
+         break;
+      case LOCK_UN:
+         lock.l_type = F_UNLCK;
+         break;
+      default:
+         return -1;
+   }
+
+   int ret, errno;
+   SYSCALL3(SYSCALL_FCNTL, fd, F_SETLK, &lock);
+   return errno;
+}
+
+int sys_getpriority(int which, id_t who, int *value) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_GETPRIO, which, who);
+   *value = ret;
+   return errno;
+}
+
+int sys_setpriority(int which, id_t who, int value) {
+   int ret, errno;
+   SYSCALL3(SYSCALL_SETPRIO, which, who, value);
+   return errno;
 }
 
 int sys_getrusage(int scope, struct rusage *usage) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_GETRUSAGE, scope, usage);
+   int ret, errno;
+   SYSCALL2(SYSCALL_GETRUSAGE, scope, usage);
 
-	// Ironclad returns nanoseconds instead of microseconds for usage, so we
-	// have to compensate for that.
-	usage->ru_utime.tv_usec = usage->ru_utime.tv_usec / 1000;
-	usage->ru_stime.tv_usec = usage->ru_stime.tv_usec / 1000;
+   // Ironclad returns nanoseconds instead of microseconds for usage, so we
+   // have to compensate for that.
+   usage->ru_utime.tv_usec = usage->ru_utime.tv_usec / 1000;
+   usage->ru_stime.tv_usec = usage->ru_stime.tv_usec / 1000;
 
-	return errno;
+   return errno;
 }
 
 int sys_anon_allocate(size_t size, void **pointer) {
-	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON, 0, 0, pointer);
+   return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON, 0, 0, pointer);
 }
 
 int sys_anon_free(void *pointer, size_t size) {
-	return sys_vm_unmap(pointer, size);
+   return sys_vm_unmap(pointer, size);
 }
 
 int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
-	void *ret;
-	int errno;
-	SYSCALL6(SYSCALL_MMAP, hint, size, prot, flags, fd, offset);
-	*window = ret;
-	return errno;
+   void *ret;
+   int errno;
+   SYSCALL6(SYSCALL_MMAP, hint, size, prot, flags, fd, offset);
+   *window = ret;
+   return errno;
 }
 
 int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) {
-	(void)fd;
-	(void)size;
-	if (layer == SOL_SOCKET && number == SO_PEERCRED) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
-		*(int *)buffer = 4096;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_TYPE) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
-		*(int *)buffer = SOCK_STREAM;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_ERROR) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else {
-		mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
-	}
-
-	return 0;
+   (void)fd;
+   (void)size;
+   if (layer == SOL_SOCKET && number == SO_PEERCRED) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
+      *(int *)buffer = 0;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+      *(int *)buffer = 4096;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_TYPE) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
+      *(int *)buffer = SOCK_STREAM;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_ERROR) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
+      *(int *)buffer = 0;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
+      *(int *)buffer = 0;
+      return 0;
+   } else {
+      mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+   }
+
+   return 0;
 }
 
 int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) {
-	(void)fd;
-	(void)buffer;
-	(void)size;
-	if (layer == SOL_SOCKET && number == SO_PASSCRED) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_REUSEADDR) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == AF_NETLINK && number == SO_ACCEPTCONN) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
-		return 0;
-	} else {
-		mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
-	}
-
-	 return 0;
+   (void)fd;
+   (void)buffer;
+   (void)size;
+   if (layer == SOL_SOCKET && number == SO_PASSCRED) {
+      mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
+      mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
+      mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_REUSEADDR) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
+      return 0;
+   } else if (layer == AF_NETLINK && number == SO_ACCEPTCONN) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
+      return 0;
+   } else {
+      mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+   }
+
+    return 0;
 }
 
 int sys_vm_unmap(void *pointer, size_t size) {
-	int ret;
-	int errno;
-	SYSCALL2(SYSCALL_MUNMAP, pointer, size);
-	if (ret != 0) {
-		return errno;
-	} else {
-		return 0;
-	}
+   int ret;
+   int errno;
+   SYSCALL2(SYSCALL_MUNMAP, pointer, size);
+   if (ret != 0) {
+      return errno;
+   } else {
+      return 0;
+   }
 }
 
 int sys_vm_protect(void *pointer, size_t size, int prot) {
-	int ret;
-	int errno;
-	SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
-	if (ret != 0) {
-		return errno;
-	}
-	return 0;
+   int ret;
+   int errno;
+   SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
+   if (ret != 0) {
+      return errno;
+   }
+   return 0;
+}
+
+int sys_getsid(pid_t pid, pid_t *sid) {
+   //  STUB.
+   return 0;
 }
 
 pid_t sys_getpid() {
-	pid_t ret;
-	int errno;
-	SYSCALL0(SYSCALL_GETPID);
-	return ret;
+   pid_t ret;
+   int errno;
+   SYSCALL0(SYSCALL_GETPID);
+   return ret;
 }
 
 pid_t sys_getppid() {
-	pid_t ret;
-	int errno;
-	SYSCALL0(SYSCALL_GETPPID);
-	return ret;
+   pid_t ret;
+   int errno;
+   SYSCALL0(SYSCALL_GETPPID);
+   return ret;
+}
+
+int sys_getgroups(size_t size, const gid_t *list, int *retval) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_GETGROUPS, size, list);
+   *retval = ret;
+   return errno;
+}
+
+int sys_setgroups(size_t size, const gid_t *list) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGROUPS, size, list);
+   return errno;
 }
 
 int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
-	return 0;
+   return 0;
 }
 
 int sys_ptrace(long req, pid_t pid, void *addr, void *data, long *out) {
-	int ret, errno;
-	SYSCALL4(SYSCALL_PTRACE, req, pid, addr, data);
-	*out = (long)ret;
-	return errno;
+   int ret, errno;
+   SYSCALL4(SYSCALL_PTRACE, req, pid, addr, data);
+   *out = (long)ret;
+   return errno;
 }
 
 int sys_fcntl(int fd, int request, va_list args, int *result) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
-	*result = ret;
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
+   *result = ret;
+   return errno;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
-	return 0;
+   return 0;
 }
 
 int sys_isatty(int fd) {
-	struct termios t;
-	if (sys_tcgetattr(fd, &t) == 0) {
-		return 0;
-	} else {
-		return ENOTTY;
-	}
-}
-
-gid_t sys_getgid() {
-	// FIXME: Stub needed by mlibc.
-	return 0;
-}
-
-gid_t sys_getegid() {
-	// FIXME: Stub needed by mlibc.
-	return 0;
+   struct termios t;
+   if (sys_tcgetattr(fd, &t) == 0) {
+      return 0;
+   } else {
+      return ENOTTY;
+   }
 }
 
 int sys_getpgid(pid_t pid, pid_t *pgid) {
-	(void)pid;
-	// FIXME: Stub needed by mlibc.
-	*pgid = 0;
-	return 0;
+   (void)pid;
+   // FIXME: Stub needed by mlibc.
+   *pgid = 0;
+   return 0;
 }
 
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
-	int ret, errno, argv_len, envp_len;
-	for (argv_len = 0; argv[argv_len] != NULL; argv_len++);
-	for (envp_len = 0; envp[envp_len] != NULL; envp_len++);
+   int ret, errno, argv_len, envp_len;
+   for (argv_len = 0; argv[argv_len] != NULL; argv_len++);
+   for (envp_len = 0; envp[envp_len] != NULL; envp_len++);
 
-	size_t path_len = strlen (path);
-	SYSCALL6(SYSCALL_EXEC, path, path_len, argv, argv_len, envp, envp_len);
+   size_t path_len = strlen (path);
+   SYSCALL6(SYSCALL_EXEC, path, path_len, argv, argv_len, envp, envp_len);
 
-	if (ret == -1) {
-		return errno;
-	 }
+   if (ret == -1) {
+      return errno;
+    }
 
-	return 0;
+   return 0;
 }
 
 int sys_fork(pid_t *child) {
-	pid_t ret;
-	int errno;
+   pid_t ret;
+   int errno;
 
-	SYSCALL6(SYSCALL_CLONE, 0, 0, 0, 0, 0, 1);
+   SYSCALL6(SYSCALL_CLONE, 0, 0, 0, 0, 0, 1);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	if (child != NULL) {
-		*child = ret;
-	}
+   if (child != NULL) {
+      *child = ret;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_getrlimit(int resource, struct rlimit *limit) {
-	uint64_t ret, errno;
-	SYSCALL1(SYSCALL_GETRLIMIT, resource);
-	limit->rlim_cur = ret;
-	limit->rlim_max = ret;
-	return errno;
+   uint64_t ret, errno;
+   SYSCALL1(SYSCALL_GETRLIMIT, resource);
+   limit->rlim_cur = ret;
+   limit->rlim_max = ret;
+   return errno;
 }
 
 int sys_setrlimit(int resource, const struct rlimit *limit) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_SETRLIMIT, resource, limit->rlim_cur);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETRLIMIT, resource, limit->rlim_cur);
+   return errno;
 }
 
 int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
-	pid_t ret;
-	int errno;
+   pid_t ret;
+   int errno;
 
-	if(ru) {
-		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
-		return ENOSYS;
-	}
+   if(ru) {
+      mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
+      return ENOSYS;
+   }
 
-	SYSCALL3(SYSCALL_WAIT, pid, status, flags);
+   SYSCALL3(SYSCALL_WAIT, pid, status, flags);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	*ret_pid = ret;
-	return errno;
+   *ret_pid = ret;
+   return errno;
 }
 
 int sys_uname(struct utsname *buf) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL3(SYSCALL_SYSCONF, 10, buf, sizeof(struct utsname));
+   SYSCALL3(SYSCALL_SYSCONF, 10, buf, sizeof(struct utsname));
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 
 
 int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid;
-	(void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
-	return 0;
+   (void)pid;
+   (void)pgid;
+   return 0;
 }
 
-int sys_ttyname(int, char *, size_t) {
-	return ENOSYS;
+int sys_ttyname(int fd, char *buff, size_t size) {
+   int ret, errno;
+   SYSCALL3(SYSCALL_TTYNAME, fd, buff, size);
+   return errno;
 }
 
 int sys_sethostname(const char *buff, size_t size) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL2(SYSCALL_SETHOSTNAME, buff, size);
+   SYSCALL2(SYSCALL_SETHOSTNAME, buff, size);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_chdir(const char *buff) {
-	int ret, errno;
+   int ret, errno;
 
-	size_t buff_len = strlen(buff);
-	SYSCALL4(SYSCALL_OPEN, AT_FDCWD, buff, buff_len, O_RDONLY);
-	if (ret == -1) {
-		return ENOENT;
-	}
+   size_t buff_len = strlen(buff);
+   SYSCALL4(SYSCALL_OPEN, AT_FDCWD, buff, buff_len, O_RDONLY);
+   if (ret == -1) {
+      return ENOENT;
+   }
 
-	SYSCALL1(SYSCALL_CHDIR, ret);
+   SYSCALL1(SYSCALL_CHDIR, ret);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_fchdir(int fd) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL1(SYSCALL_CHDIR, fd);
+   SYSCALL1(SYSCALL_CHDIR, fd);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
-	int ret, errno;
+   int ret, errno;
+
+   if (request == TIOCGPGRP) {
+      *result = 0;
+      return 0;
+   } else if (request == TIOCSPGRP) {
+      return 0;
+   }
 
-	SYSCALL3(SYSCALL_IOCTL, fd, request, arg);
+   SYSCALL3(SYSCALL_IOCTL, fd, request, arg);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	*result = ret;
-	return 0;
+   *result = ret;
+   return 0;
 }
 
 void sys_yield(void) {
-	int ret, errno;
-	SYSCALL0(SYSCALL_SCHED_YIELD);
+   int ret, errno;
+   SYSCALL0(SYSCALL_SCHED_YIELD);
 }
 
 int sys_kill(int pid, int sig) {
-	int ret, errno;
-	if (sig == SIGKILL) {
-		SYSCALL1(SYSCALL_ACTUALLY_KILL, pid);
-	} else {
-		SYSCALL2(SYSCALL_SEND_SIGNAL, pid, sig);
-	}
+   int ret, errno;
+   if (sig == SIGKILL) {
+      SYSCALL1(SYSCALL_ACTUALLY_KILL, pid);
+   } else {
+      SYSCALL2(SYSCALL_SEND_SIGNAL, pid, sig);
+   }
 
-	return errno;
+   return errno;
 }
 
 int sys_dup(int fd, int flags, int *newfd) {
-	int ret, errno;
-	if (flags & O_CLOEXEC) {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, 0);
-	} else {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
-	}
-	*newfd = ret;
-	return errno;
+   int ret, errno;
+   if (flags & O_CLOEXEC) {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, 0);
+   } else {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
+   }
+   *newfd = ret;
+   return errno;
 }
 
 int sys_dup2(int fd, int flags, int newfd) {
-	if (sys_close(newfd) != 0) {
-		 return EBADFD;
-	}
+   if (sys_close(newfd) != 0) {
+       return EBADFD;
+   }
 
-	int ret, errno;
-	if (flags & O_CLOEXEC) {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
-	} else {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
-	}
+   int ret, errno;
+   if (flags & O_CLOEXEC) {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
+   } else {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
+   }
 
-	if (ret != -1 && ret != newfd) {
-		return EBADFD;
-	} else {
-		return errno;
-	}
+   if (ret != -1 && ret != newfd) {
+      return EBADFD;
+   } else {
+      return errno;
+   }
 }
 
 int sys_tcgetattr(int fd, struct termios *attr) {
-	 int ret;
+    int ret;
 
-	 if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
-		  return r;
-	 }
+    if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
+        return r;
+    }
 
-	 return 0;
+    return 0;
 }
 
 int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
-	 int ret;
+    int ret;
 
-	 switch (optional_action) {
-		  case TCSANOW:
-				optional_action = TCSETS; break;
-		  case TCSADRAIN:
-				optional_action = TCSETSW; break;
-		  case TCSAFLUSH:
-				optional_action = TCSETSF; break;
-		  default:
-				__ensure(!"Unsupported tcsetattr");
-	 }
+    switch (optional_action) {
+        case TCSANOW:
+            optional_action = TCSETS; break;
+        case TCSADRAIN:
+            optional_action = TCSETSW; break;
+        case TCSAFLUSH:
+            optional_action = TCSETSF; break;
+        default:
+            __ensure(!"Unsupported tcsetattr");
+    }
 
-	 if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
-		  return r;
-	 }
+    if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
+        return r;
+    }
 
-	 return 0;
+    return 0;
 }
 
 int sys_access(const char *path, int mode) {
-	int ret, errno;
-	size_t len = strlen(path);
-	SYSCALL5(SYSCALL_ACCESS, AT_FDCWD, path, len, mode, 0);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(path);
+   SYSCALL5(SYSCALL_ACCESS, AT_FDCWD, path, len, mode, 0);
+   return errno;
 }
 
 int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL5(SYSCALL_ACCESS, dirfd, pathname, len, mode, flags);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL5(SYSCALL_ACCESS, dirfd, pathname, len, mode, flags);
+   return errno;
 }
 
 struct futex_item {
-	 uint64_t addr;
-	 uint32_t expected;
-	 uint32_t flags;
+    uint64_t addr;
+    uint32_t expected;
+    uint32_t flags;
 };
 
 int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-	int ret, errno;
-	struct futex_item item = {.addr = (uint64_t)pointer, .expected = expected, .flags = 0};
-	if (time == NULL) {
-		 struct timespec t = {(time_t)-1, (time_t)-1};
-		 SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, &t);
-	} else {
-		 SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, time);
-	}
-	return errno;
+   int ret, errno;
+   struct futex_item item = {.addr = (uint64_t)pointer, .expected = expected, .flags = 0};
+   if (time == NULL) {
+       struct timespec t = {(time_t)-1, (time_t)-1};
+       SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, &t);
+   } else {
+       SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, time);
+   }
+   return errno;
 }
 
 int sys_futex_wake(int *pointer) {
-	int ret, errno;
-	struct futex_item item = {.addr = (uint64_t)pointer, .expected = 0, .flags = 0};
-	struct timespec t = {(time_t)-1, (time_t)-1};
-	SYSCALL4(SYSCALL_FUTEX, 0b10, &item, 1, &t);
-	return errno;
+   int ret, errno;
+   struct futex_item item = {.addr = (uint64_t)pointer, .expected = 0, .flags = 0};
+   struct timespec t = {(time_t)-1, (time_t)-1};
+   SYSCALL4(SYSCALL_FUTEX, 0b10, &item, 1, &t);
+   return errno;
 }
 
 int sys_pipe(int *fds, int flags) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_PIPE, fds, flags);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_PIPE, fds, flags);
+   return errno;
 }
 
 int sys_getentropy(void *buffer, size_t length) {
-	ssize_t ret;
-	int errno;
-	SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
+   return errno;
 }
 
 int sys_mkdir(const char *path, mode_t mode) {
-	return sys_mkdirat(AT_FDCWD, path, mode);
+   return sys_mkdirat(AT_FDCWD, path, mode);
 }
 
 int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
-	int ret, errno;
-	size_t path_len = strlen (path);
-	SYSCALL5(SYSCALL_MAKENODE, dirfd, path, path_len, S_IFDIR | mode, 0);
-	return errno;
+   int ret, errno;
+   size_t path_len = strlen (path);
+   SYSCALL5(SYSCALL_MAKENODE, dirfd, path, path_len, S_IFDIR | mode, 0);
+   return errno;
 }
 
 int sys_rmdir(const char* path){
-	int ret, errno;
-	size_t path_len = strlen (path);
-	SYSCALL3(SYSCALL_UNLINK, AT_FDCWD, path, path_len);
-	return errno;
+   int ret, errno;
+   size_t path_len = strlen (path);
+   SYSCALL3(SYSCALL_UNLINK, AT_FDCWD, path, path_len);
+   return errno;
 }
 
 int sys_unlinkat(int fd, const char *path, int flags) {
-	int ret, errno;
-	size_t path_len = strlen (path);
-	SYSCALL3(SYSCALL_UNLINK, fd, path, path_len);
-	return errno;
+   int ret, errno;
+   size_t path_len = strlen (path);
+   SYSCALL3(SYSCALL_UNLINK, fd, path, path_len);
+   return errno;
 }
 
 int sys_link(const char* srcpath, const char* destpath) {
-	int ret, errno;
-	size_t src_len = strlen (srcpath);
-	size_t dst_len = strlen (destpath);
-	SYSCALL6(SYSCALL_LINK, AT_FDCWD, srcpath, src_len, AT_FDCWD, destpath, dst_len);
-	return errno;
+   int ret, errno;
+   size_t src_len = strlen (srcpath);
+   size_t dst_len = strlen (destpath);
+   SYSCALL6(SYSCALL_LINK, AT_FDCWD, srcpath, src_len, AT_FDCWD, destpath, dst_len);
+   return errno;
 }
 
 int sys_socket(int domain, int type, int protocol, int *fd) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_SOCKET, domain, type, protocol);
-	if (ret != -1) {
-		*fd = ret;
-		return 0;
-	} else {
-		return errno;
-	}
+   int ret, errno;
+   SYSCALL3(SYSCALL_SOCKET, domain, type, protocol);
+   if (ret != -1) {
+      *fd = ret;
+      return 0;
+   } else {
+      return errno;
+   }
 }
 
 uid_t sys_getuid() {
-	uint64_t ret, errno;
-	SYSCALL0(SYSCALL_GETUID);
-	return (uid_t)ret;
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETUID);
+   return (uid_t)ret;
 }
 
 uid_t sys_geteuid() {
-	uint64_t ret, errno;
-	SYSCALL0(SYSCALL_GETEUID);
-	return (uid_t)ret;
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETEUID);
+   return (uid_t)ret;
 }
 
 int sys_setuid(uid_t uid) {
-	int ret, errno;
-	if (uid == 0) {
-		 SYSCALL2(SYSCALL_SETUIDS, uid, uid);
-	} else {
-		 SYSCALL2(SYSCALL_SETUIDS, uid, ((uint64_t)-1));
-	}
-	return ret;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETUIDS, uid, uid);
+   return ret;
 }
 
 int sys_seteuid(uid_t euid) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_SETUIDS, ((uint64_t)-1), euid);
-	return ret;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETUIDS, ((uint64_t)-1), euid);
+   return ret;
+}
+
+int sys_setreuid(uid_t ruid, uid_t euid) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETUIDS, ruid, euid);
+   return ret;
+}
+
+gid_t sys_getgid() {
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETGID);
+   return (gid_t)ret;
+}
+
+gid_t sys_getegid() {
+   return sys_getgid();
+}
+
+int sys_setgid(gid_t gid) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGIDS, gid, gid);
+   return ret;
+}
+
+int sys_setegid(gid_t egid) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGIDS, ((uint64_t)-1), egid);
+   return ret;
+}
+
+int sys_setregid(gid_t rgid, gid_t egid) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGIDS, rgid, egid);
+   return ret;
+}
+
+int sys_setsid(pid_t *sid) {
+    return 0;
 }
 
 #ifndef MLIBC_BUILDING_RTDL
@@ -727,443 +791,479 @@ int sys_seteuid(uid_t euid) {
 extern "C" void __mlibc_thread_entry();
 
 int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
-	 int ret, errno;
-	 SYSCALL6(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb, 1);
+    int ret, errno;
+    SYSCALL6(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb, 1);
 
-	 if (ret == -1) {
-		  return errno;
-	 }
+    if (ret == -1) {
+        return errno;
+    }
 
-	 *tid_out = (pid_t)ret;
-	 return 0;
+    *tid_out = (pid_t)ret;
+    return 0;
 }
 
 int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size) {
-	// TODO guard
+   // TODO guard
 
-	mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+   mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
 
-	*guard_size = 0;
-	*stack_size = *stack_size ? *stack_size : 0x400000;
+   *guard_size = 0;
+   *stack_size = *stack_size ? *stack_size : 0x400000;
 
-	if (!*stack) {
-		*stack = (void *)((char *)mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size);
-		if (*stack == MAP_FAILED) {
-			return errno;
-		}
-	}
+   if (!*stack) {
+      *stack = (void *)((char *)mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size);
+      if (*stack == MAP_FAILED) {
+         return errno;
+      }
+   }
 
-	void **stack_it = (void **)*stack;
+   void **stack_it = (void **)*stack;
 
-	*--stack_it = arg;
-	*--stack_it = tcb;
-	*--stack_it = entry;
+   *--stack_it = arg;
+   *--stack_it = tcb;
+   *--stack_it = entry;
 
-	*stack = (void *)stack_it;
+   *stack = (void *)stack_it;
 
-	return 0;
+   return 0;
 }
 
 int sys_clock_getres(int clock, time_t *secs, long *nanos) {
-	struct timespec time;
-	int ret, errno;
-	SYSCALL3(SYSCALL_CLOCK, 0, clock, &time);
-	*secs  = time.tv_sec;
-	*nanos = time.tv_nsec;
-	return errno;
+   struct timespec time;
+   int ret, errno;
+   SYSCALL3(SYSCALL_CLOCK, 0, clock, &time);
+   *secs  = time.tv_sec;
+   *nanos = time.tv_nsec;
+   return errno;
 }
 
 int sys_clock_get(int clock, time_t *secs, long *nanos) {
-	struct timespec time;
-	int ret, errno;
-	SYSCALL3(SYSCALL_CLOCK, 1, clock, &time);
-	*secs  = time.tv_sec;
-	*nanos = time.tv_nsec;
-	return errno;
+   struct timespec time;
+   int ret, errno;
+   SYSCALL3(SYSCALL_CLOCK, 1, clock, &time);
+   *secs  = time.tv_sec;
+   *nanos = time.tv_nsec;
+   return errno;
 }
 
 int sys_clock_set(int clock, time_t secs, long nanos) {
-	struct timespec time = {.tv_sec = secs, .tv_nsec = nanos };
-	int ret, errno;
-	SYSCALL3(SYSCALL_CLOCK, 2, clock, &time);
-	return errno;
+   struct timespec time = {.tv_sec = secs, .tv_nsec = nanos };
+   int ret, errno;
+   SYSCALL3(SYSCALL_CLOCK, 2, clock, &time);
+   return errno;
 }
 
 int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addrlen) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_BIND, fd, addr_ptr, addrlen);
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_BIND, fd, addr_ptr, addrlen);
+   return errno;
 }
 
 int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addrlen) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_CONNECT, fd, addr_ptr, addrlen);
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_CONNECT, fd, addr_ptr, addrlen);
+   return errno;
 }
 
 int sys_listen(int fd, int backlog) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_LISTEN, fd, backlog);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_LISTEN, fd, backlog);
+   return errno;
 }
 
 int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length, int flags) {
-	int ret, errno;
-	SYSCALL4(SYSCALL_ACCEPT, fd, addr_ptr, addr_length, flags);
-	*newfd = ret;
-	return errno;
+   int ret, errno;
+   SYSCALL4(SYSCALL_ACCEPT, fd, addr_ptr, addr_length, flags);
+   *newfd = ret;
+   return errno;
 }
 
 
 int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_GETSOCKNAME, fd, addr_ptr, &max_addr_length);
-	*actual_length = max_addr_length;
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_GETSOCKNAME, fd, addr_ptr, &max_addr_length);
+   *actual_length = max_addr_length;
+   return errno;
 }
 
 int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_GETPEERNAME, fd, addr_ptr, &max_addr_length);
-	*actual_length = max_addr_length;
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_GETPEERNAME, fd, addr_ptr, &max_addr_length);
+   *actual_length = max_addr_length;
+   return errno;
 }
 
 int sys_shutdown(int sockfd, int how) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_SHUTDOWN, sockfd, how);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SHUTDOWN, sockfd, how);
+   return errno;
 }
 
 int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
-	if (hdr->msg_control != NULL) {
-		mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
-		return EINVAL;
-	}
+   if (hdr->msg_control != NULL) {
+      mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
+      return EINVAL;
+   }
 
-	int ret;
-	size_t count = 0;
-	int errno;
+   int ret;
+   size_t count = 0;
+   int errno;
 
-	for (int i = 0; i < hdr->msg_iovlen; i++) {
-		SYSCALL6(SYSCALL_RECVFROM, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
-					hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
-		if (ret == -1) {
-			return errno;
-		}
-		count += ret;
-	}
+   for (int i = 0; i < hdr->msg_iovlen; i++) {
+      SYSCALL6(SYSCALL_RECVFROM, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
+               hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
+      if (ret == -1) {
+         return errno;
+      }
+      count += ret;
+   }
 
-	*length = count;
-	return 0;
+   *length = count;
+   return 0;
 }
 
 int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
-	if (hdr->msg_control != NULL) {
-		mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
-		return EINVAL;
-	}
+   if (hdr->msg_control != NULL) {
+      mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
+      return EINVAL;
+   }
 
-	int ret;
-	size_t count = 0;
-	int errno;
+   int ret;
+   size_t count = 0;
+   int errno;
 
-	for (int i = 0; i < hdr->msg_iovlen; i++) {
-		SYSCALL6(SYSCALL_SENDTO, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
-					hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
-		if (ret == -1) {
-			return errno;
-		}
-		count += ret;
-	}
+   for (int i = 0; i < hdr->msg_iovlen; i++) {
+      SYSCALL6(SYSCALL_SENDTO, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
+               hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
+      if (ret == -1) {
+         return errno;
+      }
+      count += ret;
+   }
 
-	*length = count;
-	return 0;
+   *length = count;
+   return 0;
 }
 
 
 int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
-	// XXX: Ironclad has no sigprogmask so this is basically a weird ppoll poll
-	// chimeral abomination.
-	int ret, errno;
-	if (timeout == NULL) {
-		 struct timespec t = {.tv_sec = (time_t)-1, .tv_nsec = (time_t)-1};
-		 SYSCALL3(SYSCALL_POLL, fds, nfds, &t);
-	} else {
-		 SYSCALL3(SYSCALL_POLL, fds, nfds, timeout);
-	}
-	if (ret == -1) {
-		return errno;
-	}
-
-	*num_events = ret;
-	return errno;
+   // XXX: Ironclad has no sigprogmask so this is basically a weird ppoll poll
+   // chimeral abomination.
+   int ret, errno;
+   if (timeout == NULL) {
+       struct timespec t = {.tv_sec = (time_t)-1, .tv_nsec = (time_t)-1};
+       SYSCALL3(SYSCALL_POLL, fds, nfds, &t);
+   } else {
+       SYSCALL3(SYSCALL_POLL, fds, nfds, timeout);
+   }
+   if (ret == -1) {
+      return errno;
+   }
+
+   *num_events = ret;
+   return errno;
 }
 
 int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
-	struct timespec ts;
-	ts.tv_sec = timeout / 1000;
-	ts.tv_nsec = (timeout % 1000) * 1000000;
-	return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
+   struct timespec ts;
+   ts.tv_sec = timeout / 1000;
+   ts.tv_nsec = (timeout % 1000) * 1000000;
+   return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
 }
 
 int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
-		fd_set *except_set, const struct timespec *timeout,
-		const sigset_t *sigmask, int *num_events) {
-	struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
-	if (fds == NULL) {
-		return ENOMEM;
-	}
-
-	for (int i = 0; i < nfds; i++) {
-		struct pollfd *fd = &fds[i];
-
-		if (read_set && FD_ISSET(i, read_set)) {
-			fd->events |= POLLIN;
-		}
-		if (write_set && FD_ISSET(i, write_set)) {
-			fd->events |= POLLOUT;
-		}
-		if (except_set && FD_ISSET(i, except_set)) {
-			fd->events |= POLLPRI;
-		}
-
-		if (!fd->events) {
-			fd->fd = -1;
-			continue;
-		}
-		fd->fd = i;
-	}
-
-	int ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
-	if (ret != 0) {
-		free(fds);
-		return ret;
-	}
-
-	fd_set res_read_set, res_write_set, res_except_set;
-	FD_ZERO(&res_read_set);
-	FD_ZERO(&res_write_set);
-	FD_ZERO(&res_except_set);
-
-	for (int i = 0; i < nfds; i++) {
-		struct pollfd *fd = &fds[i];
-
-		if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0) {
-			FD_SET(i, &res_read_set);
-		}
-		if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0) {
-			FD_SET(i, &res_write_set);
-		}
-		if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) {
-			FD_SET(i, &res_except_set);
-		}
-	}
-
-	free(fds);
-	if (read_set) {
-		*read_set = res_read_set;
-	}
-	if (write_set) {
-		*write_set = res_write_set;
-	}
-	if (except_set) {
-		*except_set = res_except_set;
-	}
-
-	return 0;
+      fd_set *except_set, const struct timespec *timeout,
+      const sigset_t *sigmask, int *num_events) {
+   struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
+   if (fds == NULL) {
+      return ENOMEM;
+   }
+
+   for (int i = 0; i < nfds; i++) {
+      struct pollfd *fd = &fds[i];
+
+      if (read_set && FD_ISSET(i, read_set)) {
+         fd->events |= POLLIN;
+      }
+      if (write_set && FD_ISSET(i, write_set)) {
+         fd->events |= POLLOUT;
+      }
+      if (except_set && FD_ISSET(i, except_set)) {
+         fd->events |= POLLPRI;
+      }
+
+      if (!fd->events) {
+         fd->fd = -1;
+         continue;
+      }
+      fd->fd = i;
+   }
+
+   int ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
+   if (ret != 0) {
+      free(fds);
+      return ret;
+   }
+
+   fd_set res_read_set, res_write_set, res_except_set;
+   FD_ZERO(&res_read_set);
+   FD_ZERO(&res_write_set);
+   FD_ZERO(&res_except_set);
+
+   for (int i = 0; i < nfds; i++) {
+      struct pollfd *fd = &fds[i];
+
+      if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0) {
+         FD_SET(i, &res_read_set);
+      }
+      if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0) {
+         FD_SET(i, &res_write_set);
+      }
+      if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) {
+         FD_SET(i, &res_except_set);
+      }
+   }
+
+   free(fds);
+   if (read_set) {
+      *read_set = res_read_set;
+   }
+   if (write_set) {
+      *write_set = res_write_set;
+   }
+   if (except_set) {
+      *except_set = res_except_set;
+   }
+
+   return 0;
 }
 
 int sys_sleep(time_t *secs, long *nanos) {
-	struct timespec time = {.tv_sec = *secs, .tv_nsec = *nanos};
-	struct timespec rem  = {.tv_sec = 0, .tv_nsec = 0};
+   struct timespec time = {.tv_sec = *secs, .tv_nsec = *nanos};
+   struct timespec rem  = {.tv_sec = 0, .tv_nsec = 0};
 
-	int ret, errno;
-	SYSCALL4(SYSCALL_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, 0, &time, &rem);
-	*secs  = rem.tv_sec;
-	*nanos = rem.tv_nsec;
-	return errno;
+   int ret, errno;
+   SYSCALL4(SYSCALL_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, 0, &time, &rem);
+   *secs  = rem.tv_sec;
+   *nanos = rem.tv_nsec;
+   return errno;
 }
 
 int sys_gethostname(char *buffer, size_t bufsize) {
-	struct utsname buf;
-	if (uname(&buf)) {
-		return -1;
-	}
+   struct utsname buf;
+   if (uname(&buf)) {
+      return -1;
+   }
 
-	strncpy(buffer, buf.nodename, bufsize);
-	return 0;
+   strncpy(buffer, buf.nodename, bufsize);
+   return 0;
 }
 
 int sys_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags) {
-	int ret, errno;
-	if (pathname == NULL) {
-		pathname = "";
-		flags |= AT_EMPTY_PATH;
-	}
-
-	size_t path_len = strlen (pathname);
-	if (times == NULL) {
-		 time_t secs;
-		 long nsec;
-		 ret = sys_clock_get(CLOCK_REALTIME, &secs, &nsec);
-		 if (ret) {
-			  return ret;
-		 }
-		 struct timespec times2[2] = {0, 0};
-		 times2[0].tv_sec = secs;
-		 times2[0].tv_nsec = nsec;
-		 times2[1].tv_sec = secs;
-		 times2[1].tv_nsec = nsec;
-		 SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, &times2[0], flags);
-	} else {
-		SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, times, flags);
-	}
-
-	return errno;
+   int ret, errno;
+   if (pathname == NULL) {
+      pathname = "";
+      flags |= AT_EMPTY_PATH;
+   }
+
+   size_t path_len = strlen (pathname);
+   if (times == NULL) {
+       time_t secs;
+       long nsec;
+       ret = sys_clock_get(CLOCK_REALTIME, &secs, &nsec);
+       if (ret) {
+           return ret;
+       }
+       struct timespec times2[2] = {0, 0};
+       times2[0].tv_sec = secs;
+       times2[0].tv_nsec = nsec;
+       times2[1].tv_sec = secs;
+       times2[1].tv_nsec = nsec;
+       SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, &times2[0], flags);
+   } else {
+      SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, times, flags);
+   }
+
+   return errno;
 }
 
 int sys_sysconf(int num, long *rret) {
-	long ret, errno;
-
-	// Translate the number for the POSIX compat of the sysconf.
-	int translated;
-	switch (num) {
-		case _SC_PAGE_SIZE:		  translated = 1;  break;
-		case _SC_OPEN_MAX:			translated = 2;  break;
-		case _SC_HOST_NAME_MAX:	 translated = 3;  break;
-		case _SC_NPROCESSORS_ONLN: translated = 6;  break;
-		case _SC_PHYS_PAGES:		 translated = 7;  break;
-		case _SC_CHILD_MAX:		  translated = 11; break;
-
-		// These are values that mlibc technically has to provide itself, but
-		// I personally dont like how ugly the hardcoded warnings look, so I just
-		// harcode them myself :)
-		case _SC_LINE_MAX: *rret = 4096; return 0;
-
-		// Default is for mlibc to handle it.
-		default: return EINVAL;
-	}
-
-	SYSCALL3(SYSCALL_SYSCONF, translated, 0, 0);
-	*rret = ret;
-	return errno;
+   long ret, errno;
+   SYSCALL3(SYSCALL_SYSCONF, num, 0, 0);
+   *rret = ret;
+   return errno;
 }
 
 int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
-	int ret, errno;
-	(void)flags;
-
-	switch (fsfdt) {
-		case fsfd_target::fd: {
-			SYSCALL5(SYSCALL_STAT, fd, "", 0, statbuf, AT_EMPTY_PATH);
-			break;
-		}
-		case fsfd_target::path: {
-			size_t len = strlen(path);
-			SYSCALL5(SYSCALL_STAT, AT_FDCWD, path, len, statbuf, flags);
-			break;
-		}
-		case fsfd_target::fd_path: {
-			size_t len = strlen(path);
-			SYSCALL5(SYSCALL_STAT, fd, path, len, statbuf, flags);
-			break;
-		}
-		default: {
-			__ensure(!"stat: Invalid fsfdt");
-			__builtin_unreachable();
-		}
-	}
-
-	return errno;
+   int ret, errno;
+   (void)flags;
+
+   switch (fsfdt) {
+      case fsfd_target::fd: {
+         SYSCALL5(SYSCALL_STAT, fd, "", 0, statbuf, AT_EMPTY_PATH);
+         break;
+      }
+      case fsfd_target::path: {
+         size_t len = strlen(path);
+         SYSCALL5(SYSCALL_STAT, AT_FDCWD, path, len, statbuf, flags);
+         break;
+      }
+      case fsfd_target::fd_path: {
+         size_t len = strlen(path);
+         SYSCALL5(SYSCALL_STAT, fd, path, len, statbuf, flags);
+         break;
+      }
+      default: {
+         __ensure(!"stat: Invalid fsfdt");
+         __builtin_unreachable();
+      }
+   }
+
+   return errno;
 }
 
 int sys_chmod(const char *pathname, mode_t mode) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL5(SYSCALL_FCHMOD, AT_FDCWD, pathname, len, mode, 0);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL5(SYSCALL_FCHMOD, AT_FDCWD, pathname, len, mode, 0);
+   return errno;
 }
 
 int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL5(SYSCALL_FCHMOD, fd, pathname, len, mode, flags);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL5(SYSCALL_FCHMOD, fd, pathname, len, mode, flags);
+   return errno;
 }
 
 int sys_fchmod(int fd, mode_t mode) {
-	int ret, errno;
-	SYSCALL5(SYSCALL_FCHMOD, fd, "", 0, mode, AT_EMPTY_PATH);
-	return errno;
+   int ret, errno;
+   SYSCALL5(SYSCALL_FCHMOD, fd, "", 0, mode, AT_EMPTY_PATH);
+   return errno;
 }
 
 int sys_chown(const char *pathname, uid_t uid, gid_t gid) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL6(SYSCALL_FCHOWN, AT_FDCWD, pathname, len, uid, gid, 0);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL6(SYSCALL_FCHOWN, AT_FDCWD, pathname, len, uid, gid, 0);
+   return errno;
 }
 
 int sys_fchownat(int fd, const char *pathname, uid_t uid, gid_t gid, int flags) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL6(SYSCALL_FCHOWN, fd, pathname, len, uid, gid, flags);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL6(SYSCALL_FCHOWN, fd, pathname, len, uid, gid, flags);
+   return errno;
 }
 
 int sys_fchown(int fd, uid_t uid, gid_t gid) {
-	int ret, errno;
-	SYSCALL6(SYSCALL_FCHOWN, fd, "", 0, uid, gid, AT_EMPTY_PATH);
-	return errno;
+   int ret, errno;
+   SYSCALL6(SYSCALL_FCHOWN, fd, "", 0, uid, gid, AT_EMPTY_PATH);
+   return errno;
 }
 
 int sys_umask(mode_t mode, mode_t *old) {
-	mode_t ret;
-	int errno;
-	SYSCALL1(SYSCALL_UMASK, mode);
-	*old = (mode_t)ret;
-	return errno;
+   mode_t ret;
+   int errno;
+   SYSCALL1(SYSCALL_UMASK, mode);
+   *old = (mode_t)ret;
+   return errno;
+}
+
+int sys_fadvise(int fd, off_t offset, off_t length, int advice) {
+   int ret, errno;
+   SYSCALL4(SYSCALL_FADVISE, fd, offset, length, advice);
+   return errno;
 }
 
 int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) {
-	ssize_t ret;
-	int errno;
-	size_t path_len = strlen(path);
-	SYSCALL5(SYSCALL_READLINK, AT_FDCWD, path, path_len, buffer, max_size);
-	if (ret == -1) {
-		return errno;
-	} else {
-		*length = ret;
-		return 0;
-	}
+   ssize_t ret;
+   int errno;
+   size_t path_len = strlen(path);
+   SYSCALL5(SYSCALL_READLINK, AT_FDCWD, path, path_len, buffer, max_size);
+   if (ret == -1) {
+      return errno;
+   } else {
+      *length = ret;
+      return 0;
+   }
 }
 
 int sys_rename(const char *path, const char *new_path) {
-	int ret;
-	int errno;
-	size_t old_len = strlen(path);
-	size_t new_len = strlen(new_path);
-	SYSCALL7(SYSCALL_RENAME, AT_FDCWD, path, old_len, AT_FDCWD, new_path, new_len, 0);
-	return errno;
+   int ret;
+   int errno;
+   size_t old_len = strlen(path);
+   size_t new_len = strlen(new_path);
+   SYSCALL7(SYSCALL_RENAME, AT_FDCWD, path, old_len, AT_FDCWD, new_path, new_len, 0);
+   return errno;
 }
 
 int sys_renameat(int olddirfd, const char *old_path, int newdirfd, const char *new_path) {
-	int ret;
-	int errno;
-	size_t old_len = strlen(old_path);
-	size_t new_len = strlen(new_path);
-	SYSCALL7(SYSCALL_RENAME, olddirfd, old_path, old_len, newdirfd, new_path, new_len, 0);
-	return errno;
+   int ret;
+   int errno;
+   size_t old_len = strlen(old_path);
+   size_t new_len = strlen(new_path);
+   SYSCALL7(SYSCALL_RENAME, olddirfd, old_path, old_len, newdirfd, new_path, new_len, 0);
+   return errno;
 }
 
 int sys_mknodat(int dirfd, const char *path, mode_t mode, dev_t dev) {
-	int ret;
-	int errno;
-	size_t len = strlen(path);
-	SYSCALL5(SYSCALL_MAKENODE, dirfd, path, len, mode, dev);
-	return errno;
-}
+   int ret;
+   int errno;
+   size_t len = strlen(path);
+   SYSCALL5(SYSCALL_MAKENODE, dirfd, path, len, mode, dev);
+   return errno;
+}
+
+#define SC_LIST_MOUNTS 9
+struct mountinfo {
+    uint32_t type;
+    uint32_t flags;
+    char   source[20];
+    uint32_t source_length;
+    char   location[20];
+    uint32_t location_length;
+    uint64_t block_size;
+    uint64_t fragment_size;
+    uint64_t size_in_fragments;
+    uint64_t free_blocks;
+    uint64_t free_blocks_user;
+    uint64_t inode_count;
+    uint64_t free_inodes;
+    uint64_t free_inodes_user;
+    uint64_t max_filename;
+};
 
+int sys_statvfs(const char *path, struct statvfs *out) {
+   long ret, errno;
+   struct mountinfo *buffer = (mountinfo *)malloc(5 * sizeof(struct mountinfo));
+   SYSCALL3(SYSCALL_SYSCONF, SC_LIST_MOUNTS, buffer, 5 * sizeof(struct mountinfo));
+   if (errno) {
+      free(buffer);
+      return errno;
+   } else if (ret > 5) {
+      free(buffer);
+      return 1;
+   }
+
+   for (int i = 0; i < ret; i++) {
+      if (!strncmp(path, buffer[i].location, buffer[i].location_length)) {
+         out->f_bsize  = buffer[i].block_size;
+         out->f_frsize = buffer[i].fragment_size;
+         out->f_blocks = buffer[i].size_in_fragments;
+         out->f_bfree  = buffer[i].free_blocks;
+         out->f_bavail = buffer[i].free_blocks_user;
+         out->f_files  = buffer[i].inode_count;
+         out->f_ffree  = buffer[i].free_inodes;
+         out->f_favail = buffer[i].free_inodes_user;
+         out->f_fsid = 0;
+         out->f_flag = buffer[i].flags;
+         out->f_namemax = buffer[i].max_filename;
+         return 0;
+      }
+   }
+
+   return EINVAL;
+}
 #endif
 } // namespace mlibc
diff --git mlibc-clean/sysdeps/ironclad/generic/mount.cpp mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
index ff060e0..227bac0 100644
--- mlibc-clean/sysdeps/ironclad/generic/mount.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
@@ -4,31 +4,17 @@
 #include <sys/syscall.h>
 #include <string.h>
 
-int mount(const char *source, const char *target,
-		const char *fstype, unsigned long flags, const void *data) {
-	int ret, errno;
-	size_t source_len = strlen(source);
-	size_t target_len = strlen(target);
-	int val;
-	if (!strcmp(fstype, "ext")) {
-		val = 1;
-	} else if (!strcmp(fstype, "fat32")) {
-		val = 2;
-	} else {
-		return EINVAL;
-	}
-
-	SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, val, flags);
-	return errno;
-}
-
-int umount(const char *target) {
-	return umount2(target, 0);
+int mount(const char *source, const char *target, int type, int flags) {
+   int ret;
+   size_t source_len = strlen(source);
+   size_t target_len = strlen(target);
+   SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, type, flags);
+   return ret;
 }
 
-int umount2(const char *target, int flags) {
-	int ret, errno;
-	size_t target_len = strlen(target);
-	SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
-	return errno;
+int umount(const char *target, int flags) {
+   int ret;
+   size_t target_len = strlen(target);
+   SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
+   return ret;
 }
diff --git mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp
new file mode 100644
index 0000000..ec74e22
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp
@@ -0,0 +1,76 @@
+#include <bits/ensure.h>
+#include <stddef.h>
+#include <errno.h>
+#include <utmpx.h>
+#include <stdio.h>
+#include <time.h>
+#include <paths.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+int utmpx_file = -1;
+
+void updwtmpx(const char *, const struct utmpx *) {
+	// Empty as musl does
+}
+
+void endutxent(void) {
+	if (utmpx_file >= 0) {
+		close(utmpx_file);
+	}
+}
+
+void setutxent(void) {
+	if (utmpx_file < 0) {
+		utmpx_file = open(UTMPX_FILE, O_RDWR | O_CREAT, 0755);
+	} else {
+		lseek(utmpx_file, 0, SEEK_SET);
+	}
+}
+
+struct utmpx returned;
+
+struct utmpx *getutxent(void) {
+	if (utmpx_file < 0) {
+		setutxent();
+		if (utmpx_file < 0) {
+			return NULL;
+		}
+	}
+
+	if (read(utmpx_file, &returned, sizeof(struct utmpx)) != sizeof(struct utmpx)) {
+		return NULL;
+	}
+
+	return &returned;
+}
+
+struct utmpx *pututxline(const struct utmpx *added) {
+	if (utmpx_file < 0) {
+		setutxent();
+		if (utmpx_file < 0) {
+			return NULL;
+		}
+	}
+
+	lseek(utmpx_file, 0, SEEK_END);
+	if (write(utmpx_file, added, sizeof(struct utmpx)) != sizeof(struct utmpx)) {
+		return NULL;
+	}
+
+	return (struct utmpx *)added;
+}
+
+int utmpxname(const char *path) {
+	if (utmpx_file > 0) {
+		close(utmpx_file);
+	}
+
+	utmpx_file = open(path, O_RDWR | O_CREAT, 0755);
+	if (utmpx_file > 0) {
+		lseek(utmpx_file, 0, SEEK_END);
+		return 1;
+	} else {
+		return 0;
+	}
+}
diff --git mlibc-clean/sysdeps/ironclad/include/sys/mount.h mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
index 71ae64d..51263fa 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/mount.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
@@ -5,12 +5,17 @@
 extern "C" {
 #endif
 
+#define MNT_EXT 1
+#define MNT_FAT 2
+
+#define MS_RDONLY   0b001
+#define MS_REMOUNT  0b010
+#define MS_RELATIME 0b100
+
 #define MNT_FORCE 1
 
-int mount(const char *source, const char *target,
-		const char *fstype, unsigned long flags, const void *data);
-int umount(const char *target);
-int umount2(const char *target, int flags);
+int mount(const char *source, const char *target, int type, int flags);
+int umount(const char *target, int flags);
 
 #ifdef __cplusplus
 }
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index b0227d5..2ef5f60 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -84,87 +84,100 @@
 				  : "rcx", "r11", "memory"); \
 })
 
-#define SYSCALL_EXIT                  0
-#define SYSCALL_ARCH_PRCTL            1
-#define SYSCALL_OPEN                  2
-#define SYSCALL_CLOSE                 3
-#define SYSCALL_READ                  4
-#define SYSCALL_WRITE                 5
-#define SYSCALL_SEEK                  6
-#define SYSCALL_MMAP                  7
-#define SYSCALL_MUNMAP                8
-#define SYSCALL_GETPID                9
-#define SYSCALL_GETPPID              10
-#define SYSCALL_EXEC                 11
-#define SYSCALL_CLONE                12
-#define SYSCALL_WAIT                 13
-#define SYSCALL_SOCKET               14
-#define SYSCALL_SETHOSTNAME          15
-#define SYSCALL_UNLINK               16
-#define SYSCALL_STAT                 17
-#define SYSCALL_GETCWD               18
-#define SYSCALL_CHDIR                19
-#define SYSCALL_IOCTL                20
-#define SYSCALL_SCHED_YIELD          21
-#define SYSCALL_DELETE_TCLUSTER      22
-#define SYSCALL_PIPE                 23
-#define SYSCALL_GETUID               24
-#define SYSCALL_RENAME               25
-#define SYSCALL_SYSCONF              26
-#define SYSCALL_SPAWN                27
-#define SYSCALL_GETTID               28
-#define SYSCALL_MANAGE_TCLUSTER      29
-#define SYSCALL_FCNTL                30
-#define SYSCALL_EXIT_THREAD          31
-#define SYSCALL_GETRANDOM            32
-#define SYSCALL_MPROTECT             33
-#define SYSCALL_SYNC                 34
+#define SYSCALL_EXIT						0
+#define SYSCALL_ARCH_PRCTL				1
+#define SYSCALL_OPEN						2
+#define SYSCALL_CLOSE					  3
+#define SYSCALL_READ						4
+#define SYSCALL_WRITE					  5
+#define SYSCALL_SEEK						6
+#define SYSCALL_MMAP						7
+#define SYSCALL_MUNMAP					 8
+#define SYSCALL_GETPID					 9
+#define SYSCALL_GETPPID				  10
+#define SYSCALL_EXEC					  11
+#define SYSCALL_CLONE					 12
+#define SYSCALL_WAIT					  13
+#define SYSCALL_SOCKET					14
+#define SYSCALL_SETHOSTNAME			 15
+#define SYSCALL_UNLINK					16
+#define SYSCALL_STAT					  17
+#define SYSCALL_GETCWD					18
+#define SYSCALL_CHDIR					 19
+#define SYSCALL_IOCTL					 20
+#define SYSCALL_SCHED_YIELD			 21
+#define SYSCALL_DELETE_TCLUSTER		22
+#define SYSCALL_PIPE					  23
+#define SYSCALL_GETUID					24
+#define SYSCALL_RENAME					25
+#define SYSCALL_SYSCONF				  26
+#define SYSCALL_SPAWN					 27
+#define SYSCALL_GETTID					28
+#define SYSCALL_MANAGE_TCLUSTER		29
+#define SYSCALL_FCNTL					 30
+#define SYSCALL_EXIT_THREAD			 31
+#define SYSCALL_GETRANDOM				32
+#define SYSCALL_MPROTECT				 33
+#define SYSCALL_SYNC					  34
 #define SYSCALL_SET_MAC_CAPABILITIES 35
 #define SYSCALL_GET_MAC_CAPABILITIES 36
 #define SYSCALL_ADD_MAC_PERMISSIONS  37
 #define SYSCALL_SET_MAC_ENFORCEMENT  38
-#define SYSCALL_MOUNT                39
-#define SYSCALL_UMOUNT               40
-#define SYSCALL_READLINK             41
-#define SYSCALL_GETDENTS             42
-#define SYSCALL_MAKENODE             43
-#define SYSCALL_TRUNCATE             44
-#define SYSCALL_BIND                 45
-#define SYSCALL_SYMLINK              46
-#define SYSCALL_CONNECT              47
-#define SYSCALL_OPENPTY              48
-#define SYSCALL_FSYNC                49
-#define SYSCALL_LINK                 50
-#define SYSCALL_PTRACE               51
-#define SYSCALL_LISTEN               52
-#define SYSCALL_ACCEPT               53
-#define SYSCALL_GETRLIMIT            54
-#define SYSCALL_SETRLIMIT            55
-#define SYSCALL_ACCESS               56
-#define SYSCALL_POLL                 57
-#define SYSCALL_GETEUID              58
-#define SYSCALL_SETUIDS              59
-#define SYSCALL_FCHMOD               60
-#define SYSCALL_UMASK                61
-#define SYSCALL_REBOOT               62
-#define SYSCALL_FCHOWN               63
-#define SYSCALL_PREAD                64
-#define SYSCALL_PWRITE               65
-#define SYSCALL_GETSOCKNAME          66
-#define SYSCALL_GETPEERNAME          67
-#define SYSCALL_SHUTDOWN             68
-#define SYSCALL_FUTEX                69
-#define SYSCALL_CLOCK                70
-#define SYSCALL_CLOCK_NANOSLEEP      71
-#define SYSCALL_GETRUSAGE            72
-#define SYSCALL_RECVFROM             73
-#define SYSCALL_SENDTO               74
-#define SYSCALL_CONFIG_NETINTER      75
-#define SYSCALL_UTIMES               76
-#define SYSCALL_CREATE_TCLUSTER      77
-#define SYSCALL_SWITCH_TCLUSTER      78
-#define SYSCALL_ACTUALLY_KILL        79
-#define SYSCALL_SIGNALPOST           80
-#define SYSCALL_SEND_SIGNAL          81
+#define SYSCALL_MOUNT					 39
+#define SYSCALL_UMOUNT					40
+#define SYSCALL_READLINK				 41
+#define SYSCALL_GETDENTS				 42
+#define SYSCALL_MAKENODE				 43
+#define SYSCALL_TRUNCATE				 44
+#define SYSCALL_BIND					  45
+#define SYSCALL_SYMLINK				  46
+#define SYSCALL_CONNECT				  47
+#define SYSCALL_OPENPTY				  48
+#define SYSCALL_FSYNC					 49
+#define SYSCALL_LINK					  50
+#define SYSCALL_PTRACE					51
+#define SYSCALL_LISTEN					52
+#define SYSCALL_ACCEPT					53
+#define SYSCALL_GETRLIMIT				54
+#define SYSCALL_SETRLIMIT				55
+#define SYSCALL_ACCESS					56
+#define SYSCALL_POLL					  57
+#define SYSCALL_GETEUID				  58
+#define SYSCALL_SETUIDS				  59
+#define SYSCALL_FCHMOD					60
+#define SYSCALL_UMASK					 61
+#define SYSCALL_REBOOT					62
+#define SYSCALL_FCHOWN					63
+#define SYSCALL_PREAD					 64
+#define SYSCALL_PWRITE					65
+#define SYSCALL_GETSOCKNAME			 66
+#define SYSCALL_GETPEERNAME			 67
+#define SYSCALL_SHUTDOWN				 68
+#define SYSCALL_FUTEX					 69
+#define SYSCALL_CLOCK					 70
+#define SYSCALL_CLOCK_NANOSLEEP		71
+#define SYSCALL_GETRUSAGE				72
+#define SYSCALL_RECVFROM				 73
+#define SYSCALL_SENDTO					74
+#define SYSCALL_CONFIG_NETINTER		75
+#define SYSCALL_UTIMES					76
+#define SYSCALL_CREATE_TCLUSTER		77
+#define SYSCALL_SWITCH_TCLUSTER		78
+#define SYSCALL_ACTUALLY_KILL		  79
+#define SYSCALL_SIGNALPOST			  80
+#define SYSCALL_SEND_SIGNAL			 81
+#define SYSCALL_GETPRIO				  82
+#define SYSCALL_SETPRIO				  83
+#define SYSCALL_GETGID					84
+#define SYSCALL_GETEGID				  85
+#define SYSCALL_SETGIDS				  86
+#define SYSCALL_GETGROUPS				87
+#define SYSCALL_SETGROUPS				88
+#define SYSCALL_TTYNAME             89
+#define SYSCALL_FADVISE             90
+#define SYSCALL_SHMAT             91
+#define SYSCALL_SHMCTL             92
+#define SYSCALL_SHMDT             93
+#define SYSCALL_SHMGET             94
 
 #endif // _SYS_SYSCALL_H
diff --git mlibc-workdir/sysdeps/ironclad/include/utmpx.h mlibc-workdir/sysdeps/ironclad/include/utmpx.h
new file mode 100644
index 0000000..2d7d3e1
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/utmpx.h
@@ -0,0 +1,63 @@
+
+#ifndef  _UTMPX_H
+#define  _UTMPX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <abi-bits/pid_t.h>
+#include <bits/posix/timeval.h>
+
+#define UTMPX_FILE "/var/run/utmp"
+#define WTMPX_FILE "/var/run/wtmp"
+
+// Struct definition taken from musl
+struct utmpx {
+	short ut_type;
+	short __ut_pad1;
+	pid_t ut_pid;
+	char ut_line[32];
+	char ut_id[4];
+	char ut_user[32];
+	char ut_host[256];
+	struct {
+		short __e_termination;
+		short __e_exit;
+	} ut_exit;
+	int ut_session, __ut_pad2;
+	struct timeval ut_tv;
+	unsigned ut_addr_v6[4];
+	char __unused[20];
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+void updwtmpx(const char *, const struct utmpx *);
+int utmpxname(const char *);
+struct utmpx *pututxline(const struct utmpx *);
+struct utmpx *getutxent(void);
+void setutxent(void);
+void endutxent(void);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#define EMPTY           0
+#define RUN_LVL         1
+#define BOOT_TIME       2
+#define NEW_TIME        3
+#define OLD_TIME        4
+#define INIT_PROCESS    5
+#define LOGIN_PROCESS   6
+#define USER_PROCESS    7
+#define DEAD_PROCESS    8
+
+#define __UT_HOSTSIZE 256
+#define __UT_NAMESIZE 32
+#define __UT_LINESIZE 32
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _UTMPX_H
diff --git mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
index d12e2e1..b713b0d 100644
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -14,7 +14,8 @@ libc_sources += files(
 	'generic/thread.cpp',
 	'generic/mac.cpp',
 	'generic/sched2.cpp',
-	'generic/thread.S'
+	'generic/thread.S',
+	'generic/utmpx.cpp'
 )
 
 if not no_headers
@@ -87,7 +88,8 @@ if not no_headers
 
 	install_headers(
 		'include/mntent.h',
-		'include/pty.h'
+		'include/pty.h',
+		'include/utmpx.h'
 	)
 endif
 
