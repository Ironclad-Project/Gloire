diff --git vte-clean/meson.build vte-workdir/meson.build
index 3979c7d..545ebbd 100644
--- vte-clean/meson.build
+++ vte-workdir/meson.build
@@ -262,7 +262,7 @@ endforeach
 # Check for symbols
 
 check_symbols_required = [
-  ['TIOCGWINSZ', ['sys/ioctl.h', 'sys/termios.h',]],
+  ['TIOCGWINSZ', ['asm/ioctls.h']],
 ]
 
 foreach symbol: check_symbols_required
diff --git vte-clean/src/missing.cc vte-workdir/src/missing.cc
index c769fb4..68dfc79 100644
--- vte-clean/src/missing.cc
+++ vte-workdir/src/missing.cc
@@ -125,7 +125,7 @@ getrlimit_NOFILE_max(void)
 
 #endif /* HAVE_SYS_RESOURCE_H */
 
-#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__) || defined(__ironclad__)
         /* Use sysconf() function provided by the system if it is known to be
          * async-signal safe.
          */
@@ -250,10 +250,9 @@ fdwalk(int (*cb)(void *data, int fd),
 #endif
 
   for (fd = 0; fd < int(open_max); fd++)
-      if ((res = cb (data, fd)) != 0)
-          break;
+      cb (data, fd);
 
-  return res;
+  return 0;
 }
 #endif /* !HAVE_FDWALK */
 
diff --git vte-clean/src/pty.cc vte-workdir/src/pty.cc
index 067dba3..2dba2ac 100644
--- vte-clean/src/pty.cc
+++ vte-workdir/src/pty.cc
@@ -96,86 +96,11 @@ Pty::unref() noexcept
 int
 Pty::get_peer(bool cloexec) const noexcept
 {
-        if (!m_pty_fd)
-                return -1;
-
-        /* FIXME? else if (m_flags & VTE_PTY_NO_CTTTY)
-         * No session and no controlling TTY wanted, do we need to lose our controlling TTY,
-         * perhaps by open("/dev/tty") + ioctl(TIOCNOTTY) ?
-         */
-
-        /* Now open the PTY peer. Note that this also makes the PTY our controlling TTY. */
-        auto const fd_flags = int{O_RDWR |
-                                  ((m_flags & VTE_PTY_NO_CTTY) ? O_NOCTTY : 0) |
-                                  (cloexec ? O_CLOEXEC : 0)};
-
-        auto peer_fd = vte::libc::FD{};
-
-#ifdef __linux__
-        peer_fd = ioctl(m_pty_fd.get(), TIOCGPTPEER, fd_flags);
-        /* Note: According to the kernel's own tests (tools/testing/selftests/filesystems/devpts_pts.c),
-         * the error returned when the running kernel does not support this ioctl should be EINVAL.
-         * However it appears that the actual error returned is ENOTTY. So we check for both of them.
-         * See issue#182.
-         */
-        if (!peer_fd &&
-            errno != EINVAL &&
-            errno != ENOTTY) {
-                auto errsv = vte::libc::ErrnoSaver{};
-                _vte_debug_print(VTE_DEBUG_PTY, "%s failed: %s\n",
-                                 "ioctl(TIOCGPTPEER)", g_strerror(errsv));
-                return -1;
+        if (cloexec) {
+                vte::libc::fd_set_cloexec(m_slave_fd.get());
         }
 
-        /* Fall back to ptsname + open */
-#endif
-
-        if (!peer_fd) {
-                auto const name = ptsname(m_pty_fd.get());
-                if (name == nullptr) {
-                        auto errsv = vte::libc::ErrnoSaver{};
-                        _vte_debug_print(VTE_DEBUG_PTY, "%s failed: %s\n",
-                                         "ptsname", g_strerror(errsv));
-                        return -1;
-                }
-
-                _vte_debug_print (VTE_DEBUG_PTY,
-                                  "Setting up child pty: master FD = %d name = %s\n",
-                                  m_pty_fd.get(), name);
-
-                peer_fd = ::open(name, fd_flags);
-                if (!peer_fd) {
-                        auto errsv = vte::libc::ErrnoSaver{};
-                        _vte_debug_print (VTE_DEBUG_PTY, "Failed to open PTY: %s\n",
-                                          g_strerror(errsv));
-                        return -1;
-                }
-        }
-
-        assert(bool(peer_fd));
-
-#if defined(__sun) && defined(HAVE_STROPTS_H)
-        /* See https://illumos.org/man/7i/streamio */
-        if (isastream (peer_fd.get()) == 1) {
-                /* https://illumos.org/man/7m/ptem */
-                if ((ioctl(peer_fd.get(), I_FIND, "ptem") == 0) &&
-                    (ioctl(peer_fd.get(), I_PUSH, "ptem") == -1)) {
-                        return -1;
-                }
-                /* https://illumos.org/man/7m/ldterm */
-                if ((ioctl(peer_fd.get(), I_FIND, "ldterm") == 0) &&
-                    (ioctl(peer_fd.get(), I_PUSH, "ldterm") == -1)) {
-                        return -1;
-                }
-                /* https://illumos.org/man/7m/ttcompat */
-                if ((ioctl(peer_fd.get(), I_FIND, "ttcompat") == 0) &&
-                    (ioctl(peer_fd.get(), I_PUSH, "ttcompat") == -1)) {
-                        return -1;
-                }
-        }
-#endif
-
-        return peer_fd.release();
+        return m_slave_fd.get();
 }
 
 void
@@ -411,13 +336,16 @@ fd_setup(vte::libc::FD& fd)
  * Returns: the new PTY's master FD, or -1
  */
 static vte::libc::FD
-_vte_pty_open_posix(void)
+_vte_pty_open_posix(vte::libc::FD *slave)
 {
 	/* Attempt to open the master. */
-        auto fd = vte::libc::FD{posix_openpt(O_RDWR | O_NOCTTY | O_NONBLOCK | O_CLOEXEC)};
+        int mfd, sfd;
+        openpty(&mfd, &sfd, NULL, NULL, NULL);
+        *slave = vte::libc::FD{sfd};
+        auto fd = vte::libc::FD{mfd};
 #ifndef __linux__
         /* Other kernels may not support CLOEXEC or NONBLOCK above, so try to fall back */
-        bool need_cloexec = false, need_nonblocking = false;
+        bool need_cloexec = true, need_nonblocking = true;
 
 #ifdef __NetBSD__
         // NetBSD is a special case: prior to 9.99.101, posix_openpt() will not return
@@ -565,22 +493,19 @@ Pty::set_utf8(bool utf8) const noexcept
 Pty*
 Pty::create(VtePtyFlags flags)
 {
-        auto fd = _vte_pty_open_posix();
+        vte::libc::FD fd, sfd;
+        fd = _vte_pty_open_posix(&sfd);
         if (!fd)
                 return nullptr;
 
-        return new Pty{std::move(fd), flags};
+        return new Pty{std::move(fd), std::move(sfd), flags};
 }
 
 Pty*
 Pty::create_foreign(int foreign_fd,
                     VtePtyFlags flags)
 {
-        auto fd = _vte_pty_open_foreign(foreign_fd);
-        if (!fd)
-                return nullptr;
-
-        return new Pty{std::move(fd), flags};
+        return nullptr;
 }
 
 } // namespace vte::base
diff --git vte-clean/src/pty.hh vte-workdir/src/pty.hh
index 2dc8ac9..509bf85 100644
--- vte-clean/src/pty.hh
+++ vte-workdir/src/pty.hh
@@ -31,12 +31,15 @@ class Pty {
 private:
         mutable volatile int m_refcount{1};
         vte::libc::FD m_pty_fd{};
+        vte::libc::FD m_slave_fd{};
         VtePtyFlags m_flags{VTE_PTY_DEFAULT};
 
 public:
         constexpr Pty(vte::libc::FD&& fd,
+                      vte::libc::FD&& slave,
                       VtePtyFlags flags = VTE_PTY_DEFAULT) noexcept
                 : m_pty_fd{std::move(fd)},
+                  m_slave_fd{std::move(slave)},
                   m_flags{flags}
         {
         }
diff --git vte-clean/src/widget.cc vte-workdir/src/widget.cc
index 0daaed1..f667db1 100644
--- vte-clean/src/widget.cc
+++ vte-workdir/src/widget.cc
@@ -913,6 +913,10 @@ Widget::direction_changed(GtkTextDirection old_direction) noexcept
         // FIXME: does this need to feed to BiDi somehow?
 }
 
+#ifndef W_EXITCODE
+#define W_EXITCODE(ret, sig) (((ret) << 8) | (sig))
+#endif
+
 void
 Widget::dispose() noexcept
 {
