diff --git mlibc-clean/abis/ironclad/statvfs.h mlibc-workdir/abis/ironclad/statvfs.h
index 7a75d3a..d4fc416 100644
--- mlibc-clean/abis/ironclad/statvfs.h
+++ mlibc-workdir/abis/ironclad/statvfs.h
@@ -23,6 +23,7 @@ struct statvfs {
 	unsigned long f_fsid;
 	unsigned long f_flag;
 	unsigned long f_namemax;
+	char f_basetype[80];
 };
 
 #endif /* _ABIBITS_STATVFS_H */
diff --git mlibc-clean/abis/ironclad/termios.h mlibc-workdir/abis/ironclad/termios.h
index e8ebffd..4dd5987 100644
--- mlibc-clean/abis/ironclad/termios.h
+++ mlibc-workdir/abis/ironclad/termios.h
@@ -32,6 +32,9 @@ typedef unsigned int tcflag_t;
 #define IXOFF   0x0200
 #define IXON    0x0400
 #define PARMRK  0x0800
+#define ECHOCTL 0001000
+#define IMAXBEL 0020000
+#define ECHOKE  0004000
 
 // bitwise flags for c_oflag in struct termios
 #define OPOST   0x0001
diff --git mlibc-clean/options/ansi/generic/time-stubs.cpp mlibc-workdir/options/ansi/generic/time-stubs.cpp
index 887a7d3..547bb10 100644
--- mlibc-clean/options/ansi/generic/time-stubs.cpp
+++ mlibc-workdir/options/ansi/generic/time-stubs.cpp
@@ -242,7 +242,8 @@ size_t strftime(char *__restrict dest, size_t max_size,
 			c++;
 			break;
 		}
-		case 'I': {
+		case 'I':
+		case 'l': {
 			int hour = tm->tm_hour;
 			if(!hour)
 				hour = 12;
diff --git mlibc-clean/options/ansi/include/math.h mlibc-workdir/options/ansi/include/math.h
index ff98c16..27a0ff1 100644
--- mlibc-clean/options/ansi/include/math.h
+++ mlibc-workdir/options/ansi/include/math.h
@@ -60,10 +60,10 @@ int __fpclassifyf(float x);
 int __fpclassifyl(long double x);
 
 #define fpclassify(x) \
-	(sizeof(x) == sizeof(double) ? __fpclassify(x) : \
-	(sizeof(x) == sizeof(float) ? __fpclassifyf(x) : \
-	(sizeof(x) == sizeof(long double) ? __fpclassifyl(x) : \
-	0)))
+   (sizeof(x) == sizeof(double) ? __fpclassify(x) : \
+   (sizeof(x) == sizeof(float) ? __fpclassifyf(x) : \
+   (sizeof(x) == sizeof(long double) ? __fpclassifyl(x) : \
+   0)))
 
 #define isfinite(x) (fpclassify(x) & (FP_NORMAL | FP_SUBNORMAL | FP_ZERO))
 #define isnan(x) (fpclassify(x) == FP_NAN)
@@ -94,9 +94,9 @@ __MLIBC_INLINE_DEFINITION int __mlibc_isgreaterequall(long double x, long double
 
 // TODO: We chould use _Generic here but that does not work in C++ code.
 #define __MLIBC_CHOOSE_COMPARISON(x, y, p) ( \
-	sizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \
-	sizeof((x)+(y)) == sizeof(double) ? p(x, y) : \
-	p##l(x, y) )
+   sizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \
+   sizeof((x)+(y)) == sizeof(double) ? p(x, y) : \
+   p##l(x, y) )
 
 #define isless(x, y) __MLIBC_CHOOSE_COMPARISON(x, y, __mlibc_isless)
 #define islessequal(x, y) __MLIBC_CHOOSE_COMPARISON(x, y, __mlibc_islessequal)
@@ -359,6 +359,8 @@ double fmin(double x, double y);
 float fminf(float x, float y);
 long double fminl(long double x, long double y);
 
+int finite(double x);
+
 // [C11/7.12.13 Floating multiply-add]
 
 double fma(double, double, double);
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..1ce0414 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -2,8 +2,7 @@
 #include <bits/ensure.h>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..011d9c0 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -91,9 +91,9 @@ bool charset::is_space(codepoint c) {
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
+	/*if(c > 0x7F)
 		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+				" for the full Unicode charset" << frg::endlog;*/
 	return false;
 }
 
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 95a4fa5..debf210 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -487,9 +487,16 @@ int strcoll_l(const char *, const char *, locale_t) {
 	__builtin_unreachable();
 }
 
-int getloadavg(double *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+#include <sys/syscall.h>
+
+int getloadavg(double *samples, int nsample) {
+	int ret;
+	int samples2[3];
+	SYSCALL3(SYSCALL_SYSCONF, 19, samples2, sizeof(samples2));
+	for (int i = 0; i < 3; i++) {
+		samples[i] = samples2[i] / 100.0;
+	}
+	return 3;
 }
 
 char *secure_getenv(const char *name) {
diff --git mlibc-clean/options/posix/generic/sys-shm.cpp mlibc-workdir/options/posix/generic/sys-shm.cpp
index 3af7e90..a02d4a2 100644
--- mlibc-clean/options/posix/generic/sys-shm.cpp
+++ mlibc-workdir/options/posix/generic/sys-shm.cpp
@@ -2,23 +2,29 @@
 
 #include <bits/ensure.h>
 #include <mlibc/debug.hpp>
+#include <sys/syscall.h>
+#include <errno.h>
 
-void *shmat(int, const void *, int) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+void *shmat(int shmid, const void *shmaddr, int shmflg) {
+	void *ret;
+	SYSCALL3(SYSCALL_SHMAT, shmid, shmaddr, shmflg);
+	return ret;
 }
 
-int shmctl(int, int, struct shmid_ds *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+int shmctl(int shmid, int cmd, struct shmid_ds *buf) {
+	int ret;
+	SYSCALL3(SYSCALL_SHMCTL, shmid, cmd, buf);
+	return ret;
 }
 
-int shmdt(const void *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+int shmdt(const void *shmaddr) {
+	int ret;
+	SYSCALL1(SYSCALL_SHMDT, shmaddr);
+	return ret;
 }
 
-int shmget(key_t, size_t, int) {
-	mlibc::infoLogger() << "mlibc: shmget() is a no-op!" << frg::endlog;
-	return -1;
+int shmget(key_t key, size_t size, int shmflg) {
+	int ret;
+	SYSCALL3(SYSCALL_SHMGET, key, size, shmflg);
+	return ret;
 }
diff --git mlibc-clean/options/posix/include/fcntl.h mlibc-workdir/options/posix/include/fcntl.h
index 9983219..b43929d 100644
--- mlibc-clean/options/posix/include/fcntl.h
+++ mlibc-workdir/options/posix/include/fcntl.h
@@ -62,9 +62,6 @@ ssize_t vmsplice(int fd, const struct iovec *iov, size_t nr_segs, unsigned int f
 
 #define AT_NO_AUTOMOUNT 0x800
 
-#define F_SETPIPE_SZ 1031
-#define F_GETPIPE_SZ 1032
-
 #define FALLOC_FL_KEEP_SIZE 1
 #define FALLOC_FL_PUNCH_HOLE 2
 
diff --git mlibc-clean/options/posix/include/unistd.h mlibc-workdir/options/posix/include/unistd.h
index 4cc7507..caefe10 100644
--- mlibc-clean/options/posix/include/unistd.h
+++ mlibc-workdir/options/posix/include/unistd.h
@@ -94,103 +94,117 @@ extern "C" {
 
 // MISSING: _PC macros
 // For now, use the Linux ABI for _PC constants.
-#define _PC_LINK_MAX		0
-#define _PC_MAX_CANON		1
-#define _PC_MAX_INPUT		2
-#define _PC_NAME_MAX		3
-#define _PC_PATH_MAX		4
-#define _PC_PIPE_BUF		5
-#define _PC_CHOWN_RESTRICTED	6
-#define _PC_NO_TRUNC		7
-#define _PC_VDISABLE		8
+#define _PC_LINK_MAX    0
+#define _PC_MAX_CANON      1
+#define _PC_MAX_INPUT      2
+#define _PC_NAME_MAX    3
+#define _PC_PATH_MAX    4
+#define _PC_PIPE_BUF    5
+#define _PC_CHOWN_RESTRICTED  6
+#define _PC_NO_TRUNC    7
+#define _PC_VDISABLE    8
 
 #define _PC_FILESIZEBITS 9
 #define _PC_SYMLINK_MAX 10
 
-// MISSING: remaining _SC_macros
-#define _SC_ARG_MAX 0
-#define _SC_GETPW_R_SIZE_MAX 1
-#define _SC_PHYS_PAGES 2
-#define _SC_PAGE_SIZE 3
-#define _SC_PAGESIZE _SC_PAGE_SIZE
-#define _SC_OPEN_MAX 5
+// Kernel-supported ABI SC flags
+// TODO: This should be moved to its own abi but the mlibc people wont let
+// me do so without CBT.
+#define _SC_PAGESIZE         1
+#define _SC_OPEN_MAX         2
+#define _SC_HOST_NAME_MAX    3
+#define _SC_AVPHYS_PAGES     4
+#define _SC_PHYS_PAGES       5
 #define _SC_NPROCESSORS_ONLN 6
-#define _SC_GETGR_R_SIZE_MAX 7
-
-#define _SC_CHILD_MAX 8
-#define _SC_CLK_TCK 9
-#define _SC_NGROUPS_MAX 10
-#define _SC_VERSION 11
-#define _SC_SAVED_IDS 12
-#define _SC_JOB_CONTROL 13
-#define _SC_HOST_NAME_MAX 14
-#define _SC_LINE_MAX 15
-#define _SC_XOPEN_CRYPT 16
-#define _SC_NPROCESSORS_CONF 17
-#define _SC_SYMLOOP_MAX 18
-#define _SC_TTY_NAME_MAX 19
-#define _SC_RE_DUP_MAX 20
-
-#define _SC_ATEXIT_MAX 21
-#define _SC_LOGIN_NAME_MAX 22
-#define _SC_THREAD_DESTRUCTOR_ITERATIONS 23
-#define _SC_THREAD_KEYS_MAX 24
-#define _SC_THREAD_STACK_MIN 25
-#define _SC_THREAD_THREADS_MAX 26
-#define _SC_TZNAME_MAX 27
-#define _SC_ASYNCHRONOUS_IO 28
-#define _SC_FSYNC 29
-#define _SC_MAPPED_FILES 30
-#define _SC_MEMLOCK 31
-#define _SC_MEMLOCK_RANGE 32
-#define _SC_MEMORY_PROTECTION 33
-#define _SC_MESSAGE_PASSING 34
-#define _SC_PRIORITY_SCHEDULING 35
-#define _SC_REALTIME_SIGNALS 36
-#define _SC_SEMAPHORES 37
-#define _SC_SHARED_MEMORY_OBJECTS 38
-#define _SC_SYNCHRONIZED_IO 39
-#define _SC_THREADS 40
-#define _SC_THREAD_ATTR_STACKADDR 41
-#define _SC_THREAD_ATTR_STACKSIZE 42
-#define _SC_THREAD_PRIORITY_SCHEDULING 43
-#define _SC_THREAD_PRIO_INHERIT 44
-#define _SC_THREAD_PRIO_PROTECT 45
-#define _SC_THREAD_PROCESS_SHARED 46
-#define _SC_THREAD_SAFE_FUNCTIONS 47
-#define _SC_TIMERS 48
-#define _SC_TIMER_MAX 49
-#define _SC_2_CHAR_TERM 50
-#define _SC_2_C_BIND 51
-#define _SC_2_C_DEV 52
-#define _SC_2_FORT_DEV 53
-#define _SC_2_FORT_RUN 54
-#define _SC_2_LOCALEDEF 55
-#define _SC_2_SW_DEV 56
-#define _SC_2_UPE 57
-#define _SC_2_VERSION 58
-#define _SC_CLOCK_SELECTION 59
-#define _SC_CPUTIME 60
-#define _SC_THREAD_CPUTIME 61
-#define _SC_MONOTONIC_CLOCK 62
-#define _SC_READER_WRITER_LOCKS 63
-#define _SC_SPIN_LOCKS 64
-#define _SC_REGEXP 65
-#define _SC_SHELL 66
-#define _SC_SPAWN 67
-#define _SC_2_PBS 68
-#define _SC_2_PBS_ACCOUNTING 69
-#define _SC_2_PBS_LOCATE 70
-#define _SC_2_PBS_TRACK 71
-#define _SC_2_PBS_MESSAGE 72
-#define _SC_STREAM_MAX 73
-#define _SC_AIO_LISTIO_MAX 74
-#define _SC_AIO_MAX 75
-#define _SC_DELAYTIMER_MAX 76
-#define _SC_MQ_OPEN_MAX 77
-#define _SC_MQ_PRIO_MAX 78
-#define _SC_RTSIG_MAX 79
-#define _SC_SIGQUEUE_MAX 80
+#define _SC_TOTAL_PAGES      7
+#define _SC_LIST_PROCS       8
+#define _SC_LIST_MOUNTS      9
+#define _SC_UNAME            10
+#define _SC_CHILD_MAX        11
+#define _SC_LIST_THREADS     12
+#define _SC_LIST_CLUSTERS    13
+#define _SC_LIST_NETINTER    14
+#define _SC_DUMPLOGS         15
+#define _SC_NGROUPS_MAX      16
+#define _SC_SYMLOOP_MAX      17
+
+// SC Aliases
+#define _SC_PAGE_SIZE _SC_PAGESIZE
+
+// The rest of libc-emulated SC macros
+// MISSING: remaining _SC_macros
+#define _SC_ARG_MAX                      18
+#define _SC_GETPW_R_SIZE_MAX             19
+#define _SC_GETGR_R_SIZE_MAX             20
+#define _SC_CLK_TCK                      21
+#define _SC_VERSION                      22
+#define _SC_SAVED_IDS                    23
+#define _SC_JOB_CONTROL                  24
+#define _SC_LINE_MAX                     25
+#define _SC_XOPEN_CRYPT                  26
+#define _SC_NPROCESSORS_CONF             27
+#define _SC_TTY_NAME_MAX                 28
+#define _SC_RE_DUP_MAX                   29
+#define _SC_ATEXIT_MAX                   30
+#define _SC_LOGIN_NAME_MAX               31
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS 32
+#define _SC_THREAD_KEYS_MAX              33
+#define _SC_THREAD_STACK_MIN             34
+#define _SC_THREAD_THREADS_MAX           35
+#define _SC_TZNAME_MAX                   36
+#define _SC_ASYNCHRONOUS_IO              37
+#define _SC_FSYNC                        38
+#define _SC_MAPPED_FILES                 39
+#define _SC_MEMLOCK                      40
+#define _SC_MEMLOCK_RANGE                41
+#define _SC_MEMORY_PROTECTION            42
+#define _SC_MESSAGE_PASSING              43
+#define _SC_PRIORITY_SCHEDULING          44
+#define _SC_REALTIME_SIGNALS             45
+#define _SC_SEMAPHORES                   46
+#define _SC_SHARED_MEMORY_OBJECTS        47
+#define _SC_SYNCHRONIZED_IO              48
+#define _SC_THREADS                      49
+#define _SC_THREAD_ATTR_STACKADDR        50
+#define _SC_THREAD_ATTR_STACKSIZE        51
+#define _SC_THREAD_PRIORITY_SCHEDULING   52
+#define _SC_THREAD_PRIO_INHERIT          53
+#define _SC_THREAD_PRIO_PROTECT          54
+#define _SC_THREAD_PROCESS_SHARED        55
+#define _SC_THREAD_SAFE_FUNCTIONS        56
+#define _SC_TIMERS                       57
+#define _SC_TIMER_MAX                    58
+#define _SC_2_CHAR_TERM                  59
+#define _SC_2_C_BIND                     60
+#define _SC_2_C_DEV                      61
+#define _SC_2_FORT_DEV                   62
+#define _SC_2_FORT_RUN                   63
+#define _SC_2_LOCALEDEF                  64
+#define _SC_2_SW_DEV                     65
+#define _SC_2_UPE                        66
+#define _SC_2_VERSION                    67
+#define _SC_CLOCK_SELECTION              68
+#define _SC_CPUTIME                      69
+#define _SC_THREAD_CPUTIME               70
+#define _SC_MONOTONIC_CLOCK              71
+#define _SC_READER_WRITER_LOCKS          72
+#define _SC_SPIN_LOCKS                   73
+#define _SC_REGEXP                       74
+#define _SC_SHELL                        75
+#define _SC_SPAWN                        76
+#define _SC_2_PBS                        78
+#define _SC_2_PBS_ACCOUNTING             79
+#define _SC_2_PBS_LOCATE                 80
+#define _SC_2_PBS_TRACK                  81
+#define _SC_2_PBS_MESSAGE                82
+#define _SC_STREAM_MAX                   83
+#define _SC_AIO_LISTIO_MAX               84
+#define _SC_AIO_MAX                      85
+#define _SC_DELAYTIMER_MAX               86
+#define _SC_MQ_OPEN_MAX                  88
+#define _SC_MQ_PRIO_MAX                  89
+#define _SC_RTSIG_MAX                    90
+#define _SC_SIGQUEUE_MAX                 91
 
 #define STDERR_FILENO 2
 #define STDIN_FILENO 0
diff --git mlibc-clean/options/posix/meson.build mlibc-workdir/options/posix/meson.build
index b4a6e1b..ba4be1c 100644
--- mlibc-clean/options/posix/meson.build
+++ mlibc-workdir/options/posix/meson.build
@@ -37,7 +37,7 @@ libc_sources += files(
 	'generic/sys-select-stubs.cpp',
 	'generic/sys-shm.cpp',
 	'generic/sys-socket-stubs.cpp',
-	'generic/sys-statfs-stubs.cpp',
+	#'generic/sys-statfs-stubs.cpp',
 	'generic/sys-stat-stubs.cpp',
 	'generic/sys-statvfs-stubs.cpp',
 	'generic/sys-times.cpp',
@@ -135,7 +135,7 @@ if not no_headers
 		'include/sys/sem.h',
 		'include/sys/shm.h',
 		'include/sys/socket.h',
-		'include/sys/statfs.h',
+		#'include/sys/statfs.h',
 		'include/sys/stat.h',
 		'include/sys/statvfs.h',
 		'include/sys/termios.h',
@@ -146,7 +146,7 @@ if not no_headers
 		'include/sys/uio.h',
 		'include/sys/un.h',
 		'include/sys/utsname.h',
-		'include/sys/vfs.h',
+		#'include/sys/vfs.h',
 		'include/sys/wait.h',
 		'include/sys/syslog.h',
 		subdir: 'sys'
diff --git mlibc-clean/options/rtdl/generic/linker.cpp mlibc-workdir/options/rtdl/generic/linker.cpp
index d6e9118..cdbf039 100644
--- mlibc-clean/options/rtdl/generic/linker.cpp
+++ mlibc-workdir/options/rtdl/generic/linker.cpp
@@ -514,18 +514,25 @@ void ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
 
 				void *map_pointer;
 				if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
-						total_map_size, prot | PROT_WRITE,
+						total_map_size, PROT_WRITE,
 						MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
 					__ensure(!"sys_vm_map failed");
 
 				seekOrDie(fd, phdr->p_offset);
 				readExactlyOrDie(fd, reinterpret_cast<char *>(map_address) + misalign,
 						phdr->p_filesz);
+
+				if (prot & PROT_EXEC) {
+				   prot = PROT_READ | PROT_EXEC;
+			   }
+				if (mlibc::sys_vm_protect (reinterpret_cast<void *>(map_address),
+				      total_map_size, prot))
+				   __ensure(!"vm_protect not feeling all there");
 			#endif
 			// Take care of removing superfluous permissions.
-			if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
-				if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
-					mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
+			//if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
+			//	if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
+			//		mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
 		}else if(phdr->p_type == PT_TLS) {
 			object->tlsSegmentSize = phdr->p_memsz;
 			object->tlsAlignment = phdr->p_align;
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index 7136150..bcc274b 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -15,6 +15,7 @@
 #include <sys/mman.h>
 #include <unistd.h>
 #include <sys/file.h>
+#include <mlibc/tcb.hpp>
 
 namespace mlibc {
 
@@ -44,6 +45,21 @@ int sys_tcb_set(void *pointer) {
 	return errno;
 }
 
+int sys_thread_getname(void *tcb, char *name, size_t size) {
+	int ret, errno;
+	auto t = reinterpret_cast<Tcb *>(tcb);
+	SYSCALL3(SYSCALL_GETTIDID, t->tid, name, size);
+	return errno;
+}
+
+int sys_thread_setname(void *tcb, const char *name) {
+	int ret, errno;
+	size_t len = strlen(name);
+	auto t = reinterpret_cast<Tcb *>(tcb);
+	SYSCALL3(SYSCALL_SETTIDID, t->tid, name, len);
+	return errno;
+}
+
 int sys_open(const char *path, int flags, mode_t mode, int *fd) {
 	return sys_openat(AT_FDCWD, path, flags, mode, fd);
 }
@@ -54,8 +70,8 @@ int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 	int path_len = strlen (path);
 	SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
 	if (ret != -1 && (flags & O_EXCL)) {
-		 SYSCALL1(SYSCALL_CLOSE, ret);
-		 return EEXIST;
+		SYSCALL1(SYSCALL_CLOSE, ret);
+		return EEXIST;
 	}
 
 	if (ret == -1 && (flags & O_CREAT)) {
@@ -63,7 +79,7 @@ int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 		 if (ret == -1) {
 			  return errno;
 		 }
-		 SYSCALL4(SYSCALL_OPEN,	AT_FDCWD, path, path_len, flags);
+		 SYSCALL4(SYSCALL_OPEN, AT_FDCWD, path, path_len, flags);
 	} else if (ret != -1 && (flags & O_TRUNC)) {
 		// If the file cannot be truncated, dont sweat it, some software
 		// depends on some things being truncate-able that ironclad does not
@@ -177,13 +193,14 @@ int sys_ftruncate (int fd, size_t size) {
 }
 
 int sys_flock(int fd, int options) {
+	//  XXX: Shouldnt this use F_SETLKW and F_SETLK only when LOCK_NB ?
 	struct flock lock;
 	lock.l_whence = SEEK_SET;
 	lock.l_start = 0;
 	lock.l_len = (off_t)((uint64_t)-1);
 	lock.l_pid = sys_getpid();
 
-	switch (options) {
+	switch (options & ~(LOCK_NB)) {
 		case LOCK_SH:
 			lock.l_type = F_RDLCK;
 			break;
@@ -202,6 +219,19 @@ int sys_flock(int fd, int options) {
 	return errno;
 }
 
+int sys_getpriority(int which, id_t who, int *value) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_GETPRIO, which, who);
+	*value = ret;
+	return errno;
+}
+
+int sys_setpriority(int which, id_t who, int value) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_SETPRIO, which, who, value);
+	return errno;
+}
+
 int sys_getrusage(int scope, struct rusage *usage) {
 	int ret, errno;
 	SYSCALL2(SYSCALL_GETRUSAGE, scope, usage);
@@ -231,65 +261,15 @@ int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offse
 }
 
 int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) {
-	(void)fd;
-	(void)size;
-	if (layer == SOL_SOCKET && number == SO_PEERCRED) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
-		*(int *)buffer = 4096;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_TYPE) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
-		*(int *)buffer = SOCK_STREAM;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_ERROR) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else {
-		mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
-	}
-
-	return 0;
+	int ret, errno;
+	SYSCALL5(SYSCALL_GETSOCKOPT, fd, layer, number, buffer, size);
+	return errno;
 }
 
 int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) {
-	(void)fd;
-	(void)buffer;
-	(void)size;
-	if (layer == SOL_SOCKET && number == SO_PASSCRED) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_REUSEADDR) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == AF_NETLINK && number == SO_ACCEPTCONN) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
-		return 0;
-	} else {
-		mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
-	}
-
-	 return 0;
+	int ret, errno;
+	SYSCALL5(SYSCALL_SETSOCKOPT, fd, layer, number, buffer, size);
+	return errno;
 }
 
 int sys_vm_unmap(void *pointer, size_t size) {
@@ -303,6 +283,12 @@ int sys_vm_unmap(void *pointer, size_t size) {
 	}
 }
 
+int sys_getcwd(char *buf, size_t size) {
+	buf[0] = '/';
+	buf[1] = '\0';
+	return 0;
+}
+
 int sys_vm_protect(void *pointer, size_t size, int prot) {
 	int ret;
 	int errno;
@@ -313,6 +299,11 @@ int sys_vm_protect(void *pointer, size_t size, int prot) {
 	return 0;
 }
 
+int sys_getsid(pid_t pid, pid_t *sid) {
+	//  STUB.
+	return 0;
+}
+
 pid_t sys_getpid() {
 	pid_t ret;
 	int errno;
@@ -327,6 +318,19 @@ pid_t sys_getppid() {
 	return ret;
 }
 
+int sys_getgroups(size_t size, const gid_t *list, int *retval) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_GETGROUPS, size, list);
+	*retval = ret;
+	return errno;
+}
+
+int sys_setgroups(size_t size, const gid_t *list) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_SETGROUPS, size, list);
+	return errno;
+}
+
 int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
 	return 0;
 }
@@ -358,16 +362,6 @@ int sys_isatty(int fd) {
 	}
 }
 
-gid_t sys_getgid() {
-	// FIXME: Stub needed by mlibc.
-	return 0;
-}
-
-gid_t sys_getegid() {
-	// FIXME: Stub needed by mlibc.
-	return 0;
-}
-
 int sys_getpgid(pid_t pid, pid_t *pgid) {
 	(void)pid;
 	// FIXME: Stub needed by mlibc.
@@ -457,12 +451,13 @@ int sys_uname(struct utsname *buf) {
 int sys_setpgid(pid_t pid, pid_t pgid) {
 	(void)pid;
 	(void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
 	return 0;
 }
 
-int sys_ttyname(int, char *, size_t) {
-	return ENOSYS;
+int sys_ttyname(int fd, char *buff, size_t size) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_TTYNAME, fd, buff, size);
+	return errno;
 }
 
 int sys_sethostname(const char *buff, size_t size) {
@@ -510,6 +505,13 @@ int sys_fchdir(int fd) {
 int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
 	int ret, errno;
 
+	if (request == TIOCGPGRP) {
+		*result = 0;
+		return 0;
+	} else if (request == TIOCSPGRP) {
+		return 0;
+	}
+
 	SYSCALL3(SYSCALL_IOCTL, fd, request, arg);
 
 	if (ret == -1) {
@@ -548,11 +550,12 @@ int sys_dup(int fd, int flags, int *newfd) {
 }
 
 int sys_dup2(int fd, int flags, int newfd) {
-	if (sys_close(newfd) != 0) {
-		 return EBADFD;
+	int ret = sys_close(newfd);
+	if (ret != 0 && ret != EBADFD) {
+		return EBADFD;
 	}
 
-	int ret, errno;
+	int errno;
 	if (flags & O_CLOEXEC) {
 		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
 	} else {
@@ -708,11 +711,7 @@ uid_t sys_geteuid() {
 
 int sys_setuid(uid_t uid) {
 	int ret, errno;
-	if (uid == 0) {
-		 SYSCALL2(SYSCALL_SETUIDS, uid, uid);
-	} else {
-		 SYSCALL2(SYSCALL_SETUIDS, uid, ((uint64_t)-1));
-	}
+	SYSCALL2(SYSCALL_SETUIDS, uid, uid);
 	return ret;
 }
 
@@ -722,6 +721,44 @@ int sys_seteuid(uid_t euid) {
 	return ret;
 }
 
+int sys_setreuid(uid_t ruid, uid_t euid) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_SETUIDS, ruid, euid);
+	return ret;
+}
+
+gid_t sys_getgid() {
+	uint64_t ret, errno;
+	SYSCALL0(SYSCALL_GETGID);
+	return (gid_t)ret;
+}
+
+gid_t sys_getegid() {
+	return sys_getgid();
+}
+
+int sys_setgid(gid_t gid) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_SETGIDS, gid, gid);
+	return ret;
+}
+
+int sys_setegid(gid_t egid) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_SETGIDS, ((uint64_t)-1), egid);
+	return ret;
+}
+
+int sys_setregid(gid_t rgid, gid_t egid) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_SETGIDS, rgid, egid);
+	return ret;
+}
+
+int sys_setsid(pid_t *sid) {
+	 return 0;
+}
+
 #ifndef MLIBC_BUILDING_RTDL
 
 extern "C" void __mlibc_thread_entry();
@@ -835,10 +872,13 @@ int sys_shutdown(int sockfd, int how) {
 	return errno;
 }
 
+int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value) {
+	 return ENOSYS;
+}
+
 int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
 	if (hdr->msg_control != NULL) {
-		mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
-		return EINVAL;
+		// mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
 	}
 
 	int ret;
@@ -860,8 +900,7 @@ int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
 
 int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
 	if (hdr->msg_control != NULL) {
-		mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
-		return EINVAL;
+		// mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
 	}
 
 	int ret;
@@ -904,7 +943,7 @@ int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
 	struct timespec ts;
 	ts.tv_sec = timeout / 1000;
 	ts.tv_nsec = (timeout % 1000) * 1000000;
-	return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
+	return sys_ppoll(fds, count, timeout == -1 ? NULL : &ts, NULL, num_events);
 }
 
 int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
@@ -1025,27 +1064,7 @@ int sys_utimensat(int dirfd, const char *pathname, const struct timespec times[2
 
 int sys_sysconf(int num, long *rret) {
 	long ret, errno;
-
-	// Translate the number for the POSIX compat of the sysconf.
-	int translated;
-	switch (num) {
-		case _SC_PAGE_SIZE:		  translated = 1;  break;
-		case _SC_OPEN_MAX:			translated = 2;  break;
-		case _SC_HOST_NAME_MAX:	 translated = 3;  break;
-		case _SC_NPROCESSORS_ONLN: translated = 6;  break;
-		case _SC_PHYS_PAGES:		 translated = 7;  break;
-		case _SC_CHILD_MAX:		  translated = 11; break;
-
-		// These are values that mlibc technically has to provide itself, but
-		// I personally dont like how ugly the hardcoded warnings look, so I just
-		// harcode them myself :)
-		case _SC_LINE_MAX: *rret = 4096; return 0;
-
-		// Default is for mlibc to handle it.
-		default: return EINVAL;
-	}
-
-	SYSCALL3(SYSCALL_SYSCONF, translated, 0, 0);
+	SYSCALL3(SYSCALL_SYSCONF, num, 0, 0);
 	*rret = ret;
 	return errno;
 }
@@ -1126,6 +1145,12 @@ int sys_umask(mode_t mode, mode_t *old) {
 	return errno;
 }
 
+int sys_fadvise(int fd, off_t offset, off_t length, int advice) {
+	int ret, errno;
+	SYSCALL4(SYSCALL_FADVISE, fd, offset, length, advice);
+	return errno;
+}
+
 int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) {
 	ssize_t ret;
 	int errno;
@@ -1165,5 +1190,66 @@ int sys_mknodat(int dirfd, const char *path, mode_t mode, dev_t dev) {
 	return errno;
 }
 
+#define SC_LIST_MOUNTS 9
+struct mountinfo {
+	 uint32_t type;
+	 uint32_t flags;
+	 char source[20];
+	 uint32_t source_length;
+	 char location[20];
+	 uint32_t location_length;
+	 uint64_t block_size;
+	 uint64_t fragment_size;
+	 uint64_t size_in_fragments;
+	 uint64_t free_blocks;
+	 uint64_t free_blocks_user;
+	 uint64_t inode_count;
+	 uint64_t free_inodes;
+	 uint64_t free_inodes_user;
+	 uint64_t max_filename;
+};
+
+#include <sys/mount.h>
+
+int sys_fstatvfs(int fd, struct statvfs *out) {
+	return sys_statvfs("/", out);
+}
+
+int sys_statvfs(const char *path, struct statvfs *out) {
+	long ret, errno;
+	struct mountinfo *buffer = (mountinfo *)malloc(5 * sizeof(struct mountinfo));
+	SYSCALL3(SYSCALL_SYSCONF, SC_LIST_MOUNTS, buffer, 5 * sizeof(struct mountinfo));
+	if (errno) {
+		free(buffer);
+		return errno;
+	} else if (ret > 5) {
+		free(buffer);
+		return 1;
+	}
+
+	for (int i = 0; i < ret; i++) {
+		if (!strncmp(path, buffer[i].location, buffer[i].location_length)) {
+			out->f_bsize  = buffer[i].block_size;
+			out->f_frsize = buffer[i].fragment_size;
+			out->f_blocks = buffer[i].size_in_fragments;
+			out->f_bfree  = buffer[i].free_blocks;
+			out->f_bavail = buffer[i].free_blocks_user;
+			out->f_files  = buffer[i].inode_count;
+			out->f_ffree  = buffer[i].free_inodes;
+			out->f_favail = buffer[i].free_inodes_user;
+			out->f_fsid = 0;
+			out->f_flag = buffer[i].flags;
+			out->f_namemax = buffer[i].max_filename;
+			if (buffer[i].type == MNT_EXT) {
+				strcpy(out->f_basetype, "ext");
+			} else {
+				strcpy(out->f_basetype, "fat");
+			}
+			return 0;
+		}
+	}
+
+	return EINVAL;
+}
 #endif
 } // namespace mlibc
diff --git mlibc-clean/sysdeps/ironclad/generic/mount.cpp mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
index ff060e0..227bac0 100644
--- mlibc-clean/sysdeps/ironclad/generic/mount.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
@@ -4,31 +4,17 @@
 #include <sys/syscall.h>
 #include <string.h>
 
-int mount(const char *source, const char *target,
-		const char *fstype, unsigned long flags, const void *data) {
-	int ret, errno;
-	size_t source_len = strlen(source);
-	size_t target_len = strlen(target);
-	int val;
-	if (!strcmp(fstype, "ext")) {
-		val = 1;
-	} else if (!strcmp(fstype, "fat32")) {
-		val = 2;
-	} else {
-		return EINVAL;
-	}
-
-	SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, val, flags);
-	return errno;
-}
-
-int umount(const char *target) {
-	return umount2(target, 0);
+int mount(const char *source, const char *target, int type, int flags) {
+   int ret;
+   size_t source_len = strlen(source);
+   size_t target_len = strlen(target);
+   SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, type, flags);
+   return ret;
 }
 
-int umount2(const char *target, int flags) {
-	int ret, errno;
-	size_t target_len = strlen(target);
-	SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
-	return errno;
+int umount(const char *target, int flags) {
+   int ret;
+   size_t target_len = strlen(target);
+   SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
+   return ret;
 }
diff --git mlibc-clean/sysdeps/ironclad/generic/pty.cpp mlibc-workdir/sysdeps/ironclad/generic/pty.cpp
index 7434dae..1626e4b 100644
--- mlibc-clean/sysdeps/ironclad/generic/pty.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/pty.cpp
@@ -7,12 +7,35 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/syscall.h>
+#include <sys/ioctl.h>
 
 int openpty(int *mfd, int *sfd, char *name, const struct termios *ios, const struct winsize *win) {
-	int errno, ret;
+	int ret;
 	int fds[2];
-	SYSCALL3(SYSCALL_OPENPTY, fds, ios, win);
+	SYSCALL1(SYSCALL_OPENPTY, fds);
+	if (errno) {
+		return -1;
+	}
 	*mfd = fds[0];
 	*sfd = fds[1];
+
+	if (name != NULL) {
+		ret = ttyname_r(*mfd, name, (size_t)-1);
+		if (ret) {
+			return -1;
+		}
+	}
+	if (ios != NULL) {
+		ret = tcsetattr(*mfd, TCSANOW, ios);
+		if (ret) {
+			return -1;
+		}
+	}
+	if (win != NULL) {
+		ret = ioctl(*mfd, TIOCGWINSZ, win);
+		if (ret) {
+			return -1;
+		}
+	}
 	return ret;
 }
diff --git mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp
new file mode 100644
index 0000000..ec74e22
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp
@@ -0,0 +1,76 @@
+#include <bits/ensure.h>
+#include <stddef.h>
+#include <errno.h>
+#include <utmpx.h>
+#include <stdio.h>
+#include <time.h>
+#include <paths.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+int utmpx_file = -1;
+
+void updwtmpx(const char *, const struct utmpx *) {
+	// Empty as musl does
+}
+
+void endutxent(void) {
+	if (utmpx_file >= 0) {
+		close(utmpx_file);
+	}
+}
+
+void setutxent(void) {
+	if (utmpx_file < 0) {
+		utmpx_file = open(UTMPX_FILE, O_RDWR | O_CREAT, 0755);
+	} else {
+		lseek(utmpx_file, 0, SEEK_SET);
+	}
+}
+
+struct utmpx returned;
+
+struct utmpx *getutxent(void) {
+	if (utmpx_file < 0) {
+		setutxent();
+		if (utmpx_file < 0) {
+			return NULL;
+		}
+	}
+
+	if (read(utmpx_file, &returned, sizeof(struct utmpx)) != sizeof(struct utmpx)) {
+		return NULL;
+	}
+
+	return &returned;
+}
+
+struct utmpx *pututxline(const struct utmpx *added) {
+	if (utmpx_file < 0) {
+		setutxent();
+		if (utmpx_file < 0) {
+			return NULL;
+		}
+	}
+
+	lseek(utmpx_file, 0, SEEK_END);
+	if (write(utmpx_file, added, sizeof(struct utmpx)) != sizeof(struct utmpx)) {
+		return NULL;
+	}
+
+	return (struct utmpx *)added;
+}
+
+int utmpxname(const char *path) {
+	if (utmpx_file > 0) {
+		close(utmpx_file);
+	}
+
+	utmpx_file = open(path, O_RDWR | O_CREAT, 0755);
+	if (utmpx_file > 0) {
+		lseek(utmpx_file, 0, SEEK_END);
+		return 1;
+	} else {
+		return 0;
+	}
+}
diff --git mlibc-clean/sysdeps/ironclad/include/sys/mount.h mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
index 71ae64d..51263fa 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/mount.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
@@ -5,12 +5,17 @@
 extern "C" {
 #endif
 
+#define MNT_EXT 1
+#define MNT_FAT 2
+
+#define MS_RDONLY   0b001
+#define MS_REMOUNT  0b010
+#define MS_RELATIME 0b100
+
 #define MNT_FORCE 1
 
-int mount(const char *source, const char *target,
-		const char *fstype, unsigned long flags, const void *data);
-int umount(const char *target);
-int umount2(const char *target, int flags);
+int mount(const char *source, const char *target, int type, int flags);
+int umount(const char *target, int flags);
 
 #ifdef __cplusplus
 }
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index b0227d5..59c8cb3 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -84,87 +84,104 @@
 				  : "rcx", "r11", "memory"); \
 })
 
-#define SYSCALL_EXIT                  0
-#define SYSCALL_ARCH_PRCTL            1
-#define SYSCALL_OPEN                  2
-#define SYSCALL_CLOSE                 3
-#define SYSCALL_READ                  4
-#define SYSCALL_WRITE                 5
-#define SYSCALL_SEEK                  6
-#define SYSCALL_MMAP                  7
-#define SYSCALL_MUNMAP                8
-#define SYSCALL_GETPID                9
-#define SYSCALL_GETPPID              10
-#define SYSCALL_EXEC                 11
-#define SYSCALL_CLONE                12
-#define SYSCALL_WAIT                 13
-#define SYSCALL_SOCKET               14
-#define SYSCALL_SETHOSTNAME          15
-#define SYSCALL_UNLINK               16
-#define SYSCALL_STAT                 17
-#define SYSCALL_GETCWD               18
-#define SYSCALL_CHDIR                19
-#define SYSCALL_IOCTL                20
-#define SYSCALL_SCHED_YIELD          21
-#define SYSCALL_DELETE_TCLUSTER      22
-#define SYSCALL_PIPE                 23
-#define SYSCALL_GETUID               24
-#define SYSCALL_RENAME               25
-#define SYSCALL_SYSCONF              26
-#define SYSCALL_SPAWN                27
-#define SYSCALL_GETTID               28
-#define SYSCALL_MANAGE_TCLUSTER      29
-#define SYSCALL_FCNTL                30
-#define SYSCALL_EXIT_THREAD          31
-#define SYSCALL_GETRANDOM            32
-#define SYSCALL_MPROTECT             33
-#define SYSCALL_SYNC                 34
+#define SYSCALL_EXIT					 0
+#define SYSCALL_ARCH_PRCTL			 1
+#define SYSCALL_OPEN					 2
+#define SYSCALL_CLOSE					  3
+#define SYSCALL_READ					 4
+#define SYSCALL_WRITE					  5
+#define SYSCALL_SEEK					 6
+#define SYSCALL_MMAP					 7
+#define SYSCALL_MUNMAP					8
+#define SYSCALL_GETPID					9
+#define SYSCALL_GETPPID				10
+#define SYSCALL_EXEC					11
+#define SYSCALL_CLONE					 12
+#define SYSCALL_WAIT					13
+#define SYSCALL_SOCKET				  14
+#define SYSCALL_SETHOSTNAME			 15
+#define SYSCALL_UNLINK				  16
+#define SYSCALL_STAT					17
+#define SYSCALL_GETCWD				  18
+#define SYSCALL_CHDIR					 19
+#define SYSCALL_IOCTL					 20
+#define SYSCALL_SCHED_YIELD			 21
+#define SYSCALL_DELETE_TCLUSTER	  22
+#define SYSCALL_PIPE					23
+#define SYSCALL_GETUID				  24
+#define SYSCALL_RENAME				  25
+#define SYSCALL_SYSCONF				26
+#define SYSCALL_SPAWN					 27
+#define SYSCALL_GETTID				  28
+#define SYSCALL_MANAGE_TCLUSTER	  29
+#define SYSCALL_FCNTL					 30
+#define SYSCALL_EXIT_THREAD			 31
+#define SYSCALL_GETRANDOM			  32
+#define SYSCALL_MPROTECT				 33
+#define SYSCALL_SYNC					34
 #define SYSCALL_SET_MAC_CAPABILITIES 35
 #define SYSCALL_GET_MAC_CAPABILITIES 36
 #define SYSCALL_ADD_MAC_PERMISSIONS  37
 #define SYSCALL_SET_MAC_ENFORCEMENT  38
-#define SYSCALL_MOUNT                39
-#define SYSCALL_UMOUNT               40
-#define SYSCALL_READLINK             41
-#define SYSCALL_GETDENTS             42
-#define SYSCALL_MAKENODE             43
-#define SYSCALL_TRUNCATE             44
-#define SYSCALL_BIND                 45
-#define SYSCALL_SYMLINK              46
-#define SYSCALL_CONNECT              47
-#define SYSCALL_OPENPTY              48
-#define SYSCALL_FSYNC                49
-#define SYSCALL_LINK                 50
-#define SYSCALL_PTRACE               51
-#define SYSCALL_LISTEN               52
-#define SYSCALL_ACCEPT               53
-#define SYSCALL_GETRLIMIT            54
-#define SYSCALL_SETRLIMIT            55
-#define SYSCALL_ACCESS               56
-#define SYSCALL_POLL                 57
-#define SYSCALL_GETEUID              58
-#define SYSCALL_SETUIDS              59
-#define SYSCALL_FCHMOD               60
-#define SYSCALL_UMASK                61
-#define SYSCALL_REBOOT               62
-#define SYSCALL_FCHOWN               63
-#define SYSCALL_PREAD                64
-#define SYSCALL_PWRITE               65
-#define SYSCALL_GETSOCKNAME          66
-#define SYSCALL_GETPEERNAME          67
-#define SYSCALL_SHUTDOWN             68
-#define SYSCALL_FUTEX                69
-#define SYSCALL_CLOCK                70
-#define SYSCALL_CLOCK_NANOSLEEP      71
-#define SYSCALL_GETRUSAGE            72
-#define SYSCALL_RECVFROM             73
-#define SYSCALL_SENDTO               74
-#define SYSCALL_CONFIG_NETINTER      75
-#define SYSCALL_UTIMES               76
-#define SYSCALL_CREATE_TCLUSTER      77
-#define SYSCALL_SWITCH_TCLUSTER      78
-#define SYSCALL_ACTUALLY_KILL        79
-#define SYSCALL_SIGNALPOST           80
-#define SYSCALL_SEND_SIGNAL          81
+#define SYSCALL_MOUNT					 39
+#define SYSCALL_UMOUNT				  40
+#define SYSCALL_READLINK				 41
+#define SYSCALL_GETDENTS				 42
+#define SYSCALL_MAKENODE				 43
+#define SYSCALL_TRUNCATE				 44
+#define SYSCALL_BIND					45
+#define SYSCALL_SYMLINK				46
+#define SYSCALL_CONNECT				47
+#define SYSCALL_OPENPTY				48
+#define SYSCALL_FSYNC					 49
+#define SYSCALL_LINK					50
+#define SYSCALL_PTRACE				  51
+#define SYSCALL_LISTEN				  52
+#define SYSCALL_ACCEPT				  53
+#define SYSCALL_GETRLIMIT			  54
+#define SYSCALL_SETRLIMIT			  55
+#define SYSCALL_ACCESS				  56
+#define SYSCALL_POLL					57
+#define SYSCALL_GETEUID				58
+#define SYSCALL_SETUIDS				59
+#define SYSCALL_FCHMOD				  60
+#define SYSCALL_UMASK					 61
+#define SYSCALL_REBOOT				  62
+#define SYSCALL_FCHOWN				  63
+#define SYSCALL_PREAD					 64
+#define SYSCALL_PWRITE				  65
+#define SYSCALL_GETSOCKNAME			 66
+#define SYSCALL_GETPEERNAME			 67
+#define SYSCALL_SHUTDOWN				 68
+#define SYSCALL_FUTEX					 69
+#define SYSCALL_CLOCK					 70
+#define SYSCALL_CLOCK_NANOSLEEP	  71
+#define SYSCALL_GETRUSAGE			  72
+#define SYSCALL_RECVFROM				 73
+#define SYSCALL_SENDTO				  74
+#define SYSCALL_CONFIG_NETINTER	  75
+#define SYSCALL_UTIMES				  76
+#define SYSCALL_CREATE_TCLUSTER	  77
+#define SYSCALL_SWITCH_TCLUSTER	  78
+#define SYSCALL_ACTUALLY_KILL		79
+#define SYSCALL_SIGNALPOST			80
+#define SYSCALL_SEND_SIGNAL			 81
+#define SYSCALL_GETPRIO				82
+#define SYSCALL_SETPRIO				83
+#define SYSCALL_GETGID				  84
+#define SYSCALL_GETEGID				85
+#define SYSCALL_SETGIDS				86
+#define SYSCALL_GETGROUPS			  87
+#define SYSCALL_SETGROUPS			  88
+#define SYSCALL_TTYNAME				 89
+#define SYSCALL_FADVISE				 90
+#define SYSCALL_SHMAT				 91
+#define SYSCALL_SHMCTL				 92
+#define SYSCALL_SHMDT				 93
+#define SYSCALL_SHMGET				 94
+#define SYSCALL_GETSOCKOPT			95
+#define SYSCALL_SETSOCKOPT			96
+#define SYSCALL_GETTIDID			  97
+#define SYSCALL_SETTIDID			  98
 
 #endif // _SYS_SYSCALL_H
diff --git mlibc-workdir/sysdeps/ironclad/include/utmpx.h mlibc-workdir/sysdeps/ironclad/include/utmpx.h
new file mode 100644
index 0000000..2d7d3e1
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/utmpx.h
@@ -0,0 +1,63 @@
+
+#ifndef  _UTMPX_H
+#define  _UTMPX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <abi-bits/pid_t.h>
+#include <bits/posix/timeval.h>
+
+#define UTMPX_FILE "/var/run/utmp"
+#define WTMPX_FILE "/var/run/wtmp"
+
+// Struct definition taken from musl
+struct utmpx {
+	short ut_type;
+	short __ut_pad1;
+	pid_t ut_pid;
+	char ut_line[32];
+	char ut_id[4];
+	char ut_user[32];
+	char ut_host[256];
+	struct {
+		short __e_termination;
+		short __e_exit;
+	} ut_exit;
+	int ut_session, __ut_pad2;
+	struct timeval ut_tv;
+	unsigned ut_addr_v6[4];
+	char __unused[20];
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+void updwtmpx(const char *, const struct utmpx *);
+int utmpxname(const char *);
+struct utmpx *pututxline(const struct utmpx *);
+struct utmpx *getutxent(void);
+void setutxent(void);
+void endutxent(void);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#define EMPTY           0
+#define RUN_LVL         1
+#define BOOT_TIME       2
+#define NEW_TIME        3
+#define OLD_TIME        4
+#define INIT_PROCESS    5
+#define LOGIN_PROCESS   6
+#define USER_PROCESS    7
+#define DEAD_PROCESS    8
+
+#define __UT_HOSTSIZE 256
+#define __UT_NAMESIZE 32
+#define __UT_LINESIZE 32
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _UTMPX_H
diff --git mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
index d12e2e1..b713b0d 100644
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -14,7 +14,8 @@ libc_sources += files(
 	'generic/thread.cpp',
 	'generic/mac.cpp',
 	'generic/sched2.cpp',
-	'generic/thread.S'
+	'generic/thread.S',
+	'generic/utmpx.cpp'
 )
 
 if not no_headers
@@ -87,7 +88,8 @@ if not no_headers
 
 	install_headers(
 		'include/mntent.h',
-		'include/pty.h'
+		'include/pty.h',
+		'include/utmpx.h'
 	)
 endif
 
