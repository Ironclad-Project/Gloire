#! /bin/sh

# Copyright (C) 2022-2025 mintsuki

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

set -e

IFS=" ""	"'
'

LC_COLLATE=C
export LC_COLLATE

umask 0022

jinx_major_ver="0.8"
jinx_minor_ver="1"

jinx_version="${jinx_major_ver}.${jinx_minor_ver}"

XBPS_VERSION=213c8290ceca38264d2907d6d01f91775951bd14
XBPS_SHA256SUM=6c4420c86212be203cdbc061ab2e53255f6407e15b7aee307eac2a8f370eb3c4

debootstrap_version=1.0.141
debootstrap_sha256sum=1066dd75b337156cdc4ebace2ad38f68fdff56fb8b7d20a1a4eb9739afe55c12

die() {
    echo "$1" 1>&2
    exit 1
}

if [ -z "$1" ]; then
    die "$0: no command specified."
fi

cmd_help() {
    echo "usage: $0 <command> <package(s)>"
    printf "\n   help|--help        Displays this message"
    printf "\n   version|--version  Prints the version"
    printf "\n   init               Initialises a build directory"
    printf "\n   build              Builds package(s), does incremental builds"
    printf "\n   update             Update package(s) and their dependencies if necessary"
    printf "\n   rebuild            Rebuilds package(s)"
    printf "\n   host-build         Same as build, but for host package(s)"
    printf "\n   host-rebuild       Same as rebuild, but for host package(s)"
    printf "\n   regenerate|regen   Regenerates patch for package(s) and re-runs prepare step"
    printf "\n   install            Installs package(s)"
    printf "\n   reinstall          Reinstalls package(s)"
    printf "\n   dry-run            Prints all packages that need to be built in order (space separated)"
    printf "\n   rebuild-cache      Rebuilds Jinx cache"
    printf "\n\nexample: $0 update '*'\n"
}

cmd_init() {
    if ! [ -f "$1"/Jinxfile ]; then
        die "$0: Provided source directory contains no Jinxfile"
    fi

    srcdir="$1"

    if [ -f ".jinx-parameters" ]; then
        die "$0: Current directory already initialised, run '$0 deinit' first"
    fi

    if [ -f "Jinxfile" ]; then
        die "$0: In-tree builds are not supported"
    fi

    cat <<EOF >.jinx-parameters
#! /bin/sh

JINX_SOURCE_DIR="${srcdir}"
JINX_ARCH="$(uname -m)"
EOF

    shift 1

    for p in "$@"; do
        echo "JINX_$p" | sed 's/=/="/g;s/$/"/g' >>.jinx-parameters
    done

    echo "Initialised with '${srcdir}' as source directory"
}

case "$1" in
    version|--version)
        echo "Jinx version $jinx_version"
        exit 0
        ;;
    help|--help)
        cmd_help
        exit 0
        ;;
    init)
        shift 1
        cmd_init "$@"
        exit 0
        ;;
esac

if ! [ "$(uname -s)" = "Linux" ]; then
    die "$0: Jinx only supports running on Linux hosts."
fi

script_name="$(basename "$0")"
script_dir="$(dirname "$0")"
if [ "$script_dir" = "." ] || [ -z "$script_dir" ]; then
    if echo "$0" | grep "/" >/dev/null 2>&1; then
        script_dir=.
    else
        script_dir="$(dirname $(which "${script_name}"))"
    fi
fi
script_dir="$(cd "${script_dir}" && pwd -P)"
script="${script_dir}/${script_name}"

in_container=false
if [ "$script" = "//jinx" ]; then
    in_container=true
fi

case "$1" in
    install)
        ;;
    *)
        if [ "${in_container}" = "false" ] && [ "$(id -u)" = "0" ]; then
            die "$0: Jinx does not support running as root."
        fi
        ;;
esac

if [ -z "$JINX_PARALLELISM" ]; then
    max_threads_by_mem="$(( ((($(free | awk '/^Mem:/{print $2}') + 1048575) / 1048576) + 1) / 2 ))"
    parallelism="$(nproc 2>/dev/null || echo 1)"
    parallelism="$(( $parallelism < $max_threads_by_mem ? $parallelism : $max_threads_by_mem ))"
else
    parallelism="$JINX_PARALLELISM"
fi

if [ "$in_container" = "false" ]; then
    build_dir="$(pwd -P)"
else
    build_dir=/build_dir
fi

if ! [ -f "${build_dir}"/.jinx-parameters ]; then
    die "$0: Please run '$0 init <source dir> <parameters>' first"
fi

. "${build_dir}"/.jinx-parameters

if [ "$in_container" = "false" ]; then
    base_dir="$(cd "$JINX_SOURCE_DIR" && pwd -P)"
else
    base_dir=/base_dir
fi

JINX_CONFIG_FILE="${base_dir}/Jinxfile"

if ! [ -d "$(dirname "$JINX_CONFIG_FILE")" ]; then
    die "$0: cannot access Jinxfile directory"
fi
JINX_CONFIG_FILE="$(cd "$(dirname "$JINX_CONFIG_FILE")" && pwd -P)"/"$(basename "$JINX_CONFIG_FILE")"

if [ -z "$JINX_CACHE_DIR" ]; then
    JINX_CACHE_DIR="${base_dir}/.jinx-cache"
fi
if ! [ -d "$(dirname "$JINX_CACHE_DIR")" ]; then
    die "$0: cannot access cache directory parent"
fi

if [ "$in_container" = "false" ]; then
    mkdir -p "$JINX_CACHE_DIR"
    JINX_CACHE_DIR="$(cd "$JINX_CACHE_DIR" && pwd -P)"

    export PATH="${JINX_CACHE_DIR}/xbps/bin:${JINX_CACHE_DIR}/debootstrap/usr/sbin:${PATH}:/usr/sbin:/sbin"
    if ! [ -z "${LD_LIBRARY_PATH}" ]; then
        LD_LIBRARY_PATH=":${LD_LIBRARY_PATH}"
    fi
    export LD_LIBRARY_PATH="${JINX_CACHE_DIR}/xbps/lib${LD_LIBRARY_PATH}"

    mkdir -p "${base_dir}/sources" "${build_dir}/host-builds" "${build_dir}/host-pkgs" "${build_dir}/builds" "${build_dir}/pkgs"
fi

apt_cache="$JINX_CACHE_DIR/apt-cache"

temp_collect=""

cleanup_done=no
cleanup() {
    if [ "${cleanup_done}" = "yes" ]; then
        return
    fi
    cleanup_done=yes
    eval "rm -rf ${temp_collect}"
}

trap 'tmp_ret=$?; set +e; cleanup; trap - EXIT; exit ${tmp_ret}' INT TERM HUP QUIT
trap 'tmp_ret=$?; set +e; cleanup; trap - EXIT; exit ${tmp_ret}' EXIT

make_temp() {
    tmp="$(mktemp $1 "$JINX_CACHE_DIR/tmp/tmp.XXXXXXXX")"
    temp_collect="${temp_collect} \"${tmp}\""
}

tracked_subshell() {
    (
        temp_collect=""
        cleanup_done=no
        trap 'tmp_ret=$?; set +e; cleanup; trap - EXIT; exit ${tmp_ret}' INT TERM HUP QUIT
        trap 'tmp_ret=$?; set +e; cleanup; trap - EXIT; exit ${tmp_ret}' EXIT
        set -e
        eval "$1"
    )
    retval=$?
    if ! [ ${retval} = 0 ]; then
        exit ${retval}
    fi
}

include_recipe() {
    unset cross_compile
    unset name
    unset version
    unset revision
    unset from_source
    unset deps
    unset builddeps
    unset hostdeps
    unset hostrundeps
    unset imagedeps
    unset allow_network
    unset source_deps
    unset source_hostdeps
    unset source_imagedeps
    unset source_allow_network
    unset clean_workdirs
    unset bootstrap_pkg
    unset from_source
    unset source_dir
    unset git_url
    unset commit
    unset shallow
    unset tarball_url
    unset tarball_sha256
    unset tarball_sha512
    unset tarball_blake2b

    early_prepare() {
        :
    }

    prepare() {
        :
    }

    configure() {
        :
    }

    build() {
        :
    }

    package() {
        :
    }

    if ! [ -f "$1" ]; then
        die "$0: recipe '$1' not found"
    fi

    . "$1"
}

build_hostdeps() {
    for hostdep in ${hostdeps} ${hostrundeps}; do
        [ -f "${base_dir}"/host-recipes/${hostdep} ] || die "missing host dependency '${hostdep}' for recipe '${name}'"

        tracked_subshell '
            do_host_build_if_needed ${hostdep}
        '
    done
}

build_deps() {
    for dep in ${deps} ${builddeps}; do
        [ -f "${base_dir}"/recipes/${dep} ] || die "missing dependency '${dep}' for recipe '${name}'"

        tracked_subshell '
            do_update ${dep}
        '
    done
}

get_hostdeps_file_run() {
    deps_to_do=""

    for hostdep in ${hostrundeps}; do
        if ! grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1; then
            deps_to_do="${deps_to_do} ${hostdep}"
            new_hostdeps_file=" ${hostdep} $(cat "${hostdeps_file}") "
            echo "${new_hostdeps_file}" >"${hostdeps_file}"
        fi
    done

    for hostdep in ${deps_to_do}; do
        tracked_subshell '
            include_recipe "${base_dir}"/host-recipes/${hostdep}
            get_hostdeps_file
        '
    done
}

get_hostdeps_file() {
    deps_to_do=""

    for hostdep in ${hostdeps} ${hostrundeps}; do
        if ! grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1; then
            deps_to_do="${deps_to_do} ${hostdep}"
            new_hostdeps_file=" ${hostdep} $(cat "${hostdeps_file}") "
            echo "${new_hostdeps_file}" >"${hostdeps_file}"
        fi
    done

    for hostdep in ${deps_to_do}; do
        tracked_subshell '
            include_recipe "${base_dir}"/host-recipes/${hostdep}
            get_hostdeps_file
        '
    done
}

topo_sort_visit() {
    case " $_global_visited " in
        *" $1 "*) return ;;
    esac
    _global_visited="$_global_visited $1"

    _deps=$(awk -F: -v node="$1" '$1 == node {print $2; exit}' "$_global_graph")
    for _dep in $_deps; do
        [ -n "$_dep" ] && topo_sort_visit "$_dep"
    done

    _global_result="$_global_result$1
"
}

topo_sort() {
    make_temp
    _global_graph="${tmp}"
    _global_visited=" "
    _global_result=""

    printf '%s\n' "$1" > "$_global_graph"

    awk -F: '{print $1}' "$_global_graph" | sort -u | {
        while read _node; do
            topo_sort_visit "$_node"
        done
        printf '%s' "$_global_result" | tr '\n' ' ' | sed 's/ $/\n/'
    }
}

get_builddeps() {
    pkg="$1"

    include_recipe "${base_dir}/recipes/${pkg}"

    make_temp
    deps_file="${tmp}"

    get_builddeps_file

    graph="${pkg}:${deps}"
    if ! [ -z "${builddeps}" ]; then
        graph=$(echo "${graph} ${builddeps}" | sed 's/: /:/g')
    fi

    for dep in $(cat "${deps_file}"); do
        if ! [ -f "${base_dir}/recipes/${dep}" ]; then
            die "$0: dependency '${dep}' for recipe '${pkg}' not found"
        fi

        graph="${graph}
${dep}:$(include_recipe "${base_dir}/recipes/${dep}" && echo ${deps})"
    done

    topo_sort "${graph}"
}

get_hostdeps_builddeps() {
    # Similar to get_builddeps, but for host recipes.
    # Builds a topological ordering of host recipe dependencies.
    hostpkg="$1"

    include_recipe "${base_dir}/host-recipes/${hostpkg}"

    make_temp
    hostdeps_file="${tmp}"

    get_hostdeps_file_for_topo

    graph="${hostpkg}:${hostdeps} ${hostrundeps}"
    if ! [ -z "${hostdeps}" ] || ! [ -z "${hostrundeps}" ]; then
        graph=$(echo "${graph}" | sed 's/: /:/g')
    fi

    for hostdep in $(cat "${hostdeps_file}"); do
        if ! [ -f "${base_dir}/host-recipes/${hostdep}" ]; then
            die "$0: host dependency '${hostdep}' for host recipe '${hostpkg}' not found"
        fi

        graph="${graph}
${hostdep}:$(include_recipe "${base_dir}/host-recipes/${hostdep}" && echo ${hostdeps} ${hostrundeps})"
    done

    topo_sort "${graph}"
}

get_hostdeps_file_for_topo() {
    # Collects all host dependencies recursively for use in topological sort.
    deps_to_do=""

    for hostdep in ${hostdeps} ${hostrundeps}; do
        if ! grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1; then
            deps_to_do="${deps_to_do} ${hostdep}"
            printf " ${hostdep} " >>"${hostdeps_file}"
        fi
    done

    for hostdep in ${deps_to_do}; do
        tracked_subshell '
            include_recipe "${base_dir}"/host-recipes/${hostdep}
            get_hostdeps_file_for_topo
        '
    done
}

get_builddeps_file() {
    deps_to_do=""

    for dep in ${deps} ${builddeps}; do
        if ! grep " ${dep} " "${deps_file}" >/dev/null 2>&1; then
            deps_to_do="${deps_to_do} ${dep}"
            printf " ${dep} " >>"${deps_file}"
        fi
    done

    for dep in ${deps_to_do}; do
        tracked_subshell '
            include_recipe "${base_dir}"/recipes/${dep}
            get_deps_file
        '
    done
}

get_deps_file() {
    deps_to_do=""

    for dep in ${deps}; do
        if ! grep " ${dep} " "${deps_file}" >/dev/null 2>&1; then
            deps_to_do="${deps_to_do} ${dep}"
            printf " ${dep} " >>"${deps_file}"
        fi
    done

    for dep in ${deps_to_do}; do
        tracked_subshell '
            include_recipe "${base_dir}"/recipes/${dep}
            get_deps_file
        '
    done
}

run_in_container1() {
    run_in_cont1_root="$1"
    shift 1

    cat /etc/resolv.conf >"${run_in_cont1_root}/etc/resolv.conf"

    unshare --user --map-root-user --mount --pid --fork -- sh -c "
        set -e

        mount --rbind --make-rslave /dev '${run_in_cont1_root}/dev'
        mount -t proc proc '${run_in_cont1_root}/proc'
        mount --rbind --make-rslave /sys '${run_in_cont1_root}/sys'
        mount -t tmpfs run '${run_in_cont1_root}/run'
        mount -t tmpfs tmpfs '${run_in_cont1_root}/tmp'
        mount -t tmpfs tmpfs '${run_in_cont1_root}/var/tmp'

        mount --bind '${apt_cache}' '${run_in_cont1_root}/var/cache/apt/archives'

        env -i PATH="${PATH}" chroot '${run_in_cont1_root}' /bin/sh -c '
            set -e

            LD_PRELOAD=/nochown.so \
            HOME=/root \
            LANG=en_US.UTF-8 \
            LC_COLLATE=C \
            PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin \
            LD_LIBRARY_PATH=/usr/local/lib64:/usr/local/lib:/usr/lib64:/usr/lib \
            DEBIAN_FRONTEND=noninteractive \
            $(for arg in "$@"; do echo '"'"$(echo "${arg}" | sed 's/"/\\"/g')"'" \'; done)
            # keep this whitespace
        '
    "

    rm "${run_in_cont1_root}/etc/resolv.conf"
}

check_duplicates() {
    for elem in $(cd "$1" && find .); do
        if [ -f "$2"/${elem} ] || [ -L "$2"/${elem} ]; then
            return 1
        fi
    done
}

prepare_container() {
    cd "${build_dir}"

    make_temp
    hostdeps_file="${tmp}"
    make_temp
    deps_file="${tmp}"

    build_hostdeps
    build_deps

    get_hostdeps_file
    get_builddeps_file

    make_temp -d
    container_pkgs="${tmp}"
    make_temp -d
    sysroot_dir="${tmp}"

    for dep in $(cat "${deps_file}"); do
        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
            xbps-install -y -r "${sysroot_dir}" -R "${build_dir}"/pkgs "${dep}" >/dev/null 2>&1
    done

    if [ "$JINX_NATIVE_MODE" = "yes" ] && [ -z "$cross_compile" ]; then
        imgroot="${sysroot_dir}"
    else
        for hostdep in $(cat "${hostdeps_file}"); do
            if ! check_duplicates "${build_dir}"/host-pkgs/${hostdep}/usr/local "${container_pkgs}"; then
                die "jinx: error: Dependency '${hostdep}' contains file confilcts"
            fi
            cp -Pplr "${build_dir}"/host-pkgs/${hostdep}/usr/local/. "${container_pkgs}"/
        done

        imagedeps="$(echo "${imagedeps}" | xargs -n1 | sort -u | xargs)"

        pkgset=""
        for pkg in ${imagedeps}; do
            pkgset="${pkgset}${pkg}/"

            if [ -f "$JINX_CACHE_DIR/sets/${pkgset}.image/.jinx-set-valid" ]; then
                continue
            fi

            rm -rf "$JINX_CACHE_DIR/sets/${pkgset}"
            mkdir -p "$JINX_CACHE_DIR/sets/${pkgset}"

            cp -Pplrf "$JINX_CACHE_DIR/sets/${pkgset}../.image" "$JINX_CACHE_DIR/sets/${pkgset}.image"

            rm -f "$JINX_CACHE_DIR/sets/${pkgset}.image/.jinx-set-valid"

            run_in_container1 "$JINX_CACHE_DIR/sets/${pkgset}.image" apt-get install -y "${pkg}"

            # Fix permissions of files
            for f in $(find "$JINX_CACHE_DIR/sets/${pkgset}.image" -perm 000 2>/dev/null); do
                chmod 755 "$f"
            done

            touch "$JINX_CACHE_DIR/sets/${pkgset}.image/.jinx-set-valid"
        done

        imgroot="$JINX_CACHE_DIR/sets/${pkgset}.image"
    fi
}

run_in_container() {
    if [ "${allow_network}" = "yes" ]; then
        unshare_net_flag=""
    else
        unshare_net_flag="--net"
    fi

    if [ ! -z "$TERM" ]; then
        run_in_cont_term="TERM=\"$TERM\""
    fi

    if ! [ -z "$COLORTERM" ]; then
        run_in_cont_colorterm="COLORTERM=\"$COLORTERM\""
    fi

    mkdir -p "${imgroot}/base_dir" "${imgroot}/sources" "${imgroot}/build_dir"
    cat /etc/resolv.conf >"${imgroot}/etc/resolv.conf"
    touch "${imgroot}/jinx"

    container_pkgs_native_mount=""
    sysroot_native_mount=""
    if ( [ "$JINX_NATIVE_MODE" = "yes" ] && [ "$cross_compile" = "yes" ] ) || ( ! [ "$JINX_NATIVE_MODE" = "yes" ] ); then
        mkdir -p "${imgroot}/sysroot"

        container_pkgs_native_mount="mount -o ro --bind '${container_pkgs}' '${imgroot}/usr/local'"
        sysroot_native_mount="mount -o ro --bind '${sysroot_dir}' '${imgroot}/sysroot'"

        run_in_cont_lang=en_US.UTF-8
    else
        if ! [ -z "$JINX_NATIVE_LANG" ]; then
            run_in_cont_lang="$JINX_NATIVE_LANG"
        else
            run_in_cont_lang=C
        fi
    fi

    shadow_git_dir_build=""
    if [ -d "${build_dir}"/.git ]; then
        make_temp -d
        shadow_git_dir_build="mount --bind '${tmp}' '${imgroot}/build_dir/.git'"
    fi

    shadow_git_dir_base=""
    if [ -d "${base_dir}"/.git ]; then
        make_temp -d
        shadow_git_dir_base="mount --bind '${tmp}' '${imgroot}/base_dir/.git'"
    fi

    unshare --user --map-root-user --mount --pid --fork ${unshare_net_flag} -- sh -c "
        set -e

        mount -o ro --bind '${imgroot}' '${imgroot}'

        mount --rbind --make-rslave /dev '${imgroot}/dev'
        mount -t proc proc '${imgroot}/proc'
        mount --rbind --make-rslave /sys '${imgroot}/sys'
        mount -t tmpfs run '${imgroot}/run'
        mount -t tmpfs tmpfs '${imgroot}/tmp'
        mount -t tmpfs tmpfs '${imgroot}/var/tmp'

        mount -o ro --bind '${script}' '${imgroot}/jinx'
        mount ${container_base_dir_ro} --bind '${base_dir}' '${imgroot}/base_dir'
        mount --bind '${base_dir}/.jinx-cache/tmp' '${imgroot}/base_dir/.jinx-cache/tmp'
        mount --bind '${build_dir}' '${imgroot}/build_dir'
        mount ${container_sources_ro} --bind '${base_dir}/sources' '${imgroot}/base_dir/sources'
        ${container_pkgs_native_mount}
        ${sysroot_native_mount}
        ${shadow_git_dir_base}
        ${shadow_git_dir_build}

        env -i PATH="${PATH}" chroot '${imgroot}' /bin/sh -c '
            set -e

            cd /build_dir

            LD_PRELOAD=/nochown.so \
            HOME=/root \
            LANG=${run_in_cont_lang} \
            LC_COLLATE=C \
            PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin \
            LD_LIBRARY_PATH=/usr/local/lib64:/usr/local/lib:/usr/lib64:/usr/lib \
            ${run_in_cont_term} \
            ${run_in_cont_colorterm} \
            JINX_PARALLELISM=${parallelism} \
            JINX_CONFIG_FILE=/base_dir/Jinxfile \
            JINX_SOURCE_DIR=/base_dir \
            /bin/bash /jinx \
            $(for arg in "$@"; do echo '"'"$(echo "${arg}" | sed 's/"/\\"/g')"'" \'; done)
            # keep this whitespace
        '
    "

    rm -rf "${imgroot}/sysroot" "${imgroot}/base_dir" "${imgroot}/sources" "${imgroot}/build_dir" "${imgroot}/jinx"
    rm "${imgroot}/etc/resolv.conf"
}

destroy_container() {
    rm -rf "${container_pkgs}" "${sysroot_dir}"
}

do_git_fetch() {
    if [ -z "${commit}" ]; then
        die "* error: Git commit not specified"
    fi

    if ! ( echo "${commit}" | grep -qE '^[0-9a-f]{40}$' ); then
        die "* error: Invalid commit hash"
    fi

    if [ "${shallow}" = "no" ]; then
        git clone "${git_url}" "${base_dir}"/sources/${name}
        git -C "${base_dir}"/sources/${name} -c advice.detachedHead=false checkout "${commit}"
    else
        git clone "${git_url}" -c advice.detachedHead=false --revision="${commit}" --depth=1 "${base_dir}"/sources/${name}
    fi
}

do_tarball_fetch() {
    tarball_path="${base_dir}"/sources/"$(basename "${tarball_url}")"

    if ! [ -f "$tarball_path" ]; then
        make_temp
        download_path="${tmp}"

        curl -L -o "${download_path}" "${tarball_url}"
        mv "${download_path}" "${tarball_path}"
    fi

    checksum_verified=no

    if ! [ -z "${tarball_sha256}" ]; then
        actual_sha256="$(sha256sum "${tarball_path}" | awk '{print $1;}')"
        if ! [ ${actual_sha256} = ${tarball_sha256} ]; then
            die "* error: Failed to verify SHA256 for ${name}.
  Expected '${tarball_sha256}';
  got '${actual_sha256}'."
        fi
        checksum_verified=yes
    fi
    if ! [ -z "${tarball_sha512}" ]; then
        actual_sha512="$(sha512sum "${tarball_path}" | awk '{print $1;}')"
        if ! [ ${actual_sha512} = ${tarball_sha512} ]; then
            die "* error: Failed to verify SHA512 for ${name}.
  Expected '${tarball_sha512}';
  got '${actual_sha512}'."
        fi
        checksum_verified=yes
    fi
    if ! [ -z "${tarball_blake2b}" ]; then
        actual_blake2b="$(b2sum "${tarball_path}" | awk '{print $1;}')"
        if ! [ ${actual_blake2b} = ${tarball_blake2b} ]; then
            die "* error: Failed to verify BLAKE2B for ${name}.
  Expected '${tarball_blake2b}';
  got '${actual_blake2b}'."
        fi
        checksum_verified=yes
    fi

    if [ "${checksum_verified}" = "no" ]; then
        die "* error: No checksum method specified for ${name}"
    fi

    make_temp -d
    extract_dir="${tmp}"

    ( cd "${extract_dir}" && tar -xf "${tarball_path}" )

    mv "${extract_dir}"/* "${base_dir}"/sources/${name} >/dev/null 2>&1 || (
        mkdir -p "${base_dir}"/sources/${name}
        mv "${extract_dir}"/* "${base_dir}"/sources/${name}/
    )

    rm -rf "${extract_dir}" "${tarball_path}"
}

get_real_source_dir() {
    unset is_local_package
    unset is_sourceless_package

    if [ -z "${source_dir}" ] && [ -z "${git_url}" ] && [ -z "${tarball_url}" ]; then
        source_dir=/dev/null
        is_local_package=true
        is_sourceless_package=true
        return
    fi

    if [ -z "${source_dir}" ]; then
        source_dir="${base_dir}"/sources/${name}
    else
        source_dir="${base_dir}"/"${source_dir}"
        if ! [ -d "${source_dir}" ]; then
            die "* source_dir of a local package is not a valid path"
        fi
        is_local_package=true
    fi
}

source_source_recipe() {
    if [ -f "${base_dir}"/source-recipes/$1 ]; then
        include_recipe "${base_dir}"/source-recipes/$1
    elif [ -f "${base_dir}"/recipes/$1 ]; then
        include_recipe "${base_dir}"/recipes/$1

        imagedeps="${source_imagedeps}"
        hostdeps="${source_hostdeps}"
        deps="${source_deps}"
        allow_network="${source_allow_network}"
    else
        die "* could not find source recipe '$1'"
    fi
}

do_fetch() {
    source_source_recipe $1

    get_real_source_dir

    sysroot_dir="/sysroot"

    if ! [ "${is_local_package}" = true ] && ! [ "${is_sourceless_package}" = true ]; then
        if ! [ -z "${git_url}" ]; then
            do_git_fetch
        elif ! [ -z "${tarball_url}" ]; then
            do_tarball_fetch
        fi
    fi

    if ! [ "${is_sourceless_package}" = true ]; then
        tracked_subshell '
            cd "${source_dir}"
            early_prepare
        '
    fi
}

do_patch() {
    source_source_recipe $1

    get_real_source_dir

    make_temp
    patch_trash="${tmp}"

    cd "${source_dir}"

    needs_match_timestamps=no
    rm -rf "${base_dir}"/sources/${name}-clean
    if [ -d "${base_dir}"/patches/${name} ]; then
        for patch in "${base_dir}"/patches/${name}/*; do
            [ "${patch}" = "${base_dir}/patches/${name}/*" ] && break
            [ "${patch}" = "${base_dir}"/patches/${name}/jinx-working-patch.patch ] && continue

            if ! [ -d "${base_dir}"/sources/${name}-clean ]; then
                cp -rp "${source_dir}" "${base_dir}"/sources/${name}-clean
                needs_match_timestamps=yes
            fi

            patch --no-backup-if-mismatch -p1 -r "${patch_trash}" < "${patch}"
        done

        if [ "${needs_match_timestamps}" = yes ]; then
            # make sure timestamps match
            for f in $(diff -rq --no-dereference "${base_dir}"/sources/${name}-clean "${source_dir}" | sed '/^Only in/d;s/^Files //g;s/ and.*$//g'); do
                touch --reference="$f" "$(echo "$f" | sed "s|sources/${name}-clean|sources/${name}|g")"
            done
            rm -rf "${base_dir}"/sources/${name}-clean
        fi
    fi

    cp -rp "${source_dir}" "${base_dir}"/sources/${name}-clean

    if [ -f "${base_dir}"/patches/${name}/jinx-working-patch.patch ]; then
        patch --no-backup-if-mismatch -p1 -r "${patch_trash}" < "${base_dir}"/patches/${name}/jinx-working-patch.patch

        # make sure timestamps match
        for f in $(diff -rq --no-dereference "${base_dir}"/sources/${name}-clean "${source_dir}" | sed '/^Only in/d;s/^Files //g;s/ and.*$//g'); do
            touch --reference="$f" "$(echo "$f" | sed "s|sources/${name}-clean|sources/${name}|g")"
        done
    fi

    cp -rp "${source_dir}" "${base_dir}"/sources/${name}-workdir

    cd "${base_dir}"
}

do_prepare() {
    source_source_recipe $1

    get_real_source_dir

    sysroot_dir="/sysroot"

    cd "${source_dir}"
    prepare
    cd "${base_dir}"
}

do_configure_host() {
    include_recipe "${base_dir}"/host-recipes/$1

    mkdir -p "${build_dir}"/host-builds/${name}

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr/local"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/host-builds/${name}
    configure
    cd "${base_dir}"
}

do_build_host() {
    include_recipe "${base_dir}"/host-recipes/$1

    mkdir -p "${build_dir}"/host-builds/${name}

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr/local"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/host-builds/${name}
    build
    cd "${base_dir}"
}

do_package_host() {
    include_recipe "${base_dir}"/host-recipes/$1

    dest_dir="${build_dir}"/host-pkgs/${name}

    rm -rf "${dest_dir}"
    mkdir -p "${dest_dir}"

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr/local"
    sysroot_dir="/sysroot"

    mkdir -p "${dest_dir}${prefix}"

    cd "${build_dir}"/host-builds/${name}
    package

    # Remove libtool files
    for i in $(find "${dest_dir}${prefix}" -name "*.la"); do
        rm -rvf $i
    done

    cd "${base_dir}"
}

do_configure() {
    include_recipe "${base_dir}"/recipes/$1

    mkdir -p "${build_dir}"/builds/${name}

    if ! [ -z "${from_source}" ] || ! [ -z "${tarball_url}" ] || ! [ -z "${git_url}" ] || ! [ -z "${source_dir}" ]; then
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"
        else
            from_source=${name}
        fi

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/builds/${name}
    configure
    cd "${base_dir}"
}

do_build() {
    include_recipe "${base_dir}"/recipes/$1

    mkdir -p "${build_dir}"/builds/${name}

    if ! [ -z "${from_source}" ] || ! [ -z "${tarball_url}" ] || ! [ -z "${git_url}" ] || ! [ -z "${source_dir}" ]; then
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"
        else
            from_source=${name}
        fi

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/builds/${name}
    build
    cd "${base_dir}"
}

do_package() {
    include_recipe "${base_dir}"/recipes/$1

    dest_dir="${build_dir}"/pkgs/${name}

    rm -rf "${dest_dir}"
    mkdir -p "${dest_dir}"

    if ! [ -z "${from_source}" ] || ! [ -z "${tarball_url}" ] || ! [ -z "${git_url}" ] || ! [ -z "${source_dir}" ]; then
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"
        else
            from_source=${name}
        fi

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr"
    sysroot_dir="/sysroot"

    mkdir -p "${dest_dir}${prefix}"

    cd "${build_dir}"/builds/${name}
    package

    # Remove libtool files
    for i in $(find "${dest_dir}${prefix}" -name "*.la"); do
        rm -rvf $i
    done

    cd "${base_dir}"
}

clean_sources() {
    rm -rf "${base_dir}"/sources/$1
    rm -rf "${base_dir}"/sources/$1-clean
    rm -rf "${base_dir}"/sources/$1-workdir
    rm -rf "${base_dir}"/sources/$1.version
    rm -rf "${base_dir}"/sources/$1.patched
    rm -rf "${base_dir}"/sources/$1.prepared
}

need_repatch() {
    rm -rf "${base_dir}"/sources/$1

    if [ -d "${base_dir}"/sources/$1-clean ]; then
        mv "${base_dir}"/sources/$1-clean "${base_dir}"/sources/$1
    fi

    rm -rf "${base_dir}"/sources/$1-workdir
    rm -rf "${base_dir}"/sources/$1.patched
    rm -rf "${base_dir}"/sources/$1.prepared
}

do_source() {
    source_source_recipe $1

    get_real_source_dir

    cross_compile=yes
    prepare_container

    if ! [ -f "${base_dir}"/sources/$1.version ] || ! [ "$(cat "${base_dir}"/sources/$1.version)" = "${version}" ]; then
        tracked_subshell '
            allow_network="yes"
            clean_sources '$1'
            [ "${is_local_package}" = true ] || container_base_dir_ro="-o ro"
            run_in_container internal-fetch '$1'
            echo "${version}" >"${base_dir}"/sources/'$1'.version
        '
    fi

    if ! [ -f "${base_dir}"/sources/$1.patched ]; then
        tracked_subshell '
            if ! [ "${is_local_package}" = true ] && ! [ "${is_sourceless_package}" = true ]; then
                allow_network="yes"
                run_in_container internal-patch '$1'
            fi
            touch "${base_dir}"/sources/'$1'.patched
        '
    fi

    if ! [ -f "${base_dir}"/sources/$1.prepared ]; then
        tracked_subshell '
            if ! [ "${is_sourceless_package}" = true ]; then
                [ "${is_local_package}" = true ] || container_base_dir_ro="-o ro"
                run_in_container internal-prepare '$1'
            fi
            touch "${base_dir}"/sources/'$1'.prepared
        '
    fi

    destroy_container
}

do_rebuild() {
    rm -rf "${build_dir}"/builds/"$1"

    do_pkg "$1"
}

do_host_rebuild() {
    rm -rf "${build_dir}"/host-builds/"$1"

    do_host_pkg "$1"
}

do_regen() {
    source_source_recipe $1

    [ -f "${base_dir}"/sources/$1.patched ] || die "cannot regenerate non-built package"

    get_real_source_dir

    make_temp
    patch_file="${tmp}"

    if ! [ "${is_local_package}" = true ]; then
        cd "${base_dir}"/sources

        # exclude version control dirs
        make_temp -d
        vc_dir_clean="${tmp}"
        rm -rf "${vc_dir_clean}"
        make_temp -d
        vc_dir_workdir="${tmp}"
        rm -rf "${vc_dir_workdir}"

        if ! [ -z "${git_url}" ]; then
            mv $1-clean/.git "${vc_dir_clean}"
            mv $1-workdir/.git "${vc_dir_workdir}"
        fi

        git diff --no-index --no-prefix $1-clean $1-workdir >"${patch_file}" || true

        if ! [ -z "${git_url}" ]; then
            mv "${vc_dir_clean}" $1-clean/.git
            mv "${vc_dir_workdir}" $1-workdir/.git
        fi

        if [ -s "${patch_file}" ]; then
            mkdir -p "${base_dir}"/patches/$1
            mv "${patch_file}" "${base_dir}"/patches/$1/jinx-working-patch.patch
        fi

        cd "${base_dir}"

        rm -rf "${source_dir}"
        cp -rp "${base_dir}"/sources/$1-workdir "${source_dir}"
    fi

    rm -rf "${base_dir}"/sources/$1.prepared

    cross_compile=yes
    prepare_container
    run_in_container internal-prepare $1
    destroy_container
}

do_host_pkg() {
    include_recipe "${base_dir}"/host-recipes/$1

    echo "* building host package: $name"

    if ! [ -z "${from_source}" ]; then
        tracked_subshell 'do_source "${from_source}"'
    else
        tracked_subshell 'do_source "${name}"'
    fi

    cross_compile=yes
    prepare_container

    container_sources_ro="-o ro"
    if ! [ -d "${build_dir}"/host-builds/$1 ]; then
        run_in_container internal-configure-host $1
    fi
    run_in_container internal-build-host $1
    rm -rf "${build_dir}"/host-pkgs/$1
    run_in_container internal-package-host $1
    unset container_sources_ro

    destroy_container

    if [ "$JINX_CLEAN_WORKDIRS" = "yes" ]; then
        if ! [ "$clean_workdirs" = "no" ]; then
            rm -rf "${build_dir}"/host-builds/$1

            if [ -z "${from_source}" ]; then
                source_source_recipe $1
            else
                source_source_recipe ${from_source}
            fi

            get_real_source_dir

            if ! [ "${is_sourceless_package}" = true ] && ! [ "${is_local_package}" = true ]; then
                clean_sources "${name}"
            fi
        fi
    fi
}

do_pkg() {
    include_recipe "${base_dir}"/recipes/$1

    echo "* building package: $name"

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
    fi

    if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
        rm -rf "${build_dir}"/builds/"$1"
        tracked_subshell '
        if ! [ -z "${from_source}" ]; then
            name=$(unset name && source_source_recipe ${from_source} && echo "${name}")
        fi
        clean_sources "${name}"
        '
    fi

    if ! [ -z "${from_source}" ]; then
        tracked_subshell 'do_source "${from_source}"'
    else
        tracked_subshell 'do_source "${name}"'
    fi

    prepare_container

    container_sources_ro="-o ro"
    if ! [ -d "${build_dir}"/builds/$1 ]; then
        run_in_container internal-configure $1
    fi
    run_in_container internal-build $1
    rm -rf "${build_dir}"/pkgs/$1
    run_in_container internal-package $1
    unset container_sources_ro

    destroy_container

    xbps_deps=""
    for dep in ${deps}; do
        bootstrap_pkg=$(unset bootstrap_pkg && . "${base_dir}"/recipes/${dep} && echo "${bootstrap_pkg}")
        if [ "${bootstrap_pkg}" = "yes" ]; then
            continue
        fi

        xbps_deps="${xbps_deps} ${dep}>=0.0"
    done

    dest_dir="${build_dir}"/pkgs/${name}

    cd "${build_dir}"/pkgs
        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
    xbps-create \
        -A $JINX_ARCH \
        -s ${name} \
        -n ${name}-${version}_${revision} \
        -D "${xbps_deps}" \
        "${dest_dir}"

    rm -rf "${dest_dir}"

        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
    xbps-rindex \
        -a "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps \
        -f

    if [ "$JINX_CLEAN_WORKDIRS" = "yes" ]; then
        if ! [ "$clean_workdirs" = "no" ]; then
            rm -rf "${build_dir}"/builds/$1

            if [ -z "${from_source}" ]; then
                source_source_recipe $1
            else
                source_source_recipe ${from_source}
            fi

            get_real_source_dir

            if ! [ "${is_sourceless_package}" = true ] && ! [ "${is_local_package}" = true ]; then
                clean_sources "${name}"
            fi
        fi
    fi
}

cmd_host_build() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/host-recipes '&&' echo "${ppkg}" ')' ); do
            tracked_subshell 'do_host_pkg "${pkg}"'
        done
    done
}

cmd_build() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            tracked_subshell 'do_pkg "${pkg}"'
        done
    done
}

do_build_if_needed() {
    include_recipe "${base_dir}"/recipes/$1
    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
    fi

    if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
        tracked_subshell 'do_pkg "'$1'"'
    fi
}

do_host_build_if_needed() {
    if ! [ -d "${build_dir}"/host-pkgs/${hostdep} ]; then
        tracked_subshell 'do_host_pkg "'$1'"'
    fi
}

do_update() {
    include_recipe "${base_dir}"/recipes/$1
    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
    fi

    if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
        make_temp
        hostdeps_file="${tmp}"

        get_hostdeps_file

        for hostdep in $(cat "${hostdeps_file}"); do
            tracked_subshell 'do_host_build_if_needed "${hostdep}"'
        done
        builddeps_var="$(tracked_subshell 'get_builddeps "${name}"')"
        for dep in ${builddeps_var}; do
            tracked_subshell 'do_build_if_needed "${dep}"'
        done
    fi
}

cmd_update() {
    if [ -z "$1" ]; then
        set -- '*'
    fi

    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            tracked_subshell 'do_update "${pkg}"'
        done
    done
}

get_deps_fast() {
    # Fast dep extraction without sourcing the recipe file
    # Outputs: space-separated deps and builddeps
    recipe_file="$1"
    deps_line="$(grep '^deps=' "$recipe_file" 2>/dev/null | head -1)"
    builddeps_line="$(grep '^builddeps=' "$recipe_file" 2>/dev/null | head -1)"

    # Extract values: deps="foo bar" -> foo bar
    deps_line="${deps_line#deps=}"
    builddeps_line="${builddeps_line#builddeps=}"

    # Remove comments first (everything from # onwards)
    deps_line="${deps_line%%#*}"
    builddeps_line="${builddeps_line%%#*}"

    # Remove trailing whitespace
    deps_line="$(printf '%s' "$deps_line" | sed 's/[[:space:]]*$//')"
    builddeps_line="$(printf '%s' "$builddeps_line" | sed 's/[[:space:]]*$//')"

    # Remove quotes if present
    deps_line="${deps_line%\"}"
    deps_line="${deps_line#\"}"
    builddeps_line="${builddeps_line%\"}"
    builddeps_line="${builddeps_line#\"}"

    printf '%s' "${deps_line} ${builddeps_line}"
}

get_hostdeps_fast() {
    # Fast host dep extraction without sourcing the recipe file
    recipe_file="$1"
    hostdeps_line="$(grep '^hostdeps=' "$recipe_file" 2>/dev/null | head -1)"
    hostrundeps_line="$(grep '^hostrundeps=' "$recipe_file" 2>/dev/null | head -1)"

    hostdeps_line="${hostdeps_line#hostdeps=}"
    hostrundeps_line="${hostrundeps_line#hostrundeps=}"

    # Remove comments first (everything from # onwards)
    hostdeps_line="${hostdeps_line%%#*}"
    hostrundeps_line="${hostrundeps_line%%#*}"

    # Remove trailing whitespace
    hostdeps_line="$(printf '%s' "$hostdeps_line" | sed 's/[[:space:]]*$//')"
    hostrundeps_line="$(printf '%s' "$hostrundeps_line" | sed 's/[[:space:]]*$//')"

    # Remove quotes if present
    hostdeps_line="${hostdeps_line%\"}"
    hostdeps_line="${hostdeps_line#\"}"
    hostrundeps_line="${hostrundeps_line%\"}"
    hostrundeps_line="${hostrundeps_line#\"}"

    printf '%s' "${hostdeps_line} ${hostrundeps_line}"
}

cmd_dry_run() {
    # Print all packages that would be built (space separated), but only those
    # that are not already built in the build cache. Host packages (prefixed 'host:')
    # are mentioned inline just before the regular package that needs them,
    # and only if they haven't been mentioned before.
    if [ -z "$1" ]; then
        set -- '*'
    fi

    # Expand all package patterns upfront
    all_packages=""
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            all_packages="${all_packages} ${pkg}"
        done
    done

    # Build a fast lookup table: package -> deps (without sourcing)
    make_temp
    pkg_deps_cache="${tmp}"
    touch "${pkg_deps_cache}"

    for pkg in ${all_packages}; do
        fast_deps="$(get_deps_fast "${base_dir}/recipes/${pkg}")"
        printf "%s:%s\n" "${pkg}" "${fast_deps}" >> "${pkg_deps_cache}"
    done

    # Recursively collect all transitive deps (without sourcing recipes)
    make_temp
    all_deps_cache="${tmp}"
    touch "${all_deps_cache}"

    collect_all_deps() {
        pkg="$1"
        if grep -q "^${pkg}$" "${all_deps_cache}" 2>/dev/null; then
            return
        fi
        printf "%s\n" "${pkg}" >> "${all_deps_cache}"

        deps="$(grep "^${pkg}:" "${pkg_deps_cache}" | cut -d: -f2-)"
        for dep in ${deps}; do
            if [ ! -z "${dep}" ]; then
                collect_all_deps "${dep}"
            fi
        done
    }

    # Collect all deps for all packages
    for pkg in ${all_packages}; do
        collect_all_deps "${pkg}"
    done

    # Now check which ones are unbuilt
    all_unbuilt=""
    for dep in $(cat "${all_deps_cache}"); do
        include_recipe "${base_dir}"/recipes/"${dep}"
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        fi
        if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
            all_unbuilt="${all_unbuilt} ${dep}"
        fi
    done

    # Collect host deps for all unbuilt packages (fast)
    make_temp
    pkg_hostdeps_cache="${tmp}"
    touch "${pkg_hostdeps_cache}"

    all_hostdeps_unsorted=""
    for pkg in ${all_unbuilt}; do
        hostdeps="$(get_hostdeps_fast "${base_dir}/recipes/${pkg}")"
        if ! [ -z "${hostdeps}" ]; then
            printf "%s:%s\n" "${pkg}" "${hostdeps}" >> "${pkg_hostdeps_cache}"
            all_hostdeps_unsorted="${all_hostdeps_unsorted} ${hostdeps}"
        fi
    done

    # Topo sort host deps once
    hostdeps_sorted=""
    if ! [ -z "${all_hostdeps_unsorted}" ]; then
        hostdeps_unique="$(printf '%s\n' ${all_hostdeps_unsorted} | awk '!seen[$0]++' | tr '\n' ' ')"
        hostdeps_sorted="$(tracked_subshell '
            for hostdep in '"${hostdeps_unique}"'; do
                sorted_hostdeps="$(get_hostdeps_builddeps "${hostdep}")"
                printf "%s\n" "${sorted_hostdeps}"
            done | awk "!seen[\$0]++"
        ')"
    fi

    # Build topologically sorted list of unbuilt deps
    make_temp
    topo_sorted_unbuilt="${tmp}"
    make_temp
    topo_graph="${tmp}"

    # Build graph for topo sort
    for dep in ${all_unbuilt}; do
        deps_of_dep="$(grep "^${dep}:" "${pkg_deps_cache}" | cut -d: -f2-)"
        # Only include deps that are also unbuilt
        unbuilt_deps_of_dep=""
        for d in ${deps_of_dep}; do
            if printf ' %s ' "${all_unbuilt}" | grep -q " ${d} "; then
                unbuilt_deps_of_dep="${unbuilt_deps_of_dep} ${d}"
            fi
        done
        printf "%s:%s\n" "${dep}" "${unbuilt_deps_of_dep}" >> "${topo_graph}"
    done

    topo_sort_result="$(topo_sort "$(cat "${topo_graph}")")"

    # Emit in topological order with host deps inline
    pending_list=""
    emitted_hostdeps=" "

    for dep in ${topo_sort_result}; do
        # Emit host deps for this package first
        dep_hostdeps="$(grep "^${dep}:" "${pkg_hostdeps_cache}" 2>/dev/null | cut -d: -f2-)"
        if ! [ -z "${dep_hostdeps}" ]; then
            for hostdep in ${dep_hostdeps}; do
                if ! printf '%s' "${emitted_hostdeps}" | grep -q " ${hostdep} "; then
                    if ! [ -d "${build_dir}/host-pkgs/${hostdep}" ]; then
                        pending_list="${pending_list} host:${hostdep}"
                    fi
                    emitted_hostdeps="${emitted_hostdeps}${hostdep} "
                fi
            done
        fi
        # Then emit the package itself
        pending_list="${pending_list} ${dep}"
    done

    # Print packages preserving order, space separated, with global deduplication
    printf '%s\n' ${pending_list} | awk '!seen[$0]++{printf "%s ", $0} END{print ""}'
}

cmd_regen() {
    for i in "$@"; do
        tracked_subshell 'do_regen "$i"'
    done
}

cmd_host_rebuild() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/host-recipes '&&' echo "${ppkg}" ')' ); do
            tracked_subshell 'do_host_rebuild "${pkg}"'
        done
    done
}

cmd_rebuild() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            tracked_subshell 'do_rebuild "${pkg}"'
        done
    done
}

cmd_install() {
    force_install=""
    if [ "$1" = "-f" ]; then
        force_install="$1"
        shift 1
    fi
    sysroot="$1"
    shift 1
    mkdir -m 755 -p "${sysroot}"

    pkgs_to_install=""
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            bootstrap_pkg=$(unset bootstrap_pkg && . "${base_dir}"/recipes/${pkg} && echo "${bootstrap_pkg}")
            if [ "${bootstrap_pkg}" = "yes" ]; then
                continue
            fi

            pkgs_to_install="${pkgs_to_install} ${pkg}"
        done
    done

    files_to_ignore='\.keep
\.plist
/INSTALL
/REMOVE'

    make_temp
    all_files="${tmp}"

    for pkg in ${pkgs_to_install}; do
        echo "* installing ${pkg}..."

        tracked_subshell '
        include_recipe "${base_dir}"/recipes/${pkg}

        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        fi

        if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
            if [ "$(id -u)" = "0" ]; then
                die "$0: a package needs to be built, but Jinx was invoked as root"
            fi
            tracked_subshell '\''do_pkg "${pkg}"'\''
        fi

        # xbps seems to only install the package every second time when reinstalling.
        # Remove the package to be sure it gets reinstalled.
        if ! [ -z "${force_install}" ]; then
            XBPS_ARCH=invalid \
            XBPS_TARGET_ARCH="${JINX_ARCH}" \
                xbps-remove -Ffy -r "${sysroot}" ${pkg} >/dev/null 2>&1 || true
        fi

        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
            xbps-install -y $force_install -r "${sysroot}" -R "${build_dir}"/pkgs ${pkg} >/dev/null 2>&1

        zstdcat "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps | tar -tf - | ( grep -v "${files_to_ignore}" || true ) >>"${all_files}"
        '
    done

    echo "* checking for conflicts..."

    make_temp
    all_files_sorted="${tmp}"

    make_temp
    all_files_uniq="${tmp}"

    sort <"${all_files}" >"${all_files_sorted}"
    uniq <"${all_files_sorted}" >"${all_files_uniq}"

    dup_elements="$(comm -23 "${all_files_sorted}" "${all_files_uniq}" | uniq)"

    if ! [ -z "${dup_elements}" ]; then
        echo "* error: duplicate files were found."
        for elem in ${dup_elements}; do
            echo "  file path: ${elem}"
            printf "  in packages:"
            for pkg in ${pkgs_to_install}; do
                tracked_subshell '
                include_recipe "${base_dir}"/recipes/${pkg}

                if ! [ -z "${from_source}" ]; then
                    version=$(unset version && source_source_recipe ${from_source} && echo "$version")
                fi

                if zstdcat "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps | tar -tf - | ( grep -v "${files_to_ignore}" || true ) | grep -q "${elem}"; then
                    printf " ${pkg}"
                fi
                '
            done
            printf "\n"
        done
        exit 1
    fi
}

reinit_container() {
    chmod -R 777 "$JINX_CACHE_DIR/sets" 2>/dev/null || true
    chmod -R 777 "$JINX_CACHE_DIR/apt-cache" 2>/dev/null || true
    rm -rf "$JINX_CACHE_DIR/sets" "$JINX_CACHE_DIR/apt-cache"

    mkdir -p "${apt_cache}"
    mkdir -p "${JINX_CACHE_DIR}/tmp"

    mkdir -p "$JINX_CACHE_DIR/sets/.image"

    SHA256_COMMAND="sha256sum"
    if ! command -v "${SHA256_COMMAND%% *}" >/dev/null 2>&1; then
        SHA256_COMMAND="sha256"
        if ! command -v "${SHA256_COMMAND%% *}" >/dev/null 2>&1; then
            die "error: Cannot find sha256(sum) command"
        fi
    fi

    # Build xbps
    wget -O "${JINX_CACHE_DIR}/xbps-${XBPS_VERSION}.tar.gz" https://github.com/void-linux/xbps/archive/${XBPS_VERSION}.tar.gz
    if ! "${SHA256_COMMAND}" "${JINX_CACHE_DIR}/xbps-${XBPS_VERSION}.tar.gz" | grep "${XBPS_SHA256SUM}" >/dev/null 2>&1; then
        die "Jinx: Failed to verify XBPS tarball"
    fi

    tracked_subshell '

    cd "$JINX_CACHE_DIR"
    tar -zxf xbps-${XBPS_VERSION}.tar.gz
    cd xbps-${XBPS_VERSION}

    # XXX: xbps upstream forgot to bump version string
    sed "s/0\.60/0.60.5/g" configure >configure.sed
    mv configure.sed configure
    sed "s/&& DEBUG=yes/&& DEBUG=no/g" configure >configure.sed
    mv configure.sed configure
    chmod +x configure

    CFLAGS="-O2 -pipe -Wno-error" ./configure --verbose --prefix="$JINX_CACHE_DIR/xbps" --localstatedir=/var

    sed "/DBDIR/d" data/Makefile >data/Makefile.sed
    mv data/Makefile.sed data/Makefile

    sed "s/-lxml2/-lxml2 -llzma -lm/g" config.mk >config.mk.sed
    mv config.mk.sed config.mk

    if command -v gmake >/dev/null 2>&1; then
        MAKE=gmake
    else
        MAKE=make
    fi

    ${MAKE} -j${parallelism}
    ${MAKE} install

    cd ..
    rm -rf xbps-${XBPS_VERSION}*

    '

    cat >"$JINX_CACHE_DIR/nochown.c" <<EOF
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int chown(const char *pathname, uid_t owner, gid_t group) {
    (void)pathname; (void)owner; (void)group;
    return 0;
}

int fchown(int fd, uid_t owner, gid_t group) {
    (void)fd; (void)owner; (void)group;
    return 0;
}

int lchown(const char *pathname, uid_t owner, gid_t group) {
    (void)pathname; (void)owner; (void)group;
    return 0;
}

int fchownat(int dirfd, const char *pathname,
             uid_t owner, gid_t group, int flags) {
    (void)dirfd; (void)pathname; (void)owner; (void)group; (void)flags;
    return 0;
}
EOF
    cc -O2 -pipe -std=gnu99 -Wall -Wextra -fPIC -shared "$JINX_CACHE_DIR/nochown.c" -o "$JINX_CACHE_DIR/sets/.image/nochown.so"
    rm "$JINX_CACHE_DIR/nochown.c"

    DEBOOTSTRAP_ARCH="$(uname -m)"
    case "${DEBOOTSTRAP_ARCH}" in
        i?86) DEBOOTSTRAP_ARCH=i386 ;;
        x86_64) DEBOOTSTRAP_ARCH=amd64 ;;
        arm*) DEBOOTSTRAP_ARCH=armhf ;;
        aarch64) DEBOOTSTRAP_ARCH=arm64 ;;
        loongarch64) DEBOOTSTRAP_ARCH=loong64 ;;
        ppc64le) DEBOOTSTRAP_ARCH=ppc64el ;;
    esac

    # Install debootstrap
    tracked_subshell '
        cd "${JINX_CACHE_DIR}"
        wget -O debootstrap.tar.gz https://salsa.debian.org/installer-team/debootstrap/-/archive/${debootstrap_version}/debootstrap-${debootstrap_version}.tar.gz
        if ! "${SHA256_COMMAND}" debootstrap.tar.gz | grep "${debootstrap_sha256sum}" >/dev/null 2>&1; then
            die "Jinx: Failed to verify debootstrap tarball"
        fi
        tar -zxf debootstrap.tar.gz
        make -C debootstrap-${debootstrap_version} DESTDIR="$(pwd -P)/debootstrap" install
        rm -rf debootstrap.tar.gz debootstrap-${debootstrap_version}
        sed "s/HOST_ARCH=[^;#]*/HOST_ARCH=${DEBOOTSTRAP_ARCH}/g;s|DEBOOTSTRAP_DIR=/usr/share/debootstrap|DEBOOTSTRAP_DIR=\"$(pwd -P)/debootstrap/usr/share/debootstrap\"|g" debootstrap/usr/sbin/debootstrap >debootstrap.sed
        mv debootstrap.sed debootstrap/usr/sbin/debootstrap
        chmod +x debootstrap/usr/sbin/debootstrap
    '

    mkdir -p "$JINX_CACHE_DIR/sets/.image/var/cache/apt/archives"

    unshare --user --map-root-user --mount --pid --fork -- sh -c "
        set -e

        mount --bind '${apt_cache}' '$JINX_CACHE_DIR/sets/.image/var/cache/apt/archives'

        LD_PRELOAD='$JINX_CACHE_DIR/sets/.image/nochown.so' debootstrap \
            --foreign sid '$JINX_CACHE_DIR/sets/.image' https://snapshot.debian.org/archive/debian/${JINX_DEBIAN_SNAPSHOT}/
    "

    for dir in dev proc sys run tmp var/tmp; do
        rm -rf "${JINX_CACHE_DIR}/sets/.image/${dir}"
        mkdir -p "${JINX_CACHE_DIR}/sets/.image/${dir}"
    done

    rm "${JINX_CACHE_DIR}/sets/.image/etc/resolv.conf"
    echo localhost >"${JINX_CACHE_DIR}/sets/.image/etc/hostname"

    run_in_container1 "$JINX_CACHE_DIR/sets/.image" /debootstrap/debootstrap --second-stage

    echo 'en_US.UTF-8 UTF-8' > "$JINX_CACHE_DIR/sets/.image/etc/locale.gen"
    echo 'APT::Install-Suggests "0";
APT::Install-Recommends "0";
APT::Sandbox::User "root";
Acquire::Check-Valid-Until "0";' >> "$JINX_CACHE_DIR/sets/.image/etc/apt/apt.conf"

    run_in_container1 "$JINX_CACHE_DIR/sets/.image" apt-get update
    run_in_container1 "$JINX_CACHE_DIR/sets/.image" apt-get install -y locales
    run_in_container1 "$JINX_CACHE_DIR/sets/.image" locale-gen

    # Fix permissions of files
    for f in $(find "$JINX_CACHE_DIR/sets/.image" -perm 000 2>/dev/null); do
        chmod 755 "$f"
    done

    run_in_container1 "$JINX_CACHE_DIR/sets/.image" apt-get install -y bash bzip2 curl diffutils findutils gawk git grep gzip lzip patch sed tar xz-utils zstd ${JINX_BASE_PACKAGES}

    if ! [ -z "${JINX_CMAKE_PLATFORM}" ]; then
        cp "${base_dir}/${JINX_CMAKE_PLATFORM}" "${JINX_CACHE_DIR}"/sets/.image/usr/share/cmake-*/Modules/Platform/
    fi
}

first_use() {
    echo "* preparing Jinx cache..."

    mkdir -p "$JINX_CACHE_DIR"

    reinit_container

    echo "${jinx_version}" >"${JINX_CACHE_DIR}/version"
    echo "${JINX_DEBIAN_SNAPSHOT}" >"${JINX_CACHE_DIR}/debian_snapshot"
    echo "${JINX_BASE_PACKAGES}" >"${JINX_CACHE_DIR}/base_packages"

    echo "* done"
}

redo_first_use() {
    echo "* purging old Jinx cache..."
    chmod -R 777 "$JINX_CACHE_DIR" || true
    rm -rf "$JINX_CACHE_DIR"
    first_use
}

if ! [ -f "$JINX_CONFIG_FILE" ]; then
    die "$0: missing Jinxfile in directory '$base_dir'"
fi

unset JINX_MAJOR_VER
unset JINX_DEBIAN_SNAPSHOT
unset JINX_BASE_PACKAGES
unset JINX_CMAKE_PLATFORM
. "${JINX_CONFIG_FILE}"

if [ -z "${JINX_MAJOR_VER}" ]; then
    die "$0: required Jinxfile variable JINX_MAJOR_VER missing"
fi

if ! [ "$JINX_MAJOR_VER" = "$jinx_major_ver" ]; then
    die "$0: needed major version ($JINX_MAJOR_VER) differs from Jinx-provided major version ($jinx_major_ver)"
fi

if [ -z "${JINX_DEBIAN_SNAPSHOT}" ]; then
    die "$0: required Jinxfile variable JINX_DEBIAN_SNAPSHOT missing"
fi

if [ -z "$JINX_ARCH" ]; then
    die "$0: required config variable \$JINX_ARCH missing"
fi

if ! [ -d "$JINX_CACHE_DIR" ]; then
    first_use
fi

if  ( ! [ -f "${JINX_CACHE_DIR}/version" ] || ! [ "$(cat "${JINX_CACHE_DIR}/version")" = "${jinx_version}" ] ) \
 || ( ! [ -f "${JINX_CACHE_DIR}/debian_snapshot" ] || ! [ "$(cat "${JINX_CACHE_DIR}/debian_snapshot")" = "${JINX_DEBIAN_SNAPSHOT}" ] ) \
 || ( ! [ -f "${JINX_CACHE_DIR}/base_packages" ] || ! [ "$(cat "${JINX_CACHE_DIR}/base_packages")" = "${JINX_BASE_PACKAGES}" ] ); then
    redo_first_use
fi

case "$1" in
    internal-prepare)
        do_prepare "$2"
        ;;
    internal-fetch)
        do_fetch "$2"
        ;;
    internal-patch)
        do_patch "$2"
        ;;
    internal-configure-host)
        do_configure_host "$2"
        ;;
    internal-build-host)
        do_build_host "$2"
        ;;
    internal-package-host)
        do_package_host "$2"
        ;;
    internal-configure)
        do_configure "$2"
        ;;
    internal-build)
        do_build "$2"
        ;;
    internal-package)
        do_package "$2"
        ;;
    host-build)
        shift 1
        cmd_host_build "$@"
        ;;
    build)
        shift 1
        cmd_build "$@"
        ;;
    update)
        shift 1
        cmd_update "$@"
        ;;
    regenerate|regen)
        shift 1
        cmd_regen "$@"
        ;;
    host-rebuild)
        shift 1
        cmd_host_rebuild "$@"
        ;;
    rebuild)
        shift 1
        cmd_rebuild "$@"
        ;;
    install)
        shift 1
        cmd_install "$@"
        ;;
    reinstall)
        shift 1
        cmd_install -f "$@"
        ;;
    rebuild-cache)
        redo_first_use
        ;;
    dry-run)
        shift 1
        cmd_dry_run "$@"
        ;;
    *)
        die "$0: unknown command: $1"
        ;;
esac
