diff --git mlibc-clean/abis/ironclad/fcntl.h mlibc-workdir/abis/ironclad/fcntl.h
index 950188b..4fac95c 100644
--- mlibc-clean/abis/ironclad/fcntl.h
+++ mlibc-workdir/abis/ironclad/fcntl.h
@@ -47,6 +47,7 @@
 #define F_GETLK      9
 #define F_SETLK      10
 #define F_SETLKW     11
+#define F_DUPFD_CLOFORK 12
 
 #define F_RDLCK 1
 #define F_UNLCK 2
diff --git mlibc-clean/abis/ironclad/stat.h mlibc-workdir/abis/ironclad/stat.h
index 7a507a0..1ff2844 100644
--- mlibc-clean/abis/ironclad/stat.h
+++ mlibc-workdir/abis/ironclad/stat.h
@@ -13,14 +13,17 @@
 #include <bits/ansi/time_t.h>
 #include <bits/ansi/timespec.h>
 
-#define S_IFMT 0x0F000
-#define S_IFBLK 0x06000
-#define S_IFCHR 0x02000
-#define S_IFIFO 0x01000
-#define S_IFREG 0x08000
-#define S_IFDIR 0x04000
-#define S_IFLNK 0x0A000
-#define S_IFSOCK 0x0C000
+#define S_IFMT   0b1111111111000000000000
+#define S_IFIFO  0b0000000001000000000000
+#define S_IFCHR  0b0000000010000000000000
+#define S_IFDIR  0b0000000100000000000000
+#define S_IFBLK  0b0000001000000000000000
+#define S_IFREG  0b0000010000000000000000
+#define S_IFLNK  0b0000100000000000000000
+#define S_IFSOCK 0b0001000000000000000000
+#define S_IMQ    0b0010000000000000000000
+#define S_ISEM   0b0100000000000000000000
+#define S_ISHM   0b1000000000000000000000
 
 #define S_IRWXU 0700
 #define S_IRUSR 0400
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..232c229 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -13,36 +13,28 @@ bool charset::is_ascii_superset() {
 bool charset::is_alpha(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alpha() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_digit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= '0' && c <= '9';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_digit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_xdigit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_xdigit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_alnum(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alnum() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -55,63 +47,49 @@ bool charset::is_punct(codepoint c) {
 				|| c == '@'
 				|| c == '[' || c == '\\' || c == ']' || c == '^' || c == '_' || c == '`'
 				|| c == '{' || c == '|' || c == '}' || c == '~';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_punct() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_graph(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x21 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_graph() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_blank(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_blank() is not implemented"
-				" for the full Unicode charset " << c << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_space(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_space() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -119,9 +97,7 @@ codepoint charset::to_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'A' && c <= 'Z')
 			return c - 'A' + 'a';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_lower() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
@@ -129,9 +105,7 @@ codepoint charset::to_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'a' && c <= 'z')
 			return c - 'a' + 'A';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_upper() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
diff --git mlibc-clean/options/linux/generic/linux-unistd.cpp mlibc-workdir/options/linux/generic/linux-unistd.cpp
index 264d30c..820d1b7 100644
--- mlibc-clean/options/linux/generic/linux-unistd.cpp
+++ mlibc-workdir/options/linux/generic/linux-unistd.cpp
@@ -6,19 +6,6 @@
 #include <mlibc/linux-sysdeps.hpp>
 #include <unistd.h>
 
-int dup3(int oldfd, int newfd, int flags) {
-	if(oldfd == newfd) {
-		errno = EINVAL;
-		return -1;
-	}
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_dup2, -1);
-	if(int e = mlibc::sys_dup2(oldfd, flags, newfd); e) {
-		errno = e;
-		return -1;
-	}
-	return newfd;
-}
-
 int vhangup(void) {
 	__ensure(!"Not implemented");
 	__builtin_unreachable();
diff --git mlibc-clean/options/linux/include/bits/linux/linux_unistd.h mlibc-workdir/options/linux/include/bits/linux/linux_unistd.h
index 7aa4103..1ded98a 100644
--- mlibc-clean/options/linux/include/bits/linux/linux_unistd.h
+++ mlibc-workdir/options/linux/include/bits/linux/linux_unistd.h
@@ -7,7 +7,6 @@ extern "C" {
 
 #ifndef __MLIBC_ABI_ONLY
 
-int dup3(int __fd, int __newfd, int __flags);
 int vhangup(void);
 int getdtablesize(void);
 int syncfs(int __fd);
diff --git mlibc-clean/options/posix/generic/posix_locale.cpp mlibc-workdir/options/posix/generic/posix_locale.cpp
index f19e623..811b46f 100644
--- mlibc-clean/options/posix/generic/posix_locale.cpp
+++ mlibc-workdir/options/posix/generic/posix_locale.cpp
@@ -25,7 +25,7 @@ void freelocale(locale_t) {
 
 locale_t uselocale(locale_t) {
 	if(!uselocale_seen) {
-		mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
+		//mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
 		uselocale_seen = true;
 	}
 	return nullptr;
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 54c96d8..b4c6bef 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -534,7 +534,7 @@ long double strtold_l(const char *__restrict__, char ** __restrict__, locale_t)
 }
 
 float strtof_l(const char *__restrict__ nptr, char **__restrict__ endptr, locale_t) {
-	mlibc::infoLogger() << "mlibc: strtof_l ignores locales" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: strtof_l ignores locales" << frg::endlog;
 	return strtof(nptr, endptr);
 }
 
diff --git mlibc-clean/options/posix/generic/sys-uio.cpp mlibc-workdir/options/posix/generic/sys-uio.cpp
index 0dff9d4..cdebf00 100644
--- mlibc-clean/options/posix/generic/sys-uio.cpp
+++ mlibc-workdir/options/posix/generic/sys-uio.cpp
@@ -41,7 +41,7 @@ ssize_t writev(int fd, const struct iovec *iovs, int iovc) {
 	}
 
 	// TODO: this implementation is not safe to use in signal contexts
-	mlibc::infoLogger() << "mlibc: falling back to signal-unsafe writev implementation!" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: falling back to signal-unsafe writev implementation!" << frg::endlog;
 	size_t bytes = 0;
 	for(int i = 0; i < iovc; i++) {
 		if(SSIZE_MAX - bytes < iovs[i].iov_len) {
diff --git mlibc-clean/options/posix/generic/unistd.cpp mlibc-workdir/options/posix/generic/unistd.cpp
index 8783885..afb3157 100644
--- mlibc-clean/options/posix/generic/unistd.cpp
+++ mlibc-workdir/options/posix/generic/unistd.cpp
@@ -1134,6 +1134,19 @@ int dup2(int fd, int newfd) {
 	return newfd;
 }
 
+int dup3(int oldfd, int newfd, int flags) {
+	if(oldfd == newfd) {
+		errno = EINVAL;
+		return -1;
+	}
+	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_dup2, -1);
+	if(int e = mlibc::sys_dup2(oldfd, flags, newfd); e) {
+		errno = e;
+		return -1;
+	}
+	return newfd;
+}
+
 pid_t fork(void) {
 	auto self = mlibc::get_current_tcb();
 	pid_t child;
diff --git mlibc-clean/options/posix/include/bits/posix/stat.h mlibc-workdir/options/posix/include/bits/posix/stat.h
index 430f8a6..40e01f3 100644
--- mlibc-clean/options/posix/include/bits/posix/stat.h
+++ mlibc-workdir/options/posix/include/bits/posix/stat.h
@@ -14,6 +14,9 @@
 #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
 #define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
 #define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+#define S_TYPEISMQ(m) (((m) & S_IFMT) == S_IMQ)
+#define S_TYPEISSEM(m) (((m) & S_IFMT) == S_ISEM)
+#define S_TYPEISSHM(m) (((m) & S_IFMT) == S_ISHM)
 
 /* POSIX compatibility macros */
 #define st_atime st_atim.tv_sec
diff --git mlibc-clean/options/posix/include/dirent.h mlibc-workdir/options/posix/include/dirent.h
index b819c30..5577aff 100644
--- mlibc-clean/options/posix/include/dirent.h
+++ mlibc-workdir/options/posix/include/dirent.h
@@ -17,14 +17,16 @@ extern "C" {
 #endif
 
 #define DT_UNKNOWN 0
-#define DT_FIFO 1
-#define DT_CHR 2
-#define DT_DIR 4
-#define DT_BLK 6
-#define DT_REG 8
-#define DT_LNK 10
-#define DT_SOCK 12
-#define DT_WHT 14
+#define DT_FIFO    1
+#define DT_CHR     2
+#define DT_DIR     4
+#define DT_BLK     6
+#define DT_REG     8
+#define DT_LNK     10
+#define DT_SOCK    12
+#define DT_MQ      14
+#define DT_SEM     16
+#define DT_SHM     18
 
 /* The character array d_name is of unspecified size, but the number of bytes preceding
  * the terminating null byte will not exceed {NAME_MAX}. */
diff --git mlibc-clean/options/posix/include/unistd.h mlibc-workdir/options/posix/include/unistd.h
index bf4eb83..8223948 100644
--- mlibc-clean/options/posix/include/unistd.h
+++ mlibc-workdir/options/posix/include/unistd.h
@@ -268,6 +268,7 @@ size_t confstr(int __name, char *__buf, size_t __size);
 char *ctermid(char *__s);
 int dup(int __fd);
 int dup2(int __src_fd, int __dest_fd);
+int dup3(int __fd, int __newfd, int __flags);
 __attribute__((__noreturn__)) void _exit(int __status);
 void endusershell(void);
 int execl(const char *__path, const char *__arg, ...);
diff --git mlibc-clean/options/rtld/generic/main.cpp mlibc-workdir/options/rtld/generic/main.cpp
index 6c92521..0d2ecae 100644
--- mlibc-clean/options/rtld/generic/main.cpp
+++ mlibc-workdir/options/rtld/generic/main.cpp
@@ -475,7 +475,7 @@ extern "C" void *interpreterMain(uintptr_t *entry_stack) {
 	// Handle the LD_LIBRARY_PATH and LD_PRELOAD environment variables.
 	// This is done here as it needs to know if rtldConfig.secureRequired is set.
 	if (rtldConfig.secureRequired) {
-		mlibc::infoLogger() << "rtld: running in secure mode" << frg::endlog;
+		// mlibc::infoLogger() << "rtld: running in secure mode" << frg::endlog;
 	} else {
 		if (env_ld_library_path) {
 			for(auto path : parseList(env_ld_library_path, ":;"))
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index 1975812..bb57e2e 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -83,6 +83,12 @@ int sys_open(const char *path, int flags, mode_t mode, int *fd) {
 int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 	int ret, errno;
 
+	// Check clashing sysdep-implemented files here before we do anything else.
+	if ((flags & O_CREAT) && ((flags & O_WRONLY) == 0)) {
+		return EISDIR;
+	}
+
+	// Attempt to open.
 	int path_len = strlen(path);
 	SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
 
@@ -94,7 +100,6 @@ int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 		return EEXIST;
 	}
 
-	// We implement creating files in this sysdep.
 	if ((errno == ENOENT) && (flags & O_CREAT) && ((flags & O_DIRECTORY) == 0)) {
 		SYSCALL5(SYSCALL_MAKENODE, AT_FDCWD, path, path_len, S_IFREG | mode, 0);
 		if (ret == -1) {
@@ -620,40 +625,46 @@ int sys_kill(int pid, int sig) {
 
 int sys_dup(int fd, int flags, int *newfd) {
 	int ret, errno;
-	if (flags & O_CLOEXEC) {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, 0);
-	} else {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
-	}
-
-	*newfd = ret;
+	SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
 
-	if (errno == 0) {
-		SYSCALL3(SYSCALL_FCNTL, *newfd, F_SETFD, flags);
+	if (errno == 0 && flags != 0) {
+		int fcntl_flags = 0;
+		if (flags & O_CLOEXEC) {
+			fcntl_flags |= FD_CLOEXEC;
+		}
+		if (flags & O_CLOFORK) {
+			fcntl_flags |= FD_CLOFORK;
+		}
+		SYSCALL3(SYSCALL_FCNTL, ret, F_SETFD, fcntl_flags);
 	}
 
+	*newfd = ret;
 	return errno;
 }
 
 int sys_dup2(int fd, int flags, int newfd) {
+	// We are to do nothing if they are equal.
+	if (fd == newfd) {
+		return 0;
+	}
+
 	int ret = sys_close(newfd);
 	if (ret != 0 && ret != EBADF) {
 		return EBADF;
 	}
 
 	int errno;
-	if (flags & O_CLOEXEC) {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
-	} else {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
-	}
+	SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
 
-	if (ret != -1 && ret != newfd) {
-		return EBADF;
-	}
-
-	if (errno == 0) {
-		SYSCALL3(SYSCALL_FCNTL, newfd, F_SETFD, flags);
+	if (errno == 0 && flags != 0) {
+		int fcntl_flags = 0;
+		if (flags & O_CLOEXEC) {
+			fcntl_flags |= FD_CLOEXEC;
+		}
+		if (flags & O_CLOFORK) {
+			fcntl_flags |= FD_CLOFORK;
+		}
+		SYSCALL3(SYSCALL_FCNTL, ret, F_SETFD, fcntl_flags);
 	}
 
 	return errno;
