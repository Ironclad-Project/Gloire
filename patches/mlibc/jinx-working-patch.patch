diff --git mlibc-clean/abis/ironclad/fcntl.h mlibc-workdir/abis/ironclad/fcntl.h
index d1e9f02..397a69d 100644
--- mlibc-clean/abis/ironclad/fcntl.h
+++ mlibc-workdir/abis/ironclad/fcntl.h
@@ -1,51 +1,55 @@
 #ifndef _ABIBITS_FCNTL_H
 #define _ABIBITS_FCNTL_H
 
-// reserve 3 bits for the access mode
-#define O_ACCMODE 0x0007
-#define O_RDONLY 1
-#define O_WRONLY 2
-#define O_RDWR   3
-#define O_SEARCH 4
-#define O_EXEC   7
+// Flags supported by the kernel.
+#define O_ACCMODE   0b000011
+#define O_RDONLY    00000001
+#define O_WRONLY    0b000010
+#define O_RDWR      0b000011
+#define O_APPEND    0b000100
+#define O_CLOEXEC   0b001000
+#define O_NOFOLLOW  0b010000
+#define O_NONBLOCK  0b100000
 
-// This flags are stubs.
-#define O_APPEND 0x00008
-#define O_CREAT 0x00010
-#define O_DIRECTORY 0x00020
-#define O_EXCL 0x00040
-#define O_NOCTTY 0x00080
-#define O_NOFOLLOW 0x00100
-#define O_TRUNC 0x00200
-#define O_NONBLOCK 0x00400
-#define O_DSYNC 0x00800
-#define O_RSYNC 0x01000
-#define O_SYNC 0x02000
-#define O_CLOEXEC 0x04000
-#define O_PATH 0x08000
-#define O_LARGEFILE 0x10000
-#define O_NOATIME 0x20000
-#define O_TMPFILE 0x40000
+// Flags emulated by userland, we just have to make sure they dont overlap with
+// kernel flags.
+#define O_CREAT 0b0010000000
+#define O_EXCL  0b0100000000
+#define O_TRUNC 0b1000000000
 
-// The constants below are copied from abis/mlibc/fcntl.h.
+// Stubbed flags, the value really doesnt matter as long as they dont overlap
+// with usable ones.
+// Implemented here as some software needs them to compile.
+#define O_SEARCH    0b000000000010000000000
+#define O_EXEC      0b000000000100000000000
+#define O_NOCTTY    0b000000001000000000000
+#define O_DSYNC     0b000000010000000000000
+#define O_RSYNC     0b000000100000000000000
+#define O_SYNC      0b000001000000000000000
+#define O_PATH      0b000010000000000000000
+#define O_DIRECTORY 0b000100000000000000000
+#define O_LARGEFILE 0b001000000000000000000
+#define O_NOATIME   0b010000000000000000000
+#define O_TMPFILE   0b100000000000000000000
+
+// Fcntl flags.
+#define FD_CLOEXEC 1
+#define F_GETFD    3
+#define F_SETFD    4
+#define F_GETFL    5
+#define F_SETFL    6
+
+// Stubbed fcntl flags.
 #define F_DUPFD 1
 #define F_DUPFD_CLOEXEC 2
-#define F_GETFD 3
-#define F_SETFD 4
-#define F_GETFL 5
-#define F_SETFL 6
 #define F_GETLK 7
 #define F_SETLK 8
 #define F_SETLKW 9
 #define F_GETOWN 10
 #define F_SETOWN 11
-
 #define F_RDLCK 1
 #define F_UNLCK 2
 #define F_WRLCK 3
-
-#define FD_CLOEXEC 1
-
 #define F_SEAL_SHRINK 0x0002
 #define F_SEAL_GROW   0x0004
 #define F_SEAL_WRITE  0x0008
@@ -53,12 +57,19 @@
 #define F_ADD_SEALS   1033
 #define F_GET_SEALS   1034
 
-#define AT_EMPTY_PATH 1
-#define AT_SYMLINK_FOLLOW 2
-#define AT_SYMLINK_NOFOLLOW 4
-#define AT_REMOVEDIR 8
-#define AT_EACCESS 512
+// At flags.
+#define AT_REMOVEDIR        500
+#define AT_EACCESS          512
+#define AT_FDCWD            0x7FFFFFFF
+#define AT_EMPTY_PATH       1
+#define AT_SYMLINK_FOLLOW   0
+#define AT_SYMLINK_NOFOLLOW 2
 
-#define AT_FDCWD -100
+#define POSIX_FADV_NORMAL 1
+#define POSIX_FADV_SEQUENTIAL 2
+#define POSIX_FADV_NOREUSE 3
+#define POSIX_FADV_DONTNEED 4
+#define POSIX_FADV_WILLNEED 5
+#define POSIX_FADV_RANDOM 6
 
 #endif // _ABIBITS_FCNTL_H
diff --git mlibc-clean/meson.build mlibc-workdir/meson.build
index 1f8a8ca..01ebd25 100644
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -137,7 +137,7 @@ elif host_machine.system() == 'managarm'
 	internal_conf.set10('MLIBC_MAP_FILE_WINDOWS', true)
 	subdir('sysdeps/managarm')
 elif host_machine.system() == 'ironclad'
-	# disable_linux_option = true
+	disable_linux_option = true
 	rtdl_include_dirs += include_directories('sysdeps/ironclad/include')
 	libc_include_dirs += include_directories('sysdeps/ironclad/include')
 	subdir('sysdeps/ironclad')
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..6e87ed8 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -1,6 +1,7 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
 
+/*
 int backtrace(void **, int) {
 	__ensure(!"Not implemented");
 	__builtin_unreachable();
@@ -15,3 +16,4 @@ void backtrace_symbols_fd(void *const *, int, int) {
 	__ensure(!"Not implemented");
 	__builtin_unreachable();
 }
+*/
diff --git mlibc-clean/options/linux/generic/pty-stubs.cpp mlibc-workdir/options/linux/generic/pty-stubs.cpp
index 513c4bc..f5da649 100644
--- mlibc-clean/options/linux/generic/pty-stubs.cpp
+++ mlibc-workdir/options/linux/generic/pty-stubs.cpp
@@ -9,40 +9,17 @@
 #include <unistd.h>
 #include <stdlib.h>
 
+#include <sys/syscall.h>
 #include <mlibc/debug.hpp>
 #include <mlibc/linux-sysdeps.hpp>
 
 int openpty(int *mfd, int *sfd, char *name, const struct termios *ios, const struct winsize *win) {
-	__ensure(!ios);
-
-	if (win) {
-		mlibc::infoLogger() << "mlibc: openpty ignores win argument" << frg::endlog;
-	}
-
-	// FIXME: Close the master FD if the slave open fails.
-
-	int ptmx_fd;
-	if(int e = mlibc::sys_open("/dev/ptmx", O_RDWR | O_NOCTTY, 0, &ptmx_fd); e) {
-		errno = e;
-		return -1;
-	}
-
-	char spath[32];
-	if(!name)
-		name = spath;
-	if(ptsname_r(ptmx_fd, name, 32))
-		return -1;
-
-	int pts_fd;
-	unlockpt(ptmx_fd);
-	if(int e = mlibc::sys_open(spath, O_RDWR | O_NOCTTY, 0, &pts_fd); e) {
-		errno = e;
-		return -1;
-	}
-
-	*mfd = ptmx_fd;
-	*sfd = pts_fd;
-	return 0;
+   int errno, ret;
+   int fds[2];
+   SYSCALL3(SYSCALL_OPENPTY, fds, ios, win);
+   *mfd = fds[0];
+   *sfd = fds[1];
+   return ret;
 }
 
 int login_tty(int fd) {
diff --git mlibc-clean/options/posix/generic/dirent-stubs.cpp mlibc-workdir/options/posix/generic/dirent-stubs.cpp
index 1352585..6ae1cf3 100644
--- mlibc-clean/options/posix/generic/dirent-stubs.cpp
+++ mlibc-workdir/options/posix/generic/dirent-stubs.cpp
@@ -66,14 +66,14 @@ DIR *opendir(const char *path) {
 }
 struct dirent *readdir(DIR *dir) {
 	__ensure(dir->__ent_next <= dir->__ent_limit);
-	if(dir->__ent_next == dir->__ent_limit) {
+	if(dir->__ent_next == 0 && dir->__ent_limit == 0) {
 		MLIBC_CHECK_OR_ENOSYS(mlibc::sys_read_entries, nullptr);
-		if(int e = mlibc::sys_read_entries(dir->__handle, dir->__ent_buffer, 2048, &dir->__ent_limit); e)
+		if(int e = mlibc::sys_read_entries(dir->__handle, dir->__ent_buffer, __DIR_BUFFER_LEN, &dir->__ent_limit); e)
 			__ensure(!"mlibc::sys_read_entries() failed");
 		dir->__ent_next = 0;
-		if(!dir->__ent_limit)
-			return nullptr;
-	}
+	} else if (dir->__ent_next == dir->__ent_limit) {
+	   return nullptr;
+   }
 
 	auto entp = reinterpret_cast<struct dirent *>(dir->__ent_buffer + dir->__ent_next);
 	// We only copy as many bytes as we need to avoid buffer-overflows.
@@ -89,7 +89,7 @@ int readdir_r(DIR *dir, struct dirent *entry, struct dirent **result) {
 
 	__ensure(dir->__ent_next <= dir->__ent_limit);
 	if(dir->__ent_next == dir->__ent_limit) {
-		if(int e = mlibc::sys_read_entries(dir->__handle, dir->__ent_buffer, 2048, &dir->__ent_limit); e)
+		if(int e = mlibc::sys_read_entries(dir->__handle, dir->__ent_buffer, __DIR_BUFFER_LEN, &dir->__ent_limit); e)
 			__ensure(!"mlibc::sys_read_entries() failed");
 		dir->__ent_next = 0;
 		if(!dir->__ent_limit) {
diff --git mlibc-clean/options/posix/generic/unistd-stubs.cpp mlibc-workdir/options/posix/generic/unistd-stubs.cpp
index 786671c..0ea29c5 100644
--- mlibc-clean/options/posix/generic/unistd-stubs.cpp
+++ mlibc-workdir/options/posix/generic/unistd-stubs.cpp
@@ -685,13 +685,8 @@ unsigned long sysconf(int number) {
 		case _SC_PAGE_SIZE:
 			return mlibc::page_size;
 		case _SC_OPEN_MAX:
-			struct rlimit ru;
-			if (getrlimit(RLIMIT_NOFILE, &ru) < 0) {
-				mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns arbitrary value 256\e[39m" << frg::endlog;
-				return 256;
-			} else {
-				return (ru.rlim_cur == RLIM_INFINITY) ? -1 : ru.rlim_cur;
-			}
+			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns arbitrary value 100\e[39m" << frg::endlog;
+			return 100;
 		case _SC_PHYS_PAGES:
 			// TODO: actually return a proper value for _SC_PHYS_PAGES
 			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_PHYS_PAGES) returns arbitrary value 1024\e[39m" << frg::endlog;
diff --git mlibc-clean/options/posix/include/dirent.h mlibc-workdir/options/posix/include/dirent.h
index b50566d..bdb807b 100644
--- mlibc-clean/options/posix/include/dirent.h
+++ mlibc-workdir/options/posix/include/dirent.h
@@ -39,12 +39,12 @@ struct dirent64 {
 #undef __MLIBC_DIRENT_BODY
 
 #define IFTODT(mode) (((mode) & 0170000) >> 12)
-
+#define __DIR_BUFFER_LEN (2048 * 20)
 struct __mlibc_dir_struct {
 	int __handle;
 	__mlibc_size __ent_next;
 	__mlibc_size __ent_limit;
-	char __ent_buffer[2048];
+	char __ent_buffer[__DIR_BUFFER_LEN];
 	struct dirent __current;
 };
 
diff --git mlibc-clean/options/rtdl/generic/linker.cpp mlibc-workdir/options/rtdl/generic/linker.cpp
index 003a162..8e04b03 100644
--- mlibc-clean/options/rtdl/generic/linker.cpp
+++ mlibc-workdir/options/rtdl/generic/linker.cpp
@@ -516,9 +516,9 @@ void ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
 						phdr->p_filesz);
 			#endif
 			// Take care of removing superfluous permissions.
-			if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
-				if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
-					mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
+			//if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
+			//	if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
+			//		mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
 		}else if(phdr->p_type == PT_TLS) {
 			object->tlsSegmentSize = phdr->p_memsz;
 			object->tlsAlignment = phdr->p_align;
diff --git mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S
new file mode 100644
index 0000000..911b078
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S
new file mode 100644
index 0000000..0187e50
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index d6dbca3..89b61a5 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -10,24 +10,23 @@
 #include <string.h>
 #include <stdio.h>
 #include <sys/syscall.h>
+#include <sys/ironclad_devices.h>
+#include <sched.h>
+#include <sys/mman.h>
 
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-	/*
 	ssize_t unused;
 	char new_line = '\n';
-	sys_write(1, message, strlen(message), &unused);
-	sys_write(1, &new_line, 1, &unused);
-	*/
-	(void)message;
-	return;
+	sys_write(2, message, strlen(message), &unused);
+	sys_write(2, &new_line, 1, &unused);
 }
 
 void sys_libc_panic() {
 	ssize_t unused;
 	char const *message = "mlibc panicked unrecoverably\n";
-	sys_write(1, message, strlen(message), &unused);
+	sys_write(2, message, strlen(message), &unused);
 	sys_exit(1);
 }
 
@@ -39,15 +38,37 @@ void sys_exit(int status) {
 
 int sys_tcb_set(void *pointer) {
 	int ret, errno;
-	SYSCALL1(SYSCALL_SET_TCB, pointer);
+	SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
 	return errno;
 }
 
 int sys_open(const char *path, int flags, mode_t mode, int *fd) {
+	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 	int ret, errno;
-	(void)mode;
 
-	SYSCALL2(SYSCALL_OPEN, path, flags);
+	int path_len = strlen (path);
+	SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
+	if (ret != -1 && (flags & O_EXCL)) {
+	    SYSCALL1(SYSCALL_CLOSE, ret);
+	    return EEXIST;
+	}
+
+	if (ret == -1 && (flags & O_CREAT)) {
+	    SYSCALL5(SYSCALL_MAKENODE, AT_FDCWD, path, path_len, mode, 0);
+       if (ret == -1) {
+           return errno;
+       }
+	    SYSCALL4(SYSCALL_OPEN,   AT_FDCWD, path, path_len, flags);
+	} else if (ret != -1 && (flags & O_TRUNC)) {
+		// If the file cannot be truncated, dont sweat it, some software
+		// depends on some things being truncate-able that ironclad does not
+		// allow. For example, some devices.
+		sys_ftruncate(ret, 0);
+	}
+
 	*fd = ret;
 	return errno;
 }
@@ -56,12 +77,50 @@ int sys_open_dir(const char *path, int *handle) {
 	return sys_open(path, O_RDONLY, 0660, handle);
 }
 
+int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
+	size_t ret;
+	int errno;
+	SYSCALL3(SYSCALL_GETDENTS, handle, buffer, max_size);
+	if (errno != 0) {
+		return errno;
+	} else {
+		*bytes_read = ret;
+		return 0;
+	}
+}
+
+void sys_thread_exit() {
+    int ret, errno;
+    SYSCALL0(SYSCALL_EXIT_THREAD);
+    __builtin_unreachable();
+}
+
 int sys_close(int fd) {
 	int ret, errno;
 	SYSCALL1(SYSCALL_CLOSE, fd);
 	return errno;
 }
 
+void sys_sync() {
+   int ret, errno;
+   SYSCALL0(SYSCALL_SYNC);
+   if (ret != 0) {
+      sys_libc_log("mlibc: sync failed");
+   }
+}
+
+int sys_fsync(int fd) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_FSYNC, fd, 0);
+   return errno;
+}
+
+int sys_fdatasync(int fd) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_FSYNC, fd, 1);
+   return errno;
+}
+
 int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
 	ssize_t ret;
 	int errno;
@@ -86,6 +145,12 @@ int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
 	return errno;
 }
 
+int sys_ftruncate (int fd, size_t size) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_TRUNCATE, fd, size);
+   return errno;
+}
+
 int sys_anon_allocate(size_t size, void **pointer) {
 	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON, 0, 0, pointer);
 }
@@ -113,6 +178,16 @@ int sys_vm_unmap(void *pointer, size_t size) {
 	}
 }
 
+int sys_vm_protect(void *pointer, size_t size, int prot) {
+	int ret;
+	int errno;
+	SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
+	if (ret != 0) {
+		return errno;
+	}
+	return 0;
+}
+
 pid_t sys_getpid() {
 	pid_t ret;
 	int errno;
@@ -131,100 +206,65 @@ int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *old
 	(void)signum;
 	(void)act;
 	(void)oldact;
-	mlibc::infoLogger() << "sigaction() is a stub" << frg::endlog;
+	// FIXME: Stub.
 	return 0;
 }
 
+int sys_ptrace(long req, pid_t pid, void *addr, void *data, long *out) {
+	int ret, errno;
+	SYSCALL4(SYSCALL_PTRACE, req, pid, addr, data);
+	*out = (long)ret;
+	return errno;
+}
+
 int sys_fcntl(int fd, int request, va_list args, int *result) {
-	(void)fd;
-	(void)request;
-	(void)args;
-	(void)result;
-	mlibc::infoLogger() << "fcntl() is a stub!" << frg::endlog;
-	return 0;
+	int ret, errno;
+	SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
+	*result = ret;
+	return errno;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
 	(void)how;
 	(void)set;
 	(void)retrieve;
-	mlibc::infoLogger() << "sigprocmask() is a stub!" << frg::endlog;
-	return ENOSYS;
-}
-
-int sys_ttyname(int fd, char *buf, size_t size) {
-	(void)fd;
-	(void)buf;
-	(void)size;
-	mlibc::infoLogger() << "ttyname() is a stub!" << frg::endlog;
+	// FIXME: Stub.
 	return ENOSYS;
 }
 
-int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid;
-	(void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
-	return 0;
-}
-
-int sys_pselect(int num_fds, fd_set *read_set, fd_set *write_set, fd_set *except_set,
-	const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
-	(void)num_fds;
-	(void)read_set;
-	(void)write_set;
-	(void)except_set;
-	(void)timeout;
-	(void)sigmask;
-	(void)num_events;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
-}
-
 int sys_isatty(int fd) {
-	(void)fd;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
-}
-
-uid_t sys_getuid() {
-	mlibc::infoLogger() << "getuid() is a stub" << frg::endlog;
-	return 0;
-}
-
-uid_t sys_geteuid() {
-	mlibc::infoLogger() << "geteuid() is a stub" << frg::endlog;
-	return 0;
+	struct termios t;
+	if (sys_tcgetattr(fd, &t) == 0) {
+		return 0;
+	} else {
+		return ENOTTY;
+	}
 }
 
 gid_t sys_getgid() {
-	mlibc::infoLogger() << "getgid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 gid_t sys_getegid() {
-	mlibc::infoLogger() << "getegid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
 	(void)pid;
-	mlibc::infoLogger() << "getpgid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	*pgid = 0;
 	return 0;
 }
 
-int sys_clock_get(int clock, time_t *secs, long *nanos) {
-	(void)clock;
-	(void)secs;
-	(void)nanos;
-	mlibc::infoLogger() << "clock_get() is a stub" << frg::endlog;
-	return 0;
-}
-
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
-	int ret, errno;
+	int ret, errno, argv_len, envp_len;
+   for (argv_len = 0; argv[argv_len] != NULL; argv_len++);
+   for (envp_len = 0; envp[envp_len] != NULL; envp_len++);
 
-	SYSCALL3(SYSCALL_EXEC, path, argv, envp);
+   size_t path_len = strlen (path);
+	SYSCALL6(SYSCALL_EXEC, path, path_len, argv, argv_len, envp, envp_len);
 
 	if (ret == -1) {
 		return errno;
@@ -234,17 +274,20 @@ int sys_execve(const char *path, char *const argv[], char *const envp[]) {
 }
 
 int sys_fork(pid_t *child) {
-    pid_t ret;
-    int errno;
+	pid_t ret;
+	int errno;
 
-    SYSCALL0(SYSCALL_FORK);
+	SYSCALL5(SYSCALL_CLONE, 0, 0, 0, 0, 0);
 
-    if (ret == -1) {
-        return errno;
-    }
+	if (ret == -1) {
+		return errno;
+	}
 
-    *child = ret;
-    return 0;
+	if (child != NULL) {
+		*child = ret;
+	}
+
+	return 0;
 }
 
 int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
@@ -263,7 +306,7 @@ int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret
 	}
 
 	*ret_pid = ret;
-	return 0;
+	return errno;
 }
 
 int sys_uname(struct utsname *buf) {
@@ -278,6 +321,17 @@ int sys_uname(struct utsname *buf) {
 	return 0;
 }
 
+int sys_setpgid(pid_t pid, pid_t pgid) {
+	(void)pid;
+	(void)pgid;
+	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+	return 0;
+}
+
+int sys_ttyname(int, char *, size_t) {
+	return ENOSYS;
+}
+
 int sys_sethostname(const char *buff, size_t size) {
 	int ret, errno;
 
@@ -290,7 +344,7 @@ int sys_sethostname(const char *buff, size_t size) {
 	return 0;
 }
 
-int sys_getcwd(const char *buff, size_t size) {
+int sys_getcwd(char *buff, size_t size) {
 	char* ret;
 	int errno;
 
@@ -306,7 +360,7 @@ int sys_getcwd(const char *buff, size_t size) {
 int sys_chdir(const char *buff) {
 	int ret, errno;
 
-	SYSCALL1(SYSCALL_CHDIR, buff);
+	SYSCALL2(SYSCALL_CHDIR, buff, strlen(buff));
 
 	if (ret == -1) {
 		return errno;
@@ -328,46 +382,39 @@ int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
 	return 0;
 }
 
-int sys_sched_yield(void) {
+void sys_yield(void) {
 	int ret, errno;
-
 	SYSCALL0(SYSCALL_SCHED_YIELD);
-
-	if (ret == -1) {
-		return errno;
-	}
-
-	return 0;
 }
 
 int sys_dup(int fd, int flags, int *newfd) {
-	(void)flags;
-
 	int ret, errno;
-
-	SYSCALL1(SYSCALL_DUP, fd);
-
-	if (ret == -1) {
-        return errno;
-	}
+	if (flags & O_CLOEXEC) {
+		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, 0);
+	} else {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
+   }
 	*newfd = ret;
-	return 0;
+	return errno;
 }
 
 int sys_dup2(int fd, int flags, int newfd) {
-	int ret, errno;
+   if (sys_close(newfd) != 0) {
+       return EBADFD;
+   }
 
-	if (flags) {
-		SYSCALL3(SYSCALL_DUP3, fd, newfd, flags);
+	int ret, errno;
+	if (flags & O_CLOEXEC) {
+		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
 	} else {
-		SYSCALL2(SYSCALL_DUP2, fd, newfd);
-	}
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
+   }
 
-	if (ret == -1) {
-        return errno;
-	} else {
-		return 0;
-	}
+   if (ret != -1 && ret != newfd) {
+      return EBADFD;
+   } else {
+      return errno;
+   }
 }
 
 int sys_tcgetattr(int fd, struct termios *attr) {
@@ -401,58 +448,286 @@ int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
     return 0;
 }
 
+int sys_pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+                const struct timespec *timeout, const sigset_t *sigmask,
+                int *num_events) {
+    return 0;
+}
+
 int sys_access(const char *path, int mode) {
+	return sys_faccessat(AT_FDCWD, path, mode, 0);
+}
+
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
+	(void)flags;
+	struct stat buf;
+	if (int r = sys_stat(fsfd_target::fd_path, dirfd, pathname, mode & AT_SYMLINK_FOLLOW, &buf)) {
+		return r;
+	}
+	return 0;
+}
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+	(void)pointer;
+	(void)expected;
+	(void)time;
+	return 0;
+}
+
+int sys_futex_wake(int *pointer) {
+	(void)pointer;
+	return 0;
+}
+
+int sys_pipe(int *fds, int flags) {
+   int ret, errno;
+	SYSCALL2(SYSCALL_PIPE, fds, flags);
+	return errno;
+}
+
+int sys_getentropy(void *buffer, size_t length) {
+	ssize_t ret;
+	int errno;
+	SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
+	return errno;
+}
+
+int sys_mkdir(const char *path, mode_t mode) {
+	return sys_mkdirat(AT_FDCWD, path, mode);
+}
+
+int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
 	int ret, errno;
+	size_t path_len = strlen (path);
+	SYSCALL5(SYSCALL_MAKENODE, dirfd, path, path_len, S_IFDIR | mode, 0);
+	return errno;
+}
 
-	SYSCALL2(SYSCALL_ACCESS, path, mode);
+int sys_rmdir(const char* path){
+	int ret, errno;
+	size_t path_len = strlen (path);
+	SYSCALL3(SYSCALL_UNLINK, AT_FDCWD, path, path_len);
+	return errno;
+}
 
-	if (ret == -1) {
-        return errno;
-	} else {
-        return 0;
-   }
+int sys_unlinkat(int fd, const char *path, int flags) {
+	int ret, errno;
+	size_t path_len = strlen (path);
+	SYSCALL3(SYSCALL_UNLINK, fd, path, path_len);
+	return errno;
 }
 
-int sys_getpriority(int which, id_t who, int *value) {
+int sys_link(const char* srcpath, const char* destpath) {
 	int ret, errno;
+	size_t src_len = strlen (srcpath);
+   size_t dst_len = strlen (destpath);
+	SYSCALL6(SYSCALL_LINK, AT_FDCWD, srcpath, src_len, AT_FDCWD, destpath, dst_len);
+	return errno;
+}
 
-	SYSCALL2(SYSCALL_GETPRIORITY, which, who);
+int sys_socket(int domain, int type, int protocol, int *fd) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_SOCKET, domain, type, protocol);
+	if (ret != -1) {
+      *fd = ret;
+      return 0;
+   } else {
+      return errno;
+   }
+}
 
-	if (ret == -1 && errno != 0) {
-        return errno;
-	} else {
-			*value = ret;
-        return 0;
+uid_t sys_getuid() {
+	uint64_t ret, errno;
+	SYSCALL0(SYSCALL_GETUID);
+   return (uid_t)ret;
+}
+
+uid_t sys_geteuid() {
+	uint64_t ret, errno;
+	SYSCALL0(SYSCALL_GETEUID);
+   return (uid_t)ret;
+}
+
+int sys_setuid(uid_t uid) {
+	int ret, errno;
+   if (uid == 0) {
+	    SYSCALL2(SYSCALL_SETUIDS, uid, uid);
+   } else {
+       SYSCALL2(SYSCALL_SETUIDS, uid, ((uint64_t)-1));
    }
+   return ret;
 }
 
-int sys_setpriority(int which, id_t who, int prio) {
+int sys_seteuid(uid_t euid) {
 	int ret, errno;
+	SYSCALL2(SYSCALL_SETUIDS, ((uint64_t)-1), euid);
+   return ret;
+}
 
-	SYSCALL3(SYSCALL_SETPRIORITY, which, who, prio);
+#ifndef MLIBC_BUILDING_RTDL
 
-	if (ret == -1) {
+extern "C" void __mlibc_thread_entry();
+
+int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
+    int ret, errno;
+    SYSCALL5(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb);
+
+    if (ret == -1) {
         return errno;
-	} else {
-        return 0;
+    }
+
+    *tid_out = (pid_t)ret;
+    return 0;
+}
+
+int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	// TODO guard
+
+	mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+
+	*guard_size = 0;
+   *stack_size = *stack_size ? *stack_size : 0x400000;
+
+	if (!*stack) {
+		*stack = (void *)((char *)mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size);
+		if (*stack == MAP_FAILED) {
+			return errno;
+		}
+	}
+
+	void **stack_it = (void **)*stack;
+
+	*--stack_it = arg;
+	*--stack_it = tcb;
+	*--stack_it = entry;
+
+	*stack = (void *)stack_it;
+
+	return 0;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+   static int rtc_fd = -1;
+
+	switch (clock) {
+		case CLOCK_REALTIME: {
+			// Use the RTC interface, there is no native kernel entity.
+			// RTC gives true month and year, substract to make epoch.
+			int ret;
+			struct rtc_time rtc;
+			struct tm tm;
+         if (rtc_fd == -1) {
+            sys_open("/dev/rtc", O_RDONLY, 0, &rtc_fd);
+         }
+			if (sys_ioctl(rtc_fd, RTC_RD_TIME, &rtc, &ret))
+			{
+				return -1;
+			}
+			tm = {
+				.tm_sec  = rtc.tm_sec,
+				.tm_min  = rtc.tm_min,
+				.tm_hour = rtc.tm_hour,
+				.tm_mday = rtc.tm_mday,
+				.tm_mon  = rtc.tm_mon  - 1,
+				.tm_year = rtc.tm_year - 1900,
+				.tm_wday = rtc.tm_wday,
+				.tm_yday = rtc.tm_yday,
+				.tm_isdst = rtc.tm_isdst
+			};
+			*nanos = 0;
+			*secs  = mktime(&tm);
+			return 0;
+		}
+		default:
+			return -1;
+	}
+}
+
+int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addrlen) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_BIND, fd, addr_ptr, addrlen);
+	return errno;
+}
+
+int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addrlen) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_CONNECT, fd, addr_ptr, addrlen);
+	return errno;
+}
+
+int sys_listen(int fd, int backlog) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_LISTEN, fd, backlog);
+	return errno;
+}
+
+int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length) {
+	int ret, errno;
+	SYSCALL4(SYSCALL_ACCEPT, fd, addr_ptr, addr_length, 0);
+   if (ret != -1) {
+      *newfd = ret;
+      return 0;
+   } else {
+	   return errno;
    }
 }
 
-int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-	(void)pointer;
-	(void)expected;
-	(void)time;
-	__ensure(!"sys_futex is a stub!");
-	__builtin_unreachable();
+int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
+   if (flags != 0 || hdr->msg_control != NULL || hdr->msg_name != NULL) {
+      mlibc::infoLogger() << "mlibc: recv() was invalid!" << frg::endlog;
+      return EINVAL;
+   }
+
+   size_t ret, count = 0;
+   int errno;
+   for (size_t i = 0; i < hdr->msg_iovlen; i++) {
+      SYSCALL3(SYSCALL_READ, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len);
+      if (ret == -1) {
+         return errno;
+      }
+      count += ret;
+   }
+
+   *length = count;
+   return 0;
 }
 
-int sys_futex_wake(int *pointer) {
-	(void)pointer;
-	__ensure(!"sys_futex is a stub!");
-	__builtin_unreachable();
+int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
+   if (flags != 0 || hdr->msg_control != NULL || hdr->msg_name != NULL) {
+      mlibc::infoLogger() << "mlibc: recv() was invalid!" << frg::endlog;
+      return EINVAL;
+   }
+
+   size_t ret, count = 0;
+   int errno;
+   for (size_t i = 0; i < hdr->msg_iovlen; i++) {
+      SYSCALL3(SYSCALL_WRITE, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len);
+      if (ret == -1) {
+         return errno;
+      }
+      count += ret;
+   }
+
+   *length = count;
+   return 0;
 }
 
-#ifndef MLIBC_BUILDING_RTDL
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
+	int ret, errno;
+	SYSCALL3(SYSCALL_POLL, fds, count, timeout);
+   if (ret == -1) {
+      return errno;
+   }
+
+   *num_events = ret;
+	return errno;
+}
+
+int sys_sleep(time_t *secs, long *nanos) {
+	*secs  = 0;
+	*nanos = 0;
+	return 0;
+}
 
 int sys_gethostname(char *buffer, size_t bufsize) {
 	struct utsname buf;
@@ -465,24 +740,29 @@ int sys_gethostname(char *buffer, size_t bufsize) {
 }
 
 int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
-	int ret, errno;
+	int ret, errno, fd2;
 	(void)flags;
 
 	switch (fsfdt) {
 		case fsfd_target::fd: {
-			// mlibc wants us to do a fstat.
-			SYSCALL2(SYSCALL_FSTAT, fd, statbuf);
+			SYSCALL2(SYSCALL_STAT, fd, statbuf);
 			return errno;
 		}
 		case fsfd_target::path: {
-			// mlibc wants us to do a lstat.
-			SYSCALL2(SYSCALL_LSTAT, path, statbuf);
+         if (sys_open(path, O_RDONLY | O_NOFOLLOW, 0777, &fd2)) {
+            return ENOENT;
+         }
+			SYSCALL2(SYSCALL_STAT, fd2, statbuf);
+         sys_close(fd2);
 			return errno;
 		}
 		case fsfd_target::fd_path: {
-			// mlibc wants us to do an fstatat
-			__ensure(!"stat: Invalid fstatat");
-			__builtin_unreachable();
+         if (sys_openat(fd, path, O_RDONLY, 0777, &fd2)) {
+            return ENOENT;
+         }
+			SYSCALL2(SYSCALL_STAT, fd2, statbuf);
+         sys_close(fd2);
+			return errno;
 		}
 		default: {
 			__ensure(!"stat: Invalid fsfdt");
@@ -493,5 +773,98 @@ int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat
 	__builtin_unreachable();
 }
 
+int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags) {
+	int ret, errno, fd2;
+   if (sys_openat(fd, pathname, O_RDONLY, 0777, &fd2)) {
+       return ENOENT;
+   }
+   SYSCALL2(SYSCALL_FCHMOD, fd2, mode);
+   sys_close(fd2);
+   return errno;
+}
+
+int sys_fchmod(int fd, mode_t mode) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_FCHMOD, fd, mode);
+	return errno;
+}
+
+int sys_umask(mode_t mode, mode_t *old) {
+   mode_t ret;
+   int errno;
+	SYSCALL1(SYSCALL_UMASK, mode);
+	*old = (mode_t)ret;
+	return errno;
+}
+
+int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) {
+	ssize_t ret;
+	int errno;
+	size_t path_len = strlen(path);
+	SYSCALL5(SYSCALL_READLINK, AT_FDCWD, path, path_len, buffer, max_size);
+	if (ret == -1) {
+		return errno;
+	} else {
+		*length = ret;
+		return 0;
+	}
+}
+
+int sys_mount(const char *source, const char *target,
+	const char *fstype, unsigned long flags, const void *data) {
+	(void)data;
+
+	int ret;
+	int errno;
+	size_t source_len = strlen(source);
+	size_t target_len = strlen(target);
+   int val;
+   if (!strcmp(fstype, "ext")) {
+      val = 1;
+   } else if (!strcmp(fstype, "fat32")) {
+      val = 2;
+   } else {
+      return EINVAL;
+   }
+
+	SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, val, flags);
+   return errno;
+}
+
+int sys_umount2(const char *target, int flags) {
+	int ret;
+	int errno;
+	size_t target_len = strlen(target);
+	SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
+   return errno;
+}
+
+
+int sys_rename(const char *path, const char *new_path) {
+	int ret;
+	int errno;
+	size_t old_len = strlen(path);
+   size_t new_len = strlen(new_path);
+	SYSCALL7(SYSCALL_RENAME, AT_FDCWD, path, old_len, AT_FDCWD, new_path, new_len, 0);
+   return errno;
+}
+
+int sys_renameat(int olddirfd, const char *old_path, int newdirfd, const char *new_path) {
+	int ret;
+	int errno;
+	size_t old_len = strlen(old_path);
+   size_t new_len = strlen(new_path);
+	SYSCALL7(SYSCALL_RENAME, olddirfd, old_path, old_len, newdirfd, new_path, new_len, 0);
+   return errno;
+}
+
+int sys_mknodat(int dirfd, const char *path, mode_t mode, dev_t dev) {
+	int ret;
+	int errno;
+	size_t len = strlen(path);
+	SYSCALL5(SYSCALL_MAKENODE, dirfd, path, len, mode, dev);
+   return errno;
+}
+
 #endif
 } // namespace mlibc
diff --git mlibc-workdir/sysdeps/ironclad/generic/mac.cpp mlibc-workdir/sysdeps/ironclad/generic/mac.cpp
new file mode 100644
index 0000000..a13e56f
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/mac.cpp
@@ -0,0 +1,36 @@
+#include <sys/syscall.h>
+#include <sys/mac.h>
+#include <errno.h>
+#include <string.h>
+
+extern "C" {
+
+unsigned long get_mac_capabilities(void) {
+	int ret, errn;
+	SYSCALL0(SYSCALL_GET_MAC_CAPABILITIES);
+	errno = errn;
+	return ret;
+}
+
+int set_mac_capabilities(unsigned long request) {
+	int ret, errn;
+	SYSCALL1(SYSCALL_SET_MAC_CAPABILITIES, request);
+	errno = errn;
+	return ret;
+}
+
+int add_mac_permissions(const char *path, int flags) {
+	int ret, errn;
+	SYSCALL3(SYSCALL_ADD_MAC_PERMISSIONS, path, strlen(path), flags);
+	errno = errn;
+	return ret;
+}
+
+int set_mac_enforcement(unsigned long enforcement) {
+	int ret, errn;
+	SYSCALL1(SYSCALL_SET_MAC_ENFORCEMENT, enforcement);
+	errno = errn;
+	return ret;
+}
+
+}
diff --git mlibc-workdir/sysdeps/ironclad/generic/mntent.cpp mlibc-workdir/sysdeps/ironclad/generic/mntent.cpp
new file mode 100644
index 0000000..d064af3
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/mntent.cpp
@@ -0,0 +1,97 @@
+#include <errno.h>
+#include <mntent.h>
+#include <stdio.h>
+#include <limits.h>
+#include <string.h>
+#include <bits/ensure.h>
+
+namespace {
+
+char *internal_buf;
+size_t internal_bufsize;
+
+}
+
+#define SENTINEL (char *)&internal_buf
+
+FILE *setmntent(const char *name, const char *mode) {
+	return fopen(name, mode);
+}
+
+struct mntent *getmntent(FILE *f) {
+	static struct mntent mnt;
+	return getmntent_r(f, &mnt, SENTINEL, 0);
+}
+
+int addmntent(FILE *f, const struct mntent *mnt) {
+	if(fseek(f, 0, SEEK_END)) {
+		return 1;
+	}
+	return fprintf(f, "%s\t%s\t%s\t%s\t%d\t%d\n",
+		mnt->mnt_fsname, mnt->mnt_dir, mnt->mnt_type, mnt->mnt_opts,
+		mnt->mnt_freq, mnt->mnt_passno) < 0;
+}
+
+int endmntent(FILE *f) {
+	if(f) {
+		fclose(f);
+	}
+	return 1;
+}
+
+char *hasmntopt(const struct mntent *mnt, const char *opt) {
+	return strstr(mnt->mnt_opts, opt);
+}
+
+/* Adapted from musl */
+struct mntent *getmntent_r(FILE *f, struct mntent *mnt, char *linebuf, int buflen) {
+	int n[8];
+	bool use_internal = (linebuf == SENTINEL);
+	int len;
+	size_t i;
+
+	mnt->mnt_freq = 0;
+	mnt->mnt_passno = 0;
+
+	do {
+		if(use_internal) {
+			getline(&internal_buf, &internal_bufsize, f);
+			linebuf = internal_buf;
+		} else {
+			fgets(linebuf, buflen, f);
+		}
+		if(feof(f) || ferror(f)) {
+			return 0;
+		}
+		if(!strchr(linebuf, '\n')) {
+			fscanf(f, "%*[^\n]%*[\n]");
+			errno = ERANGE;
+			return 0;
+		}
+
+		len = strlen(linebuf);
+		if(len > INT_MAX) {
+			continue;
+		}
+
+		for(i = 0; i < sizeof n / sizeof *n; i++) {
+			n[i] = len;
+		}
+
+		sscanf(linebuf, " %n%*s%n %n%*s%n %n%*s%n %n%*s%n %d %d",
+			n, n + 1, n + 2, n + 3, n + 4, n + 5, n + 6, n + 7,
+			&mnt->mnt_freq, &mnt->mnt_passno);
+	} while(linebuf[n[0]] == '#' || n[1] == len);
+
+	linebuf[n[1]] = 0;
+	linebuf[n[3]] = 0;
+	linebuf[n[5]] = 0;
+	linebuf[n[7]] = 0;
+
+	mnt->mnt_fsname = linebuf + n[0];
+	mnt->mnt_dir = linebuf + n[2];
+	mnt->mnt_type = linebuf + n[4];
+	mnt->mnt_opts = linebuf + n[6];
+
+	return mnt;
+}
diff --git mlibc-workdir/sysdeps/ironclad/generic/mount.cpp mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
new file mode 100644
index 0000000..f10254d
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
@@ -0,0 +1,16 @@
+#include <errno.h>
+#include <sys/mount.h>
+#include <bits/ensure.h>
+
+int mount(const char *source, const char *target,
+		const char *fstype, unsigned long flags, const void *data) {
+	return 0;
+}
+
+int umount(const char *target) {
+	return umount2(target, 0);
+}
+
+int umount2(const char *target, int flags) {
+	return 0;
+}
diff --git mlibc-workdir/sysdeps/ironclad/generic/pty.cpp mlibc-workdir/sysdeps/ironclad/generic/pty.cpp
new file mode 100644
index 0000000..fcee169
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/pty.cpp
@@ -0,0 +1,18 @@
+#include <asm/ioctls.h>
+#include <bits/ensure.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pty.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/syscall.h>
+
+int openpty(int *mfd, int *sfd, char *name, const struct termios *ios, const struct winsize *win) {
+   int errno, ret;
+   int fds[2];
+   SYSCALL3(SYSCALL_OPENPTY, fds, ios, win);
+   *mfd = fds[0];
+   *sfd = fds[1];
+   return ret;
+}
diff --git mlibc-workdir/sysdeps/ironclad/generic/reboot.cpp mlibc-workdir/sysdeps/ironclad/generic/reboot.cpp
new file mode 100644
index 0000000..45e8f03
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/reboot.cpp
@@ -0,0 +1,9 @@
+#include <errno.h>
+#include <sys/reboot.h>
+#include <sys/syscall.h>
+
+int reboot(int what) {
+	int ret, errno;
+	SYSCALL2(SYSCALL_REBOOT, what, 0);
+	return ret;
+}
diff --git mlibc-workdir/sysdeps/ironclad/generic/sched2.cpp mlibc-workdir/sysdeps/ironclad/generic/sched2.cpp
new file mode 100644
index 0000000..c76faa3
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/sched2.cpp
@@ -0,0 +1,30 @@
+#include <sys/syscall.h>
+#include <sys/sched2.h>
+#include <errno.h>
+#include <string.h>
+
+extern "C" {
+
+int get_thread_sched(void) {
+	int ret, errn;
+	SYSCALL0(SYSCALL_GET_THREAD_SCHED);
+	errno = errn;
+	return ret;
+}
+
+int set_thread_sched(int flags) {
+	int ret, errn;
+	SYSCALL1(SYSCALL_SET_THREAD_SCHED, flags);
+	errno = errn;
+	return ret;
+}
+
+int set_deadlines(int runtime, int period) {
+	int ret;
+	int errn;
+	SYSCALL2(SYSCALL_SET_DEADLINES, runtime, period);
+	errno = errn;
+	return ret;
+}
+
+}
diff --git mlibc-workdir/sysdeps/ironclad/generic/thread.S mlibc-workdir/sysdeps/ironclad/generic/thread.S
new file mode 100644
index 0000000..47ab6a9
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/thread.S
@@ -0,0 +1,9 @@
+.section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_thread_trampoline
+
+.section .note.GNU-stack,"",%progbits
diff --git mlibc-workdir/sysdeps/ironclad/generic/thread.cpp mlibc-workdir/sysdeps/ironclad/generic/thread.cpp
new file mode 100644
index 0000000..687ef8c
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/thread.cpp
@@ -0,0 +1,19 @@
+#include <sys/mman.h>
+#include <mlibc/debug.hpp>
+#include <errno.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <bits/ensure.h>
+#include <mlibc/tcb.hpp>
+
+extern "C" void __mlibc_thread_trampoline(void *(*fn)(void *), Tcb *tcb, void *arg) {
+	while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0) {
+		mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);
+	}
+
+	tcb->returnValue = fn(arg);
+
+	__atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&tcb->didExit);
+
+	mlibc::sys_thread_exit();
+}
diff --git mlibc-workdir/sysdeps/ironclad/include/asm/ioctls.h mlibc-workdir/sysdeps/ironclad/include/asm/ioctls.h
new file mode 100644
index 0000000..5bb74bc
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/asm/ioctls.h
@@ -0,0 +1,102 @@
+#ifndef _ASM_IOCTLS_H
+#define _ASM_IOCTLS_H
+
+// List of all the IOCTLs supported, for further explanation on the meanings
+// please refer to documentation. If you did not get any, good luck!
+// Some IOCTL codes may be the same, in which case the device they are used in
+// gives them meaning. Cross-device IOCTLs have more distinct values.
+
+#define PS2MOUSE_2_1_SCALING     1
+#define PS2MOUSE_1_1_SCALING     2
+#define PS2MOUSE_SET_RES         3
+#define PS2MOUSE_SET_SAMPLE_RATE 4
+#define RTC_RD_TIME              1
+#define RTC_SET_TIME             2
+#define FIOQSIZE                 0x5460
+#define TCGETS                   0x5401
+#define TCSETS                   0x5402
+#define TCSETSW                  0x5403
+#define TCSETSF                  0x5404
+#define TCGETA                   0x5405
+#define TCSETA                   0x5406
+#define TCSETAW                  0x5407
+#define TCSETAF                  0x5408
+#define TCSBRK                   0x5409
+#define TCXONC                   0x540A
+#define TCFLSH                   0x540B
+#define TIOCEXCL                 0x540C
+#define TIOCNXCL                 0x540D
+#define TIOCSCTTY                0x540E
+#define TIOCGPGRP                0x540F
+#define TIOCSPGRP                0x5410
+#define TIOCOUTQ                 0x5411
+#define TIOCSTI                  0x5412
+#define TIOCGWINSZ               0x5413
+#define TIOCSWINSZ               0x5414
+#define TIOCMGET                 0x5415
+#define TIOCMBIS                 0x5416
+#define TIOCMBIC                 0x5417
+#define TIOCMSET                 0x5418
+#define TIOCGSOFTCAR             0x5419
+#define TIOCSSOFTCAR             0x541A
+#define FIONREAD                 0x541B
+#define TIOCINQ                  FIONREAD
+#define TIOCLINUX                0x541C
+#define TIOCCONS                 0x541D
+#define TIOCGSERIAL              0x541E
+#define TIOCSSERIAL              0x541F
+#define TIOCPKT                  0x5420
+#define FIONBIO                  0x5421
+#define TIOCNOTTY                0x5422
+#define TIOCSETD                 0x5423
+#define TIOCGETD                 0x5424
+#define TCSBRKP                  0x5425
+#define TIOCSBRK                 0x5427
+#define TIOCCBRK                 0x5428
+#define TIOCGSID                 0x5429 
+#define TCGETS2                  3
+#define TCSETS2                  3
+#define TCSETSW2                 3
+#define TCSETSF2                 3
+#define TIOCGRS485               0x542E
+#define TIOCSRS485               0x542F
+#define TIOCGPTN                 3
+#define TIOCSPTLCK               3
+#define TIOCGDEV                 3
+#define TCGETX                   0x5432
+#define TCSETX                   0x5433
+#define TCSETXF                  0x5434
+#define TCSETXW                  0x5435
+#define TIOCSIG                  0x36
+#define TIOCVHANGUP              0x5437
+#define TIOCGPKT                 3
+#define TIOCGPTLCK               3
+#define TIOCGEXCL                3
+#define TIOCGPTPEER              3
+#define TIOCGISO7816             3
+#define TIOCSISO7816             3
+#define FIONCLEX                 0x5450
+#define FIOCLEX                  0x5451
+#define FIOASYNC                 0x5452
+#define TIOCSERCONFIG            0x5453
+#define TIOCSERGWILD             0x5454
+#define TIOCSERSWILD             0x5455
+#define TIOCGLCKTRMIOS           0x5456
+#define TIOCSLCKTRMIOS           0x5457
+#define TIOCSERGSTRUCT           0x5458
+#define TIOCSERGETLSR            0x5459
+#define TIOCSERGETMULTI          0x545A
+#define TIOCSERSETMULTI          0x545B
+#define TIOCMIWAIT               0x545C
+#define TIOCGICOUNT              0x545D
+#define TIOCPKT_DATA             0
+#define TIOCPKT_FLUSHREAD        1
+#define TIOCPKT_FLUSHWRITE       2
+#define TIOCPKT_STOP             4
+#define TIOCPKT_START            8
+#define TIOCPKT_NOSTOP           16
+#define TIOCPKT_DOSTOP           32
+#define TIOCPKT_IOCTL            64
+#define TIOCSER_TEMT	            0x01
+
+#endif /* _ASM_IOCTLS_H */
diff --git mlibc-workdir/sysdeps/ironclad/include/linux/fb.h mlibc-workdir/sysdeps/ironclad/include/linux/fb.h
new file mode 100644
index 0000000..b3b5350
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/linux/fb.h
@@ -0,0 +1,397 @@
+#ifndef _SYS_FB_H
+#define _SYS_FB_H
+
+#include <stddef.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+#define FB_TYPE_FOURCC			5	/* Type identified by a V4L2 FOURCC */
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+#define FB_VISUAL_FOURCC		6	/* Visual identified by a V4L2 FOURCC */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/
+
+#define FB_CAP_FOURCC		1	/* Device supports FOURCC-based formats */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	uint32_t smem_len;			/* Length of frame buffer mem */
+	uint32_t type;			/* see FB_TYPE_*		*/
+	uint32_t type_aux;			/* Interleave for interleaved Planes */
+	uint32_t visual;			/* see FB_VISUAL_*		*/ 
+	uint16_t xpanstep;			/* zero if no hardware panning  */
+	uint16_t ypanstep;			/* zero if no hardware panning  */
+	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
+	uint32_t line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
+	uint32_t accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	uint16_t capabilities;		/* see FB_CAP_*			*/
+	uint16_t reserved[2];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the palette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	uint32_t offset;			/* beginning of bitfield	*/
+	uint32_t length;			/* length of bitfield		*/
+	uint32_t msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+#define FB_ACTIVATE_KD_TEXT   512       /* for KDSET vt ioctl */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	uint32_t xres;			/* visible resolution		*/
+	uint32_t yres;
+	uint32_t xres_virtual;		/* virtual resolution		*/
+	uint32_t yres_virtual;
+	uint32_t xoffset;			/* offset from virtual to visible */
+	uint32_t yoffset;			/* resolution			*/
+
+	uint32_t bits_per_pixel;		/* guess what			*/
+	uint32_t grayscale;		/* 0 = color, 1 = grayscale,	*/
+					/* >1 = FOURCC			*/
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	uint32_t nonstd;			/* != 0 Non standard pixel format */
+
+	uint32_t activate;			/* see FB_ACTIVATE_*		*/
+
+	uint32_t height;			/* height of picture in mm    */
+	uint32_t width;			/* width of picture in mm     */
+
+	uint32_t accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
+	uint32_t left_margin;		/* time from sync to picture	*/
+	uint32_t right_margin;		/* time from picture to sync	*/
+	uint32_t upper_margin;		/* time from sync to picture	*/
+	uint32_t lower_margin;
+	uint32_t hsync_len;		/* length of horizontal sync	*/
+	uint32_t vsync_len;		/* length of vertical sync	*/
+	uint32_t sync;			/* see FB_SYNC_*		*/
+	uint32_t vmode;			/* see FB_VMODE_*		*/
+	uint32_t rotate;			/* angle we rotate counter clockwise */
+	uint32_t colorspace;		/* colorspace for FOURCC-based modes */
+	uint32_t reserved[4];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	uint32_t start;			/* First entry	*/
+	uint32_t len;			/* Number of entries */
+	uint16_t *red;			/* Red values	*/
+	uint16_t *green;
+	uint16_t *blue;
+	uint16_t *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	uint32_t console;
+	uint32_t framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	uint32_t flags;			/* FB_VBLANK flags */
+	uint32_t count;			/* counter of retraces since boot */
+	uint32_t vcount;			/* current scanline position */
+	uint32_t hcount;			/* current scandot position */
+	uint32_t reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	uint32_t dx;
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t sx;
+	uint32_t sy;
+};
+
+struct fb_fillrect {
+	uint32_t dx;	/* screen-relative */
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t color;
+	uint32_t rop;
+};
+
+struct fb_image {
+	uint32_t dx;		/* Where to place image */
+	uint32_t dy;
+	uint32_t width;		/* Size of image */
+	uint32_t height;
+	uint32_t fg_color;		/* Only used when a mono bitmap */
+	uint32_t bg_color;
+	uint8_t  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	uint16_t x, y;
+};
+
+struct fb_cursor {
+	uint16_t set;		/* what to set */
+	uint16_t enable;		/* cursor on/off */
+	uint16_t rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+
+
+#endif /* _SYS_FB_H */
diff --git mlibc-workdir/sysdeps/ironclad/include/mntent.h mlibc-workdir/sysdeps/ironclad/include/mntent.h
new file mode 100644
index 0000000..e5e49e7
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/mntent.h
@@ -0,0 +1,46 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#include <stdio.h>
+
+// TODO: Refer to _PATH_MOUNTED
+#define MOUNTED "/etc/mtab"
+
+/* Generic mount options */
+#define MNTOPT_DEFAULTS "defaults"		/* Use all default options. */
+#define MNTOPT_RO       "ro"			/* Read only. */
+#define MNTOPT_RW       "rw"			/* Read/write. */
+#define MNTOPT_SUID     "suid"			/* Set uid allowed. */
+#define MNTOPT_NOSUID   "nosuid"		/* No set uid allowed. */
+#define MNTOPT_NOAUTO   "noauto"		/* Do not auto mount. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mntent {
+	char *mnt_fsname;
+	char *mnt_dir;
+	char *mnt_type;
+	char *mnt_opts;
+	int mnt_freq;
+	int mnt_passno;
+};
+
+FILE *setmntent(const char *, const char *);
+
+struct mntent *getmntent(FILE *);
+
+int addmntent(FILE *, const struct mntent *);
+
+int endmntent(FILE *);
+
+char *hasmntopt(const struct mntent *, const char *);
+
+struct mntent *getmntent_r(FILE *, struct mntent *,  char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _MNTENT_H
diff --git mlibc-workdir/sysdeps/ironclad/include/pty.h mlibc-workdir/sysdeps/ironclad/include/pty.h
new file mode 100644
index 0000000..0468b46
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/pty.h
@@ -0,0 +1,16 @@
+#ifndef _PTY_H
+#define _PTY_H
+
+#include <termios.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int openpty(int *mfd, int *sfd, char *name, const struct termios *ios, const struct winsize *win);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _PTY_H
diff --git mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h
deleted file mode 100644
index 89a3851..0000000
--- mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef _IRONCLAD_H
-#define _IRONCLAD_H
-
-#include <stdint.h>
-#include <stdbool.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define FB_DIMENSIONS 1
-
-struct ironclad_fb_dimensions {
-	uint16_t width;
-	uint16_t height;
-	uint16_t pitch;
-	uint16_t bpp;
-	uint8_t  red_mask_size;
-	uint8_t  red_mask_shift;
-	uint8_t  green_mask_size;
-	uint8_t  green_mask_shift;
-	uint8_t  blue_mask_size;
-	uint8_t  blue_mask_shift;
-};
-
-#define PS2MOUSE_2_1_SCALING     1
-#define PS2MOUSE_1_1_SCALING     2
-#define PS2MOUSE_SET_RES         3
-#define PS2MOUSE_SET_SAMPLE_RATE 4
-
-struct ironclad_mouse_data {
-	int  x_variation;
-	int  y_variation;
-	bool is_left;
-	bool is_right;
-};
-#ifdef __cplusplus
-}
-#endif
-
-#endif // _IRONCLAD_H
diff --git mlibc-workdir/sysdeps/ironclad/include/sys/ironclad_devices.h mlibc-workdir/sysdeps/ironclad/include/sys/ironclad_devices.h
new file mode 100644
index 0000000..74f47f8
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/sys/ironclad_devices.h
@@ -0,0 +1,44 @@
+#ifndef _SYS_IRONCLAD_DEVICES_H
+#define _SYS_IRONCLAD_DEVICES_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <asm/ioctls.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PS2MOUSE_2_1_SCALING     1
+#define PS2MOUSE_1_1_SCALING     2
+#define PS2MOUSE_SET_RES         3
+#define PS2MOUSE_SET_SAMPLE_RATE 4
+
+struct ironclad_mouse_data {
+	int  x_variation;
+	int  y_variation;
+	bool is_left;
+	bool is_right;
+};
+
+#define RTC_RD_TIME  1
+#define RTC_SET_TIME 2
+
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;     /* unused */
+	int tm_yday;     /* unused */
+	int tm_isdst;    /* unused */
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_IRONCLAD_DEVICES_H
diff --git mlibc-workdir/sysdeps/ironclad/include/sys/mac.h mlibc-workdir/sysdeps/ironclad/include/sys/mac.h
new file mode 100644
index 0000000..fda3821
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mac.h
@@ -0,0 +1,44 @@
+#ifndef _SYS_MAC_H
+#define _SYS_MAC_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MAC_CAP_SCHED   0b00000000001
+#define MAC_CAP_SPAWN   0b00000000010
+#define MAC_CAP_ENTROPY 0b00000000100
+#define MAC_CAP_SYS_MEM 0b00000001000
+#define MAC_CAP_USE_NET 0b00000010000
+#define MAC_CAP_SYS_NET 0b00000100000
+#define MAC_CAP_SYS_MNT 0b00001000000
+#define MAC_CAP_SYS_PWR 0b00010000000
+#define MAC_CAP_PTRACE  0b00100000000
+#define MAC_CAP_SETUID  0b01000000000
+#define MAC_CAP_SYS_MAC 0b10000000000
+unsigned long get_mac_capabilities(void);
+int set_mac_capabilities(unsigned long request);
+
+#define MAC_PERM_CONTENTS 0b0000001
+#define MAC_PERM_READ     0b0000010
+#define MAC_PERM_WRITE    0b0000100
+#define MAC_PERM_EXEC     0b0001000
+#define MAC_PERM_APPEND   0b0010000
+#define MAC_PERM_FLOCK    0b0100000
+#define MAC_PERM_DEV      0b1000000
+int add_mac_permissions(const char *path, int flags);
+
+#define MAC_DENY            0b001
+#define MAC_DENY_AND_SCREAM 0b010
+#define MAC_KILL            0b100
+int set_mac_enforcement(unsigned long enforcement);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_MAC_H
diff --git mlibc-workdir/sysdeps/ironclad/include/sys/mount.h mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
new file mode 100644
index 0000000..71ae64d
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
@@ -0,0 +1,19 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MNT_FORCE 1
+
+int mount(const char *source, const char *target,
+		const char *fstype, unsigned long flags, const void *data);
+int umount(const char *target);
+int umount2(const char *target, int flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_MOUNT_H
diff --git mlibc-workdir/sysdeps/ironclad/include/sys/reboot.h mlibc-workdir/sysdeps/ironclad/include/sys/reboot.h
new file mode 100644
index 0000000..c2dbbf2
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/sys/reboot.h
@@ -0,0 +1,16 @@
+#ifndef _SYS_REBOOT_H
+#define _SYS_REBOOT_H
+
+#include <abi-bits/reboot.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int reboot(int arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_REBOOT_H
diff --git mlibc-workdir/sysdeps/ironclad/include/sys/sched2.h mlibc-workdir/sysdeps/ironclad/include/sys/sched2.h
new file mode 100644
index 0000000..caeb86a
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/sys/sched2.h
@@ -0,0 +1,24 @@
+#ifndef _SYS_SCHED2_H
+#define _SYS_SCHED2_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define THREAD_RT     0b0001
+#define THREAD_MONO   0b0010
+#define THREAD_MLOCK  0b0100
+#define THREAD_BANNED 0b1000
+int get_thread_sched(void);
+int set_thread_sched(int flags);
+int set_deadlines(int runtime, int period);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_SCHED2_H
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index 28d233e..3b94bda 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -1,5 +1,5 @@
-#ifndef _SYSCALL_H
-#define _SYSCALL_H
+#ifndef _SYS_SYSCALL_H
+#define _SYS_SYSCALL_H
 
 #include <stddef.h>
 
@@ -38,9 +38,18 @@
 				  : "memory"); \
 })
 
+#define SYSCALL5(NUM, ARG0, ARG1, ARG2, ARG3, ARG4) ({ \
+   register auto arg_r8 asm("r8") = ARG4; \
+	asm volatile ("int $0x80" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), "c"(ARG3), \
+				    "r"(arg_r8) \
+				  : "memory"); \
+})
+
 #define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
-	register uint64_t arg_r8 asm("r8") = (uint64_t)ARG4; \
-	register uint64_t arg_r9 asm("r9") = (uint64_t)ARG5; \
+	register auto arg_r8 asm("r8") = ARG4; \
+	register auto arg_r9 asm("r9") = ARG5; \
 	asm volatile ("int $0x80" \
 				  : "=a"(ret), "=d"(errno) \
 				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
@@ -48,33 +57,77 @@
 				  : "memory"); \
 })
 
-#define SYSCALL_EXIT               0
-#define SYSCALL_SET_TCB            1
-#define SYSCALL_OPEN               2
-#define SYSCALL_CLOSE              3
-#define SYSCALL_READ               4
-#define SYSCALL_WRITE              5
-#define SYSCALL_SEEK               6
-#define SYSCALL_MMAP               7
-#define SYSCALL_MUNMAP             8
-#define SYSCALL_GETPID             9
-#define SYSCALL_GETPPID           10
-#define SYSCALL_EXEC              11
-#define SYSCALL_FORK              12
-#define SYSCALL_WAIT              13
-#define SYSCALL_UNAME             14
-#define SYSCALL_SETHOSTNAME       15
-#define SYSCALL_FSTAT             16
-#define SYSCALL_LSTAT             17
-#define SYSCALL_GETCWD            18
-#define SYSCALL_CHDIR             19
-#define SYSCALL_IOCTL             20
-#define SYSCALL_SCHED_YIELD       21
-#define SYSCALL_GETPRIORITY       22
-#define SYSCALL_SETPRIORITY       23
-#define SYSCALL_DUP               24
-#define SYSCALL_DUP2              25
-#define SYSCALL_DUP3              26
-#define SYSCALL_ACCESS            27
+#define SYSCALL7(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ({ \
+	register auto arg_r8  asm("r8")  = ARG4; \
+	register auto arg_r9  asm("r9")  = ARG5; \
+	register auto arg_r10 asm("r10") = ARG6; \
+	asm volatile ("int $0x80" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+					"c"(ARG3), "r"(arg_r8), "r"(arg_r9), "r"(arg_r10) \
+				  : "memory"); \
+})
+
+#define SYSCALL_EXIT                  0
+#define SYSCALL_ARCH_PRCTL            1
+#define SYSCALL_OPEN                  2
+#define SYSCALL_CLOSE                 3
+#define SYSCALL_READ                  4
+#define SYSCALL_WRITE                 5
+#define SYSCALL_SEEK                  6
+#define SYSCALL_MMAP                  7
+#define SYSCALL_MUNMAP                8
+#define SYSCALL_GETPID                9
+#define SYSCALL_GETPPID              10
+#define SYSCALL_EXEC                 11
+#define SYSCALL_CLONE                12
+#define SYSCALL_WAIT                 13
+#define SYSCALL_UNAME                14
+#define SYSCALL_SETHOSTNAME          15
+#define SYSCALL_UNLINK               16
+#define SYSCALL_STAT                 17
+#define SYSCALL_GETCWD               18
+#define SYSCALL_CHDIR                19
+#define SYSCALL_IOCTL                20
+#define SYSCALL_SCHED_YIELD          21
+#define SYSCALL_SET_DEADLINES        22
+#define SYSCALL_PIPE                 23
+#define SYSCALL_GETUID               24
+#define SYSCALL_RENAME               25
+#define SYSCALL_SYSCONF              26
+#define SYSCALL_GET_THREAD_SCHED     28
+#define SYSCALL_SET_THREAD_SCHED     29
+#define SYSCALL_FCNTL                30
+#define SYSCALL_EXIT_THREAD          31
+#define SYSCALL_GETRANDOM            32
+#define SYSCALL_MPROTECT             33
+#define SYSCALL_SYNC                 34
+#define SYSCALL_SET_MAC_CAPABILITIES 35
+#define SYSCALL_GET_MAC_CAPABILITIES 36
+#define SYSCALL_ADD_MAC_PERMISSIONS  37
+#define SYSCALL_SET_MAC_ENFORCEMENT  38
+#define SYSCALL_MOUNT                39
+#define SYSCALL_UMOUNT               40
+#define SYSCALL_READLINK             41
+#define SYSCALL_GETDENTS             42
+#define SYSCALL_MAKENODE             43
+#define SYSCALL_TRUNCATE             44
+#define SYSCALL_SYMLINK              46
+#define SYSCALL_INTEGRITY_SETUP      47
+#define SYSCALL_OPENPTY              48
+#define SYSCALL_FSYNC                49
+#define SYSCALL_LINK                 50
+#define SYSCALL_PTRACE               51
+#define SYSCALL_SOCKET               52
+#define SYSCALL_BIND                 53
+#define SYSCALL_CONNECT              54
+#define SYSCALL_LISTEN               55
+#define SYSCALL_ACCEPT               56
+#define SYSCALL_POLL                 57
+#define SYSCALL_GETEUID              58
+#define SYSCALL_SETUIDS              59
+#define SYSCALL_FCHMOD               60
+#define SYSCALL_UMASK                61
+#define SYSCALL_REBOOT               62
 
-#endif // _SYSCALL_H
+#endif // _SYS_SYSCALL_H
diff --git mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
index 898e0de..81b3157 100644
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -5,7 +5,15 @@ rtdl_sources += files(
 
 libc_sources += files(
 	'generic/entry.cpp',
-	'generic/generic.cpp'
+	'generic/generic.cpp',
+   'generic/mntent.cpp',
+   'generic/mount.cpp',
+   'generic/reboot.cpp',
+   'generic/pty.cpp',
+	'generic/thread.cpp',
+   'generic/mac.cpp',
+   'generic/sched2.cpp',
+	'generic/thread.S'
 )
 
 if not no_headers
@@ -55,9 +63,28 @@ if not no_headers
 		subdir: 'abi-bits'
 	)
 	install_headers(
-		'include/sys/ironclad.h',
+		'include/sys/sched2.h',
+      'include/sys/ironclad_devices.h',
+      'include/sys/mac.h',
 		'include/sys/syscall.h',
-		subdir: 'sys'
+      'include/sys/reboot.h',
+      'include/sys/mount.h',
+      subdir: 'sys'
+	)
+
+	install_headers(
+      'include/asm/ioctls.h',
+		subdir: 'asm'
+	)
+
+	install_headers(
+      'include/linux/fb.h',
+		subdir: 'linux'
+	)
+
+	install_headers(
+      'include/mntent.h',
+      'include/pty.h'
 	)
 endif
 
@@ -70,5 +97,23 @@ if not headers_only
 		install: true,
 		install_dir: get_option('libdir')
 	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
 endif
 
