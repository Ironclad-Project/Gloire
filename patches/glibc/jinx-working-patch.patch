diff --git glibc-clean/Makeconfig glibc-workdir/Makeconfig
index 7102d92..29485e8 100644
--- glibc-clean/Makeconfig
+++ glibc-workdir/Makeconfig
@@ -1294,7 +1294,9 @@ $(common-objpfx)dl-tunable-list.stmp: \
 # Dump the GCC macros used by the default compiler flags to a header
 # file, so that they can be inspected when using different compiler
 # flags.  Add the GCCMACRO prefix to make these macro names unique.
-$(common-objpfx)gcc-macros.h.in: $(common-objpfx)config.status
+# Depend on libc-modules.stmp because CPPFLAGS includes -include libc-modules.h.
+$(common-objpfx)gcc-macros.h.in: $(common-objpfx)config.status \
+				 $(common-objpfx)libc-modules.stmp
 	$(CC) $(CFLAGS) $(CPPFLAGS) -E -dM -x c -o $@ /dev/null
 $(common-objpfx)gcc-macros.h: $(common-objpfx)gcc-macros.h.in
 	sed 's/^#define /#define GCCMACRO/' < $< > $@
@@ -1408,7 +1410,7 @@ all-subdirs = csu assert ctype locale intl catgets math setjmp signal	    \
 	      stdlib stdio-common libio malloc string wcsmbs time dirent    \
 	      posix io termios resource misc socket sysvipc gmon            \
 	      gnulib iconv iconvdata wctype manual po argp                  \
-	      localedata timezone rt conform debug mathvec support	    \
+	      localedata timezone rt conform debug mathvec	    \
 	      dlfcn elf
 
 ifndef avoid-generated
diff --git glibc-clean/abi-tags glibc-workdir/abi-tags
index 87cd681..a4a9d77 100644
--- glibc-clean/abi-tags
+++ glibc-workdir/abi-tags
@@ -28,5 +28,7 @@
 
 .*-.*-syllable.*	5	2.0.0	# just an arbitrary value
 
+.*-.*-ironclad.*	6	1.0.0	# Ironclad kernel
+
 # There is no catch-all default here because every supported OS that uses
 # ELF must have its own unique ABI tag.
diff --git glibc-workdir/bits/access.h glibc-workdir/bits/access.h
new file mode 100644
index 0000000..b6b5741
--- /dev/null
+++ glibc-workdir/bits/access.h
@@ -0,0 +1,37 @@
+/* Access mode flags - generic version.
+   Copyright (C) 2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_ACCESS_H
+#define _BITS_ACCESS_H	1
+
+/* POSIX/Linux access mode flags.
+   Platform-specific overrides may define different values.  */
+#ifndef R_OK
+# define R_OK	4		/* Test for read permission.  */
+#endif
+#ifndef W_OK
+# define W_OK	2		/* Test for write permission.  */
+#endif
+#ifndef X_OK
+# define X_OK	1		/* Test for execute permission.  */
+#endif
+#ifndef F_OK
+# define F_OK	0		/* Test for existence.  */
+#endif
+
+#endif /* _BITS_ACCESS_H */
diff --git glibc-workdir/bits/seek_whence.h glibc-workdir/bits/seek_whence.h
new file mode 100644
index 0000000..30bcfeb
--- /dev/null
+++ glibc-workdir/bits/seek_whence.h
@@ -0,0 +1,28 @@
+/* Generic seek whence values.
+   Copyright (C) 2024-2025 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_SEEK_WHENCE_H
+#define _BITS_SEEK_WHENCE_H 1
+
+/* Generic SEEK_* values (Linux-compatible).
+   OS-specific sysdeps may override these.  */
+#define SEEK_SET	0	/* Seek from beginning of file.  */
+#define SEEK_CUR	1	/* Seek from current position.  */
+#define SEEK_END	2	/* Seek from end of file.  */
+
+#endif /* bits/seek_whence.h */
diff --git glibc-clean/configure glibc-workdir/configure
index 180e49d..b1ffdf4 100755
--- glibc-clean/configure
+++ glibc-workdir/configure
@@ -4968,7 +4968,7 @@ fi
 ###
 if test -z "$enable_hacker_mode" && test x"$libc_config_ok" != xyes; then
   case "$machine-$host_os" in
-  *-linux* | *-gnu*)
+  *-linux* | *-gnu* | *-ironclad*)
     ;;
   *)
     as_fn_error $? "
@@ -6500,6 +6500,8 @@ gnu*)
   base_os=mach/hurd ;;
 linux*)
   base_os=unix/sysv ;;
+ironclad*)
+  base_os=unix/sysv ;;
 esac
 
 # For sunos4.1.1, try sunos4.1.1, then sunos4.1, then sunos4, then sunos.
diff --git glibc-clean/io/fcntl.h glibc-workdir/io/fcntl.h
index 132d83a..2c64224 100644
--- glibc-clean/io/fcntl.h
+++ glibc-workdir/io/fcntl.h
@@ -132,11 +132,10 @@ typedef __pid_t pid_t;
 # endif
 #endif /* Use misc.  */
 
-/* XPG wants the following symbols.   <stdio.h> has the same definitions.  */
+/* XPG wants the following symbols.   <stdio.h> has the same definitions.
+   Get OS-specific values from bits/seek_whence.h.  */
 #if defined __USE_XOPEN || defined __USE_XOPEN2K8
-# define SEEK_SET	0	/* Seek from beginning of file.  */
-# define SEEK_CUR	1	/* Seek from current position.  */
-# define SEEK_END	2	/* Seek from end of file.  */
+# include <bits/seek_whence.h>
 #endif	/* XPG */
 
 /* The constants AT_REMOVEDIR and AT_EACCESS have the same value.  AT_EACCESS
@@ -145,26 +144,52 @@ typedef __pid_t pid_t;
    the flags can be allowed to overlap.  For example, passing AT_REMOVEDIR to
    faccessat would be undefined behavior and thus treating it equivalent to
    AT_EACCESS is valid undefined behavior.  */
+/* Note: These may be defined by bits/fcntl.h for platforms with different
+   values (e.g., Ironclad).  Use #ifndef guards to allow overriding.  */
 #ifdef __USE_ATFILE
-# define AT_FDCWD		-100	/* Special value used to indicate
+# ifndef AT_FDCWD
+#  define AT_FDCWD		-100	/* Special value used to indicate
 					   the *at functions should use the
 					   current working directory. */
-# define AT_SYMLINK_NOFOLLOW	0x100	/* Do not follow symbolic links.  */
-# define AT_REMOVEDIR		0x200	/* Remove directory instead of
+# endif
+# ifndef AT_SYMLINK_NOFOLLOW
+#  define AT_SYMLINK_NOFOLLOW	0x100	/* Do not follow symbolic links.  */
+# endif
+# ifndef AT_REMOVEDIR
+#  define AT_REMOVEDIR		0x200	/* Remove directory instead of
 					   unlinking file.  */
-# define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic links.  */
+# endif
+# ifndef AT_SYMLINK_FOLLOW
+#  define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic links.  */
+# endif
 # ifdef __USE_GNU
-#  define AT_NO_AUTOMOUNT	0x800	/* Suppress terminal automount
+#  ifndef AT_NO_AUTOMOUNT
+#   define AT_NO_AUTOMOUNT	0x800	/* Suppress terminal automount
 					   traversal.  */
-#  define AT_EMPTY_PATH		0x1000	/* Allow empty relative pathname.  */
-#  define AT_STATX_SYNC_TYPE	0x6000
-#  define AT_STATX_SYNC_AS_STAT	0x0000
-#  define AT_STATX_FORCE_SYNC	0x2000
-#  define AT_STATX_DONT_SYNC	0x4000
-#  define AT_RECURSIVE		0x8000	/* Apply to the entire subtree.  */
+#  endif
+#  ifndef AT_EMPTY_PATH
+#   define AT_EMPTY_PATH	0x1000	/* Allow empty relative pathname.  */
+#  endif
+#  ifndef AT_STATX_SYNC_TYPE
+#   define AT_STATX_SYNC_TYPE	0x6000
+#  endif
+#  ifndef AT_STATX_SYNC_AS_STAT
+#   define AT_STATX_SYNC_AS_STAT	0x0000
+#  endif
+#  ifndef AT_STATX_FORCE_SYNC
+#   define AT_STATX_FORCE_SYNC	0x2000
+#  endif
+#  ifndef AT_STATX_DONT_SYNC
+#   define AT_STATX_DONT_SYNC	0x4000
+#  endif
+#  ifndef AT_RECURSIVE
+#   define AT_RECURSIVE		0x8000	/* Apply to the entire subtree.  */
+#  endif
 # endif
-# define AT_EACCESS		0x200	/* Test access permitted for
+# ifndef AT_EACCESS
+#  define AT_EACCESS		0x200	/* Test access permitted for
 					   effective IDs, not real IDs.  */
+# endif
 #endif
 
 /* Do the file control operation described by CMD on FD.
diff --git glibc-clean/libio/fileops.c glibc-workdir/libio/fileops.c
index 0cce828..fd9a62f 100644
--- glibc-clean/libio/fileops.c
+++ glibc-workdir/libio/fileops.c
@@ -475,7 +475,7 @@ new_do_write (FILE *fp, const char *data, size_t to_do)
   else if (fp->_IO_read_end != fp->_IO_write_base)
     {
       off64_t new_pos
-	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);
+	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, _IO_seek_cur);
       if (new_pos == _IO_pos_BAD)
 	return 0;
       fp->_offset = new_pos;
@@ -839,7 +839,7 @@ _IO_new_file_sync (FILE *fp)
     }
   if (delta != 0)
     {
-      off64_t new_pos = _IO_SYSSEEK (fp, delta, 1);
+      off64_t new_pos = _IO_SYSSEEK (fp, delta, _IO_seek_cur);
       if (new_pos != (off64_t) EOF)
 	fp->_IO_read_end = fp->_IO_read_ptr;
       else if (errno == ESPIPE)
@@ -1059,7 +1059,7 @@ _IO_new_file_seekoff (FILE *fp, off64_t offset, int dir, int mode)
       new_offset = offset;
       delta = 0;
     }
-  result = _IO_SYSSEEK (fp, new_offset, 0);
+  result = _IO_SYSSEEK (fp, new_offset, _IO_seek_set);
   if (result < 0)
     return EOF;
   if (delta == 0)
@@ -1102,7 +1102,7 @@ resync:
      we fopen a file and then do a fork. One process may access the
      file and the kernel file offset will be changed. */
   if (fp->_offset >= 0)
-    _IO_SYSSEEK (fp, fp->_offset, 0);
+    _IO_SYSSEEK (fp, fp->_offset, _IO_seek_set);
 
   return offset;
 }
@@ -1148,7 +1148,7 @@ _IO_file_seekoff_mmap (FILE *fp, off64_t offset, int dir, int mode)
       return EOF;
     }
 
-  result = _IO_SYSSEEK (fp, offset, 0);
+  result = _IO_SYSSEEK (fp, offset, _IO_seek_set);
   if (result < 0)
     return EOF;
 
diff --git glibc-clean/libio/libioP.h glibc-workdir/libio/libioP.h
index 1e3d28b..28f37aa 100644
--- glibc-clean/libio/libioP.h
+++ glibc-workdir/libio/libioP.h
@@ -54,9 +54,17 @@
    adjusts the libio configuration.  */
 #include <_G_config.h>
 
+/* These may be overridden by sysdeps _G_config.h for platforms with
+   different SEEK_* values (e.g., Ironclad).  */
+#ifndef _IO_seek_set
 #define _IO_seek_set 0
+#endif
+#ifndef _IO_seek_cur
 #define _IO_seek_cur 1
+#endif
+#ifndef _IO_seek_end
 #define _IO_seek_end 2
+#endif
 
 /* THE JUMPTABLE FUNCTIONS.
 
diff --git glibc-clean/libio/oldfileops.c glibc-workdir/libio/oldfileops.c
index a268ece..2b6cdea 100644
--- glibc-clean/libio/oldfileops.c
+++ glibc-workdir/libio/oldfileops.c
@@ -273,7 +273,7 @@ old_do_write (FILE *fp, const char *data, size_t to_do)
   else if (fp->_IO_read_end != fp->_IO_write_base)
     {
       off_t new_pos
-	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);
+	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, _IO_seek_cur);
       if (new_pos == _IO_pos_BAD)
 	return 0;
       fp->_old_offset = new_pos;
@@ -418,7 +418,7 @@ _IO_old_file_sync (FILE *fp)
       if (_IO_in_backup (fp))
 	delta -= eGptr () - Gbase ();
 #endif
-      off_t new_pos = _IO_SYSSEEK (fp, delta, 1);
+      off_t new_pos = _IO_SYSSEEK (fp, delta, _IO_seek_cur);
       if (new_pos != (off_t) EOF)
 	fp->_IO_read_end = fp->_IO_read_ptr;
       else if (errno == ESPIPE)
@@ -564,7 +564,7 @@ _IO_old_file_seekoff (FILE *fp, off64_t offset, int dir, int mode)
       new_offset = offset;
       delta = 0;
     }
-  result = _IO_SYSSEEK (fp, new_offset, 0);
+  result = _IO_SYSSEEK (fp, new_offset, _IO_seek_set);
   if (result < 0)
     return EOF;
   if (delta == 0)
@@ -607,7 +607,7 @@ resync:
      we fopen a file and then do a fork. One process may access the
      file and the kernel file offset will be changed. */
   if (fp->_old_offset >= 0)
-    _IO_SYSSEEK (fp, fp->_old_offset, 0);
+    _IO_SYSSEEK (fp, fp->_old_offset, _IO_seek_set);
 
   return offset;
 }
diff --git glibc-clean/libio/stdio.h glibc-workdir/libio/stdio.h
index d042b36..82a1c44 100644
--- glibc-clean/libio/stdio.h
+++ glibc-workdir/libio/stdio.h
@@ -105,14 +105,20 @@ typedef __fpos64_t fpos64_t;
 #define EOF (-1)
 
 
+/* Get the values:
+   FILENAME_MAX	Maximum length of a filename.  */
+#include <bits/stdio_lim.h>
+
 /* The possibilities for the third argument to `fseek'.
-   These values should not be changed.  */
-#define SEEK_SET	0	/* Seek from beginning of file.  */
-#define SEEK_CUR	1	/* Seek from current position.  */
-#define SEEK_END	2	/* Seek from end of file.  */
+   Get OS-specific values from bits/seek_whence.h.  */
+#include <bits/seek_whence.h>
 #ifdef __USE_GNU
-# define SEEK_DATA	3	/* Seek to next data.  */
-# define SEEK_HOLE	4	/* Seek to next hole.  */
+# ifndef SEEK_DATA
+#  define SEEK_DATA	3	/* Seek to next data.  */
+# endif
+# ifndef SEEK_HOLE
+#  define SEEK_HOLE	4	/* Seek to next hole.  */
+# endif
 #endif
 
 
@@ -124,10 +130,6 @@ typedef __fpos64_t fpos64_t;
 #define L_tmpnam 20
 #define TMP_MAX 238328
 
-/* Get the values:
-   FILENAME_MAX	Maximum length of a filename.  */
-#include <bits/stdio_lim.h>
-
 #ifdef __USE_POSIX
 # define L_ctermid 9
 # if !defined __USE_XOPEN2K || defined __USE_GNU
diff --git glibc-clean/libio/wfileops.c glibc-workdir/libio/wfileops.c
index 4882a33..f15bad0 100644
--- glibc-clean/libio/wfileops.c
+++ glibc-workdir/libio/wfileops.c
@@ -518,7 +518,7 @@ _IO_wfile_sync (FILE *fp)
 	  delta = -(fp->_IO_read_end - fp->_IO_read_base - nread);
 	}
 
-      new_pos = _IO_SYSSEEK (fp, delta, 1);
+      new_pos = _IO_SYSSEEK (fp, delta, _IO_seek_cur);
       if (new_pos != (off64_t) EOF)
 	{
 	  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;
@@ -892,7 +892,7 @@ _IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode)
       new_offset = offset;
       delta = 0;
     }
-  result = _IO_SYSSEEK (fp, new_offset, 0);
+  result = _IO_SYSSEEK (fp, new_offset, _IO_seek_set);
   if (result < 0)
     return EOF;
   if (delta == 0)
@@ -946,7 +946,7 @@ resync:
      we fopen a file and then do a fork. One process may access the
      file and the kernel file offset will be changed. */
   if (fp->_offset >= 0)
-    _IO_SYSSEEK (fp, fp->_offset, 0);
+    _IO_SYSSEEK (fp, fp->_offset, _IO_seek_set);
 
   return offset;
 }
diff --git glibc-clean/malloc/Makefile glibc-workdir/malloc/Makefile
index 83f6c87..3001d7d 100644
--- glibc-clean/malloc/Makefile
+++ glibc-workdir/malloc/Makefile
@@ -211,7 +211,9 @@ install-lib := libmcheck.a
 non-lib.a := libmcheck.a
 
 # Additional libraries.
-extra-libs = libmemusage libc_malloc_debug
+# Note: libmemusage and libc_malloc_debug disabled for Ironclad bootstrap
+# (they require __dso_handle from crtbegin.o which isn't available yet)
+extra-libs =
 extra-libs-others = $(extra-libs)
 
 # Helper objects for some tests.
diff --git glibc-clean/nptl/allocatestack.c glibc-workdir/nptl/allocatestack.c
index 800ca89..19456b9 100644
--- glibc-clean/nptl/allocatestack.c
+++ glibc-workdir/nptl/allocatestack.c
@@ -200,16 +200,17 @@ setup_stack_prot (char *mem, size_t size, struct pthread *pd,
   char *guard = guard_position (mem, size, guardsize, pd, pagesize_m1);
   if (atomic_load_relaxed (&allocate_stack_mode) == ALLOCATE_GUARD_MADV_GUARD)
     {
+#ifdef MADV_GUARD_INSTALL
       if (__madvise (guard, guardsize, MADV_GUARD_INSTALL) == 0)
 	{
 	  pd->stack_mode = ALLOCATE_GUARD_MADV_GUARD;
 	  return true;
 	}
-
-      /* If madvise fails it means the kernel does not support the guard
-	 advise (we assume that the syscall is available, guard is page-aligned
-	 and length is non negative).  The stack has already the expected
-	 protection flags, so it just need to PROT_NONE the guard area.  */
+#endif
+      /* If madvise fails (or MADV_GUARD_INSTALL is not available) it means
+	 the kernel does not support the guard advise.  The stack has already
+	 the expected protection flags, so it just needs to PROT_NONE the
+	 guard area.  */
       atomic_store_relaxed (&allocate_stack_mode, ALLOCATE_GUARD_PROT_NONE);
       if (__mprotect (guard, guardsize, PROT_NONE) != 0)
 	return false;
@@ -259,9 +260,12 @@ adjust_stack_prot (char *mem, size_t size, const struct pthread *pd,
   if (guardsize > pd->guardsize)
     {
       char *guard = guard_position (mem, size, guardsize, pd, pagesize_m1);
+#ifdef MADV_GUARD_INSTALL
       if (pd->stack_mode == ALLOCATE_GUARD_MADV_GUARD)
 	return __madvise (guard, guardsize, MADV_GUARD_INSTALL) == 0;
-      else if (pd->stack_mode == ALLOCATE_GUARD_PROT_NONE)
+      else
+#endif
+      if (pd->stack_mode == ALLOCATE_GUARD_PROT_NONE)
 	return __mprotect (guard, guardsize, PROT_NONE) == 0;
     }
   /* The current guard area is larger than the required one.  For
@@ -282,6 +286,7 @@ adjust_stack_prot (char *mem, size_t size, const struct pthread *pd,
   else if (pd->guardsize > guardsize)
     {
       size_t slacksize = pd->guardsize - guardsize;
+#ifdef MADV_GUARD_REMOVE
       if (pd->stack_mode == ALLOCATE_GUARD_MADV_GUARD)
 	{
 	  void *slack =
@@ -292,7 +297,9 @@ adjust_stack_prot (char *mem, size_t size, const struct pthread *pd,
 #endif
 	  return __madvise (slack, slacksize, MADV_GUARD_REMOVE) == 0;
 	}
-      else if (pd->stack_mode == ALLOCATE_GUARD_PROT_NONE)
+      else
+#endif
+      if (pd->stack_mode == ALLOCATE_GUARD_PROT_NONE)
 	{
 	  const int prot = stack_prot ();
 #if _STACK_GROWS_DOWN
@@ -495,9 +502,11 @@ allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
 
 	  /* Do madvise in case the tunable glibc.pthread.stack_hugetlb is
 	     set to 0, disabling hugetlb.  */
+#ifdef MADV_NOHUGEPAGE
 	  if (__glibc_unlikely (__nptl_stack_hugetlb == 0)
 	      && __madvise (mem, size, MADV_NOHUGEPAGE) != 0)
 	    return errno;
+#endif
 
 	  /* SIZE is guaranteed to be greater than zero.
 	     So we can never get a null pointer back from mmap.  */
diff --git glibc-clean/nptl/descr.h glibc-workdir/nptl/descr.h
index ada6867..4511659 100644
--- glibc-clean/nptl/descr.h
+++ glibc-workdir/nptl/descr.h
@@ -407,6 +407,11 @@ struct pthread
   bool exiting;
   int exit_lock; /* A low-level lock (for use with __libc_lock_init etc).  */
 
+  /* For Ironclad: userspace thread exit signaling (mlibc-style).
+     Set to 1 by the thread just before exit, with futex wake.
+     pthread_join waits on this instead of relying on kernel set_tid_address.  */
+  int did_exit;
+
   /* Used on strsignal.  */
   struct tls_internal_t tls_state;
 
diff --git glibc-clean/nptl/nptl_setxid.c glibc-workdir/nptl/nptl_setxid.c
index 3da0d19..3d3f24c 100644
--- glibc-clean/nptl/nptl_setxid.c
+++ glibc-workdir/nptl/nptl_setxid.c
@@ -158,7 +158,13 @@ setxid_signal_thread (struct xid_command *cmdp, struct pthread *t)
 
   int val;
   pid_t pid = __getpid ();
+#ifdef __ironclad__
+  /* Ironclad doesn't have tgkill - use send_signal, ignoring tid.  */
+  (void) t->tid;
+  val = INTERNAL_SYSCALL_CALL (send_signal, pid, SIGSETXID);
+#else
   val = INTERNAL_SYSCALL_CALL (tgkill, pid, t->tid, SIGSETXID);
+#endif
 
   /* If this failed, it must have had not started yet or else exited.  */
   if (!INTERNAL_SYSCALL_ERROR_P (val))
diff --git glibc-clean/nptl/pthread_create.c glibc-workdir/nptl/pthread_create.c
index e1033d4..e3e25b5 100644
--- glibc-clean/nptl/pthread_create.c
+++ glibc-workdir/nptl/pthread_create.c
@@ -88,8 +88,13 @@ late_init (void)
      structure.  It is already cleared.  */
   __sigaddset (&sa.sa_mask, SIGCANCEL);
   __sigaddset (&sa.sa_mask, SIGSETXID);
+#ifdef __ironclad__
+  /* Ironclad sigprocmask takes 3 args (no sigsetsize).  */
+  INTERNAL_SYSCALL_CALL (sigprocmask, SIG_UNBLOCK, &sa.sa_mask, NULL);
+#else
   INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_UNBLOCK, &sa.sa_mask,
 			 NULL, __NSIG_BYTES);
+#endif
 }
 
 /* Code to allocate and deallocate a stack.  */
@@ -311,11 +316,16 @@ static int create_thread (struct pthread *pd, const struct pthread_attr *attr,
 	{
 	  assert (*stopped_start);
 
+#ifdef __NR_sched_setaffinity
 	  int res = INTERNAL_SYSCALL_CALL (sched_setaffinity, pd->tid,
 					   attr->extension->cpusetsize,
 					   attr->extension->cpuset);
 	  if (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (res)))
 	    return INTERNAL_SYSCALL_ERRNO (res);
+#else
+	  /* Ironclad doesn't support CPU affinity - return ENOSYS.  */
+	  return ENOSYS;
+#endif
 	}
 
       /* Set the scheduling parameters.  */
@@ -380,6 +390,7 @@ start_thread (void *arg)
       __libc_fatal ("Fatal glibc error: rseq registration failed\n");
   }
 
+#ifdef __NR_set_robust_list
 #ifndef __ASSUME_SET_ROBUST_LIST
   if (__nptl_set_robust_list_avail)
 #endif
@@ -389,6 +400,7 @@ start_thread (void *arg)
       INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
 			     sizeof (struct robust_list_head));
     }
+#endif /* __NR_set_robust_list */
 
   /* This is where the try/finally block should be created.  For
      compilers without that support we do use setjmp.  */
@@ -506,8 +518,13 @@ start_thread (void *arg)
      computing the signal mask, to save stack space.  */
   internal_sigfillset (&pd->sigmask);
   internal_sigdelset (&pd->sigmask, SIGSETXID);
+#ifdef __ironclad__
+  /* Ironclad sigprocmask takes 3 args (no sigsetsize).  */
+  INTERNAL_SYSCALL_CALL (sigprocmask, SIG_BLOCK, &pd->sigmask, NULL);
+#else
   INTERNAL_SYSCALL_CALL (rt_sigprocmask, SIG_BLOCK, &pd->sigmask, NULL,
 			 __NSIG_BYTES);
+#endif
 
   /* Tell __pthread_kill_internal that this thread is about to exit.
      If there is a __pthread_kill_internal in progress, this delays
@@ -600,8 +617,23 @@ out:
 
      The exit code is zero since in case all threads exit by calling
      'pthread_exit' the exit status must be 0 (zero).  */
+
+  /* Ironclad userspace thread exit signaling (mlibc-style).
+     Signal thread exit to pthread_join waiters before calling exit syscall.
+     This is needed because Ironclad doesn't support set_tid_address.  */
+  atomic_store_release (&pd->did_exit, 1);
+  futex_wake ((unsigned int *) &pd->did_exit, INT_MAX, FUTEX_PRIVATE);
+
+#ifdef __ironclad__
+  /* On Ironclad, exit (syscall 0) terminates the entire process.
+     For thread exit, we must use exit_group (syscall 31) which maps
+     to Exit_Thread and only terminates the calling thread.  */
+  while (1)
+    INTERNAL_SYSCALL_CALL (exit_group, 0);
+#else
   while (1)
     INTERNAL_SYSCALL_CALL (exit, 0);
+#endif
 
   /* NOTREACHED */
 }
diff --git glibc-clean/nptl/pthread_join_common.c glibc-workdir/nptl/pthread_join_common.c
index ff389bf..92c73c4 100644
--- glibc-clean/nptl/pthread_join_common.c
+++ glibc-workdir/nptl/pthread_join_common.c
@@ -96,6 +96,23 @@ __pthread_clockjoin_ex (pthread_t threadid, void **thread_return,
 
       /* We need acquire MO here so that we synchronize with the
          kernel's store to 0 when the clone terminates. (see above)  */
+#ifdef __ironclad__
+      /* Ironclad doesn't support set_tid_address, so we use mlibc-style
+         userspace signaling.  The thread sets did_exit to 1 and does
+         futex_wake before calling exit.  */
+      int exited;
+      while ((exited = atomic_load_acquire (&pd->did_exit)) == 0)
+        {
+	  int ret = __futex_abstimed_wait_cancelable64 (
+	    (unsigned int *) &pd->did_exit, exited, clockid, abstime,
+	    FUTEX_PRIVATE);
+	  if (ret == ETIMEDOUT || ret == EOVERFLOW)
+	    {
+	      result = ret;
+	      break;
+	    }
+	}
+#else
       pid_t tid;
       while ((tid = atomic_load_acquire (&pd->tid)) != 0)
         {
@@ -113,6 +130,7 @@ __pthread_clockjoin_ex (pthread_t threadid, void **thread_return,
 	      break;
 	    }
 	}
+#endif
 
       pthread_cleanup_pop (0);
     }
diff --git glibc-clean/nptl/pthread_kill.c glibc-workdir/nptl/pthread_kill.c
index 3938e3f..2b738d7 100644
--- glibc-clean/nptl/pthread_kill.c
+++ glibc-workdir/nptl/pthread_kill.c
@@ -40,7 +40,13 @@ __pthread_kill_implementation (pthread_t threadid, int signo, int no_tid)
          below.  POSIX only guarantees delivery of a single signal,
          which may not be the right one.)  */
       pid_t tid = INTERNAL_SYSCALL_CALL (gettid);
+#ifdef __ironclad__
+      /* Ironclad doesn't have tgkill - use send_signal, ignoring tid.  */
+      int ret = INTERNAL_SYSCALL_CALL (send_signal, __getpid (), signo);
+      (void) tid;
+#else
       int ret = INTERNAL_SYSCALL_CALL (tgkill, __getpid (), tid, signo);
+#endif
       return INTERNAL_SYSCALL_ERROR_P (ret) ? INTERNAL_SYSCALL_ERRNO (ret) : 0;
     }
 
@@ -59,7 +65,13 @@ __pthread_kill_implementation (pthread_t threadid, int signo, int no_tid)
     ret = no_tid;
   else
     {
+#ifdef __ironclad__
+      /* Ironclad doesn't have tgkill - use send_signal, ignoring tid.  */
+      ret = INTERNAL_SYSCALL_CALL (send_signal, __getpid (), signo);
+      (void) pd->tid;
+#else
       ret = INTERNAL_SYSCALL_CALL (tgkill, __getpid (), pd->tid, signo);
+#endif
       ret = INTERNAL_SYSCALL_ERROR_P (ret) ? INTERNAL_SYSCALL_ERRNO (ret) : 0;
     }
 
@@ -76,7 +88,12 @@ int
 __pthread_raise_internal (int signo)
 {
   /* Use the gettid syscall so it works after vfork.  */
+#ifdef __ironclad__
+  /* Ironclad doesn't have tgkill - use send_signal, ignoring tid.  */
+  int ret = INTERNAL_SYSCALL_CALL (send_signal, __getpid (), signo);
+#else
   int ret = INTERNAL_SYSCALL_CALL (tgkill, __getpid (), __gettid(), signo);
+#endif
   return INTERNAL_SYSCALL_ERROR_P (ret) ? INTERNAL_SYSCALL_ERRNO (ret) : 0;
 }
 
diff --git glibc-clean/nptl/pthread_sigmask.c glibc-workdir/nptl/pthread_sigmask.c
index 752fd17..7a42dff 100644
--- glibc-clean/nptl/pthread_sigmask.c
+++ glibc-workdir/nptl/pthread_sigmask.c
@@ -37,8 +37,13 @@ __pthread_sigmask (int how, const sigset_t *newmask, sigset_t *oldmask)
     }
 
   /* We know that realtime signals are available if NPTL is used.  */
+#ifdef __ironclad__
+  /* Ironclad sigprocmask takes 3 args (no sigsetsize).  */
+  int result = INTERNAL_SYSCALL_CALL (sigprocmask, how, newmask, oldmask);
+#else
   int result = INTERNAL_SYSCALL_CALL (rt_sigprocmask, how, newmask,
 				      oldmask, __NSIG_BYTES);
+#endif
 
   return (INTERNAL_SYSCALL_ERROR_P (result)
 	  ? INTERNAL_SYSCALL_ERRNO (result)
diff --git glibc-clean/posix/unistd.h glibc-workdir/posix/unistd.h
index 3f4e426..a9aaa02 100644
--- glibc-clean/posix/unistd.h
+++ glibc-workdir/posix/unistd.h
@@ -201,6 +201,10 @@ __BEGIN_DECLS
 
 #include <bits/posix_opt.h>
 
+/* Get platform-specific access mode flags (R_OK, W_OK, X_OK, F_OK).
+   These may differ from POSIX defaults on some platforms.  */
+#include <bits/access.h>
+
 /* Get the environment definitions from Unix98.  */
 #if defined __USE_UNIX98 || defined __USE_XOPEN2K
 # include <bits/environments.h>
@@ -278,10 +282,18 @@ typedef __socklen_t socklen_t;
 
 /* Values for the second argument to access.
    These may be OR'd together.  */
-#define	R_OK	4		/* Test for read permission.  */
-#define	W_OK	2		/* Test for write permission.  */
-#define	X_OK	1		/* Test for execute permission.  */
-#define	F_OK	0		/* Test for existence.  */
+#ifndef R_OK
+# define R_OK	4		/* Test for read permission.  */
+#endif
+#ifndef W_OK
+# define W_OK	2		/* Test for write permission.  */
+#endif
+#ifndef X_OK
+# define X_OK	1		/* Test for execute permission.  */
+#endif
+#ifndef F_OK
+# define F_OK	0		/* Test for existence.  */
+#endif
 
 /* Test for access to NAME using the real UID and real GID.  */
 extern int access (const char *__name, int __type) __THROW __nonnull ((1));
@@ -311,14 +323,17 @@ extern int faccessat (int __fd, const char *__file, int __type, int __flag)
 #endif /* Use GNU.  */
 
 
-/* Values for the WHENCE argument to lseek.  */
+/* Values for the WHENCE argument to lseek.
+   Get OS-specific values from bits/seek_whence.h.  */
 #ifndef	_STDIO_H		/* <stdio.h> has the same definitions.  */
-# define SEEK_SET	0	/* Seek from beginning of file.  */
-# define SEEK_CUR	1	/* Seek from current position.  */
-# define SEEK_END	2	/* Seek from end of file.  */
+# include <bits/seek_whence.h>
 # ifdef __USE_GNU
-#  define SEEK_DATA	3	/* Seek to next data.  */
-#  define SEEK_HOLE	4	/* Seek to next hole.  */
+#  ifndef SEEK_DATA
+#   define SEEK_DATA	3	/* Seek to next data.  */
+#  endif
+#  ifndef SEEK_HOLE
+#   define SEEK_HOLE	4	/* Seek to next hole.  */
+#  endif
 # endif
 #endif
 
@@ -1139,9 +1154,11 @@ extern int lockf64 (int __fd, int __cmd, __off64_t __len) __wur;
        __result; }))
 
 /* Copy LENGTH bytes from INFD to OUTFD.  */
+#ifndef __ironclad__
 ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
 			 int __outfd, __off64_t *__poutoff,
 			 size_t __length, unsigned int __flags);
+#endif
 #endif /* __USE_GNU */
 
 #if defined __USE_POSIX199309 || defined __USE_UNIX98
diff --git glibc-clean/sysdeps/nptl/Subdirs glibc-workdir/sysdeps/nptl/Subdirs
index 36266c1..6c1aa44 100644
--- glibc-clean/sysdeps/nptl/Subdirs
+++ glibc-workdir/sysdeps/nptl/Subdirs
@@ -1,2 +1 @@
 nptl
-nptl_db
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/Implies glibc-workdir/sysdeps/unix/sysv/ironclad/Implies
new file mode 100644
index 0000000..4d73196
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/Implies
@@ -0,0 +1,8 @@
+# Ironclad builds use NPTL for threading.
+nptl
+
+# The gnu subdirectory exists for things common to GNU-like systems.
+gnu
+
+# Ironclad has network support in the kernel.
+unix/inet
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/Makefile glibc-workdir/sysdeps/unix/sysv/ironclad/Makefile
new file mode 100644
index 0000000..9d16290
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/Makefile
@@ -0,0 +1,115 @@
+# Makefile for Ironclad-specific glibc code.
+
+# Disable syscalls.list mechanism entirely for Ironclad.
+# All syscalls must have explicit .c implementations in sysdeps/unix/sysv/ironclad/
+# or return ENOSYS via stub implementations.  This prevents the make-syscalls.sh
+# script from auto-generating stubs that would use incorrect syscall numbers or
+# calling conventions.
+inhibit-unix-syscalls = yes
+
+# Headers to install for Ironclad.
+sysdep_headers += \
+  bits/pthread_stack_min-dynamic.h \
+  bits/pthread_stack_min.h \
+  bits/seek_whence.h \
+  bits/sigcontext.h \
+  bits/siginfo-arch.h \
+  bits/termios.h \
+  bits/termios-baud.h \
+  bits/termios-c_cc.h \
+  bits/termios-c_cflag.h \
+  bits/termios-c_iflag.h \
+  bits/termios-c_lflag.h \
+  bits/termios-c_oflag.h \
+  bits/termios-cbaud.h \
+  bits/termios-misc.h \
+  bits/termios-struct.h \
+  bits/termios-tcflow.h \
+  # sysdep_headers
+
+ifeq ($(subdir),csu)
+sysdep_routines += \
+  errno-loc \
+  # sysdep_routines
+endif
+
+ifeq ($(subdir),malloc)
+CFLAGS-malloc.c += -DMORECORE_CLEARS=2
+endif
+
+ifeq ($(subdir),misc)
+sysdep_routines += \
+  clone \
+  clone-internal \
+  clone-pidfd-support \
+  closefrom_fallback \
+  gettid \
+  mac \
+  mount \
+  prctl \
+  tgkill \
+  umount \
+  # sysdep_routines
+
+sysdep_headers += \
+  arch-syscall.h \
+  asm/ioctl.h \
+  asm/ioctls.h \
+  asm/prctl.h \
+  bits/syscall.h \
+  linux/fb.h \
+  sys/mac.h \
+  sys/mount.h \
+  sys/prctl.h \
+  sys/ptrace.h \
+  sys/reboot.h \
+  sys/syscall.h \
+  # sysdep_headers
+endif
+
+ifeq ($(subdir),socket)
+sysdep_headers += \
+  bits/socket_type.h \
+  # sysdep_headers
+endif
+
+ifeq ($(subdir),sysvipc)
+sysdep_headers += \
+  bits/shmlba.h \
+  # sysdep_headers
+endif
+
+ifeq ($(subdir),posix)
+sysdep_headers += \
+  bits/access.h \
+  # sysdep_headers
+endif
+
+ifeq ($(subdir),io)
+sysdep_routines += \
+  close_nocancel \
+  close_nocancel_nostatus \
+  fcntl_nocancel \
+  open64_nocancel \
+  openat_nocancel \
+  openat64_nocancel \
+  pread64_nocancel \
+  read_nocancel \
+  write_nocancel \
+  # sysdep_routines
+endif
+
+ifeq ($(subdir),elf)
+# rtld needs special versions of some routines that are compiled with
+# IS_IN(rtld) to avoid pulling in libc_early_init dependencies.
+# dl-brk and dl-sbrk are provided by elf/ and include our brk.c/sbrk.c.
+# dl-getcwd, dl-openat64, dl-opendir use the standard elf/ implementations.
+sysdep-rtld-routines += \
+  dl-brk \
+  dl-getcwd \
+  dl-openat64 \
+  dl-opendir \
+  dl-sbrk \
+  # sysdep-rtld-routines
+endif
+
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/Versions glibc-workdir/sysdeps/unix/sysv/ironclad/Versions
new file mode 100644
index 0000000..23b187c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/Versions
@@ -0,0 +1,51 @@
+# Version definitions for Ironclad-specific symbols.
+
+libc {
+  GLIBC_2.2.5 {
+    # Thread-safe errno location function - must be exported for programs to use.
+    __errno_location;
+    __h_errno_location;
+
+    # stat64 family - required for programs compiled with _FILE_OFFSET_BITS=64.
+    stat64;
+    lstat64;
+    fstat64;
+    fstatat64;
+    __stat64;
+    __lstat64;
+    __fstat64;
+    __fstatat64;
+
+    # Process tracing.
+    ptrace;
+
+    # System reboot/power control.
+    reboot;
+
+    # Filesystem mounting/unmounting.
+    mount;
+    umount;
+    umount2;
+  }
+  GLIBC_2.30 {
+    # Thread/process identification.
+    getdents64;
+    gettid;
+    tgkill;
+  }
+  GLIBC_2.42 {
+    # Ironclad MAC (Mandatory Access Control) API.
+    get_mac_capabilities;
+    set_mac_capabilities;
+    add_mac_permissions;
+    set_mac_enforcement;
+  }
+  GLIBC_PRIVATE {
+    # Functions used in other libraries (NSS, etc.).
+    __open_nocancel;
+    __read_nocancel;
+    __pread64_nocancel;
+    __close_nocancel;
+    __close_nocancel_nostatus;
+  }
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/_Fork.c glibc-workdir/sysdeps/unix/sysv/ironclad/_Fork.c
new file mode 100644
index 0000000..101d9f6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/_Fork.c
@@ -0,0 +1,44 @@
+#include <arch-fork.h>
+#include <libc-lock.h>
+#include <pthreadP.h>
+#include <getrandom-internal.h>
+
+pid_t
+_Fork (void)
+{
+  /* Block all signals to avoid revealing the inconsistent TCB state
+     to a signal handler after fork.  The abort lock should AS-safe
+     to avoid deadlock if _Fork is called from a signal handler.  */
+  internal_sigset_t original_sigmask;
+  __abort_lock_rdlock (&original_sigmask);
+
+  pid_t pid = arch_fork (&THREAD_SELF->tid);
+  if (pid == 0)
+    {
+      struct pthread *self = THREAD_SELF;
+
+      /* Initialize the robust mutex list setting in the kernel which has
+	 been reset during the fork.  We do not check for errors because if
+	 it fails here, it must have failed at process startup as well and
+	 nobody could have used robust mutexes.
+	 Before we do that, we have to clear the list of robust mutexes
+	 because we do not inherit ownership of mutexes from the parent.
+	 We do not have to set self->robust_head.futex_offset since we do
+	 inherit the correct value from the parent.  We do not need to clear
+	 the pending operation because it must have been zero when fork was
+	 called.  */
+#if __PTHREAD_MUTEX_HAVE_PREV
+      self->robust_prev = &self->robust_head;
+#endif
+      self->robust_head.list = &self->robust_head;
+#ifndef __ironclad__
+      INTERNAL_SYSCALL_CALL (set_robust_list, &self->robust_head,
+			     sizeof (struct robust_list_head));
+#endif
+      call_function_static_weak (__getrandom_fork_subprocess);
+    }
+
+  __abort_lock_unlock (&original_sigmask);
+  return pid;
+}
+libc_hidden_def (_Fork)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/_G_config.h glibc-workdir/sysdeps/unix/sysv/ironclad/_G_config.h
new file mode 100644
index 0000000..17c1f74
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/_G_config.h
@@ -0,0 +1,23 @@
+/* Configuration parameters for stdio - Ironclad version.  */
+
+#ifndef __G_CONFIG_H
+#define __G_CONFIG_H 1
+
+/* Define to 1 if the operating system supports mmap, 0 otherwise.
+   This function is required by POSIX but might still be unavailable,
+   for instance when the hardware lacks support for virtual memory.  */
+#define _G_HAVE_MMAP 1
+
+/* Define to 1 if the operating system supports mremap, 0 otherwise.
+   mremap is Linux-specific extension, not available on Ironclad.  */
+#define _G_HAVE_MREMAP 0
+
+/* Ironclad uses different SEEK_* values than Linux.
+   Define _IO_seek_* to match before libioP.h defines them.
+   Ironclad: SEEK_SET=1, SEEK_CUR=2, SEEK_END=4
+   Linux:    SEEK_SET=0, SEEK_CUR=1, SEEK_END=2  */
+#define _IO_seek_set 1
+#define _IO_seek_cur 2
+#define _IO_seek_end 4
+
+#endif	/* bits/_G_config.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/____longjmp_chk.c glibc-workdir/sysdeps/unix/sysv/ironclad/____longjmp_chk.c
new file mode 100644
index 0000000..c3ae276
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/____longjmp_chk.c
@@ -0,0 +1,13 @@
+/* Ironclad: Simplified version - just perform the longjmp.
+   Full stack frame checking requires architecture-specific jmpbuf access
+   which isn't available for all targets.  */
+
+#include <setjmp.h>
+
+_Noreturn extern void ____longjmp_chk (__jmp_buf __env, int __val);
+
+void ____longjmp_chk (__jmp_buf env, int val)
+{
+  /* For Ironclad, just do the longjmp without extra checking.  */
+  __longjmp (env, val);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/_exit.c glibc-workdir/sysdeps/unix/sysv/ironclad/_exit.c
new file mode 100644
index 0000000..222c223
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/_exit.c
@@ -0,0 +1,26 @@
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <abort-instr.h>
+
+
+void
+_exit (int status)
+{
+  while (1)
+    {
+      /* Ironclad: use exit (syscall 0) not exit_group (syscall 31).
+         exit_group on Ironclad is Exit_Thread which only exits a thread,
+         not the whole process. exit calls Exit_Process which properly
+         signals the parent.  */
+      INLINE_SYSCALL (exit, 1, status);
+
+#ifdef ABORT_INSTRUCTION
+      ABORT_INSTRUCTION;
+#endif
+    }
+}
+libc_hidden_def (_exit)
+rtld_hidden_def (_exit)
+weak_alias (_exit, _Exit)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/accept.c glibc-workdir/sysdeps/unix/sysv/ironclad/accept.c
new file mode 100644
index 0000000..de0d175
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/accept.c
@@ -0,0 +1,9 @@
+#include <sys/socket.h>
+
+int
+__libc_accept (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return accept4 (fd, addr, len, 0);
+}
+weak_alias (__libc_accept, accept)
+libc_hidden_def (accept)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/accept4.c glibc-workdir/sysdeps/unix/sysv/ironclad/accept4.c
new file mode 100644
index 0000000..ed350dc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/accept4.c
@@ -0,0 +1,9 @@
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+int
+accept4 (int fd, __SOCKADDR_ARG addr, socklen_t *addr_len, int flags)
+{
+  /* Ironclad accept syscall: fd, addr, addr_len, flags */
+  return SYSCALL_CANCEL (accept, fd, addr.__sockaddr__, addr_len, flags);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/access.c glibc-workdir/sysdeps/unix/sysv/ironclad/access.c
new file mode 100644
index 0000000..5c668d2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/access.c
@@ -0,0 +1,15 @@
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+int
+__access (const char *file, int type)
+{
+  /* Ironclad access syscall: (dirfd, path, path_len, mode, flags).
+     Compute path_len first to avoid issues with macro expansion.  */
+  size_t path_len = __builtin_strlen (file);
+  /* Ironclad syscall is named 'access' not 'faccessat'.  */
+  return INLINE_SYSCALL_CALL (access, AT_FDCWD, file, path_len, type, 0);
+}
+libc_hidden_def (__access)
+weak_alias (__access, access)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/arch-fd_to_filename.h glibc-workdir/sysdeps/unix/sysv/ironclad/arch-fd_to_filename.h
new file mode 100644
index 0000000..85521d1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/arch-fd_to_filename.h
@@ -0,0 +1,4 @@
+/* Ironclad does not have /proc or /dev/fd.  This path is intentionally
+   invalid so that operations like freopen(NULL, mode, stream) fail with
+   ENOENT rather than appearing to work with a nonexistent procfs.  */
+#define FD_TO_FILENAME_PREFIX "/UNSUPPORTED/fd/"
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/arch-fork.h glibc-workdir/sysdeps/unix/sysv/ironclad/arch-fork.h
new file mode 100644
index 0000000..8d91ef4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/arch-fork.h
@@ -0,0 +1,24 @@
+#ifndef __ARCH_FORK_H
+#define __ARCH_FORK_H
+
+#include <sysdep.h>
+#include <sched.h>
+#include <signal.h>
+#include <unistd.h>
+
+/* Call the fork syscall with fork semantic.
+   Ironclad fork syscall takes a single argument:
+   0 = fork (copy-on-write)
+   1 = vfork (share address space)
+
+   The CTID address is not used on Ironclad - child TID features
+   are not supported by the fork syscall.  */
+static inline pid_t
+arch_fork (void *ctid)
+{
+  (void) ctid;  /* Ironclad fork doesn't support child TID pointers.  */
+  /* Use fork syscall (not clone) with argument 0 for normal fork.  */
+  return INLINE_SYSCALL_CALL (fork, 0);
+}
+
+#endif /* __ARCH_FORK_H  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/asm/ioctl.h glibc-workdir/sysdeps/unix/sysv/ironclad/asm/ioctl.h
new file mode 100644
index 0000000..979a8b9
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/asm/ioctl.h
@@ -0,0 +1,63 @@
+#ifndef _ASM_IOCTL_H
+#define _ASM_IOCTL_H
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+   size of the parameter structure in the lower 14 bits of the
+   upper 16 bits.
+   Encoding the size of the parameter structure in the ioctl request
+   is useful for catching programs compiled with old versions
+   and to avoid overwriting user space outside the user buffer area.
+   The highest 2 bits are reserved for indicating the ``access mode''.
+   NOTE: This limits the max parameter size to 16kB -1 !  */
+
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	14
+#define _IOC_DIRBITS	2
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/* Direction bits.  */
+#define _IOC_NONE	0U
+#define _IOC_WRITE	1U
+#define _IOC_READ	2U
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+#define _IOC_TYPECHECK(t) (sizeof(t))
+
+/* Used to create numbers.  */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
+#define _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* Used to decode ioctl numbers.  */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files...  */
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_IOCTL_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/asm/ioctls.h glibc-workdir/sysdeps/unix/sysv/ironclad/asm/ioctls.h
new file mode 100644
index 0000000..84ad9a8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/asm/ioctls.h
@@ -0,0 +1,111 @@
+#ifndef _ASM_IOCTLS_H
+#define _ASM_IOCTLS_H
+
+/* List of all the IOCTLs supported by Ironclad.
+   Based on mlibc's Ironclad implementation.  */
+
+/* PS/2 Mouse IOCTLs */
+#define PS2MOUSE_2_1_SCALING     1
+#define PS2MOUSE_1_1_SCALING     2
+#define PS2MOUSE_SET_RES         3
+#define PS2MOUSE_SET_SAMPLE_RATE 4
+
+/* RTC IOCTLs */
+#define RTC_RD_TIME              1
+#define RTC_SET_TIME             2
+
+/* File/TTY IOCTLs */
+#define FIOQSIZE                 0x5460
+#define TCGETS                   0x5401
+#define TCSETS                   0x5402
+#define TCSETSW                  0x5403
+#define TCSETSF                  0x5404
+#define TCGETA                   0x5405
+#define TCSETA                   0x5406
+#define TCSETAW                  0x5407
+#define TCSETAF                  0x5408
+#define TCSBRK                   0x5409
+#define TCXONC                   0x540A
+#define TCFLSH                   0x540B
+#define TIOCEXCL                 0x540C
+#define TIOCNXCL                 0x540D
+#define TIOCSCTTY                0x540E
+#define TIOCGPGRP                0x540F
+#define TIOCSPGRP                0x5410
+#define TIOCOUTQ                 0x5411
+#define TIOCSTI                  0x5412
+#define TIOCGWINSZ               0x5413
+#define TIOCSWINSZ               0x5414
+#define TIOCMGET                 0x5415
+#define TIOCMBIS                 0x5416
+#define TIOCMBIC                 0x5417
+#define TIOCMSET                 0x5418
+#define TIOCGSOFTCAR             0x5419
+#define TIOCSSOFTCAR             0x541A
+#define FIONREAD                 0x541B
+#define TIOCINQ                  FIONREAD
+#define TIOCLINUX                0x541C
+#define TIOCCONS                 0x541D
+#define TIOCGSERIAL              0x541E
+#define TIOCSSERIAL              0x541F
+#define TIOCPKT                  0x5420
+#define FIONBIO                  0x5421
+#define TIOCNOTTY                0x5422
+#define TIOCSETD                 0x5423
+#define TIOCGETD                 0x5424
+#define TCSBRKP                  0x5425
+#define TIOCSBRK                 0x5427
+#define TIOCCBRK                 0x5428
+#define TIOCGSID                 0x5429
+#define TCGETS2                  3
+#define TCSETS2                  3
+#define TCSETSW2                 3
+#define TCSETSF2                 3
+#define TIOCGRS485               0x542E
+#define TIOCSRS485               0x542F
+#define TIOCGPTN                 3
+#define TIOCSPTLCK               0x5430
+#define TIOCGDEV                 3
+#define TCGETX                   0x5432
+#define TCSETX                   0x5433
+#define TCSETXF                  0x5434
+#define TCSETXW                  0x5435
+#define TIOCSIG                  0x36
+#define TIOCVHANGUP              0x5437
+#define TIOCGPKT                 3
+#define TIOCGPTLCK               3
+#define TIOCGEXCL                3
+#define TIOCGPTPEER              3
+#define TIOCGISO7816             3
+#define TIOCSISO7816             3
+#define FIONCLEX                 0x5450
+#define FIOCLEX                  0x5451
+#define FIOASYNC                 0x5452
+#define TIOCSERCONFIG            0x5453
+#define TIOCSERGWILD             0x5454
+#define TIOCSERSWILD             0x5455
+#define TIOCGLCKTRMIOS           0x5456
+#define TIOCSLCKTRMIOS           0x5457
+#define TIOCSERGSTRUCT           0x5458
+#define TIOCSERGETLSR            0x5459
+#define TIOCSERGETMULTI          0x545A
+#define TIOCSERSETMULTI          0x545B
+#define TIOCMIWAIT               0x545C
+#define TIOCGICOUNT              0x545D
+
+/* TIOCPKT bits */
+#define TIOCPKT_DATA             0
+#define TIOCPKT_FLUSHREAD        1
+#define TIOCPKT_FLUSHWRITE       2
+#define TIOCPKT_STOP             4
+#define TIOCPKT_START            8
+#define TIOCPKT_NOSTOP           16
+#define TIOCPKT_DOSTOP           32
+#define TIOCPKT_IOCTL            64
+
+#define TIOCSER_TEMT             0x01
+
+/* Device-specific IOCTLs */
+#define DEV_PARTUUID             0x9821
+
+#endif /* _ASM_IOCTLS_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/asm/prctl.h glibc-workdir/sysdeps/unix/sysv/ironclad/asm/prctl.h
new file mode 100644
index 0000000..641085b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/asm/prctl.h
@@ -0,0 +1,11 @@
+#ifndef _ASM_PRCTL_H
+#define _ASM_PRCTL_H
+
+/* Ironclad uses different values than Linux for arch_prctl.
+   Based on mlibc's Ironclad implementation.  */
+#define ARCH_SET_FS	1
+#define ARCH_GET_FS	2
+#define ARCH_SET_GS	3
+#define ARCH_GET_GS	4
+
+#endif /* _ASM_PRCTL_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bind.c glibc-workdir/sysdeps/unix/sysv/ironclad/bind.c
new file mode 100644
index 0000000..08eb1e0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bind.c
@@ -0,0 +1,9 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+int
+__bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
+{
+  return INLINE_SYSCALL_CALL (bind, fd, addr.__sockaddr__, len);
+}
+weak_alias (__bind, bind)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/access.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/access.h
new file mode 100644
index 0000000..507fd7d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/access.h
@@ -0,0 +1,12 @@
+#ifndef _BITS_ACCESS_H
+#define _BITS_ACCESS_H	1
+
+/* Ironclad access mode flags - these have different values than Linux!
+   Ironclad: F_OK=1, R_OK=2, W_OK=4, X_OK=8
+   Linux:    F_OK=0, R_OK=4, W_OK=2, X_OK=1  */
+#define R_OK	2		/* Test for read permission.  */
+#define W_OK	4		/* Test for write permission.  */
+#define X_OK	8		/* Test for execute permission.  */
+#define F_OK	1		/* Test for existence.  */
+
+#endif /* _BITS_ACCESS_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/dirent.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/dirent.h
new file mode 100644
index 0000000..889c63f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/dirent.h
@@ -0,0 +1,42 @@
+#ifndef _DIRENT_H
+# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
+#endif
+
+struct dirent
+  {
+#ifndef __USE_FILE_OFFSET64
+    __ino_t d_ino;
+    __off_t d_off;
+#else
+    __ino64_t d_ino;
+    __off64_t d_off;
+#endif
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];		/* We must not include limits.h! */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct dirent64
+  {
+    __ino64_t d_ino;
+    __off64_t d_off;
+    unsigned short int d_reclen;
+    unsigned char d_type;
+    char d_name[256];		/* We must not include limits.h! */
+  };
+#endif
+
+#define d_fileno	d_ino	/* Backwards compatibility.  */
+
+#undef  _DIRENT_HAVE_D_NAMLEN
+#define _DIRENT_HAVE_D_RECLEN
+#define _DIRENT_HAVE_D_OFF
+#define _DIRENT_HAVE_D_TYPE
+
+#if defined __OFF_T_MATCHES_OFF64_T && defined __INO_T_MATCHES_INO64_T
+/* Inform libc code that these two types are effectively identical.  */
+# define _DIRENT_MATCHES_DIRENT64	1
+#else
+# define _DIRENT_MATCHES_DIRENT64	0
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/errno.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/errno.h
new file mode 100644
index 0000000..084c46b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/errno.h
@@ -0,0 +1,134 @@
+#ifndef _BITS_ERRNO_H
+#define _BITS_ERRNO_H 1
+
+#if !defined _ERRNO_H
+# error "Never include <bits/errno.h> directly; use <errno.h> instead."
+#endif
+
+/* Userland errno simulated for libc compat */
+#define EDOM   1
+#define EILSEQ 2
+#define ERANGE 3
+
+/* Errno returned by the Ironclad kernel directly (and are ABI) */
+#define E2BIG 1001
+#define EACCES 1002
+#define EADDRINUSE 1003
+#define EADDRNOTAVAIL 1004
+#define EAFNOSUPPORT 1005
+#define EAGAIN 1006
+#define EALREADY 1007
+#define EBADF 1008
+#define EBADMSG 1009
+#define EBUSY 1010
+#define ECANCELED 1011
+#define ECHILD 1012
+#define ECONNABORTED 1013
+#define ECONNREFUSED 1014
+#define ECONNRESET 1015
+#define EDEADLK 1016
+#define EDESTADDRREQ 1017
+#define EDQUOT 1018
+#define EEXIST 1019
+#define EFAULT 1020
+#define EFBIG 1021
+#define EHOSTUNREACH 1022
+#define EIDRM 1023
+#define EINPROGRESS 1024
+#define EINTR 1025
+#define EINVAL 1026
+#define EIO 1027
+#define EISCONN 1028
+#define EISDIR 1029
+#define ELOOP 1030
+#define EMFILE 1031
+#define EMLINK 1032
+#define EMSGSIZE 1034
+#define EMULTIHOP 1035
+#define ENAMETOOLONG 1036
+#define ENETDOWN 1037
+#define ENETRESET 1038
+#define ENETUNREACH 1039
+#define ENFILE 1040
+#define ENOBUFS 1041
+#define ENODEV 1042
+#define ENOENT 1043
+#define ENOEXEC 1044
+#define ENOLCK 1045
+#define ENOLINK 1046
+#define ENOMEM 1047
+#define ENOMSG 1048
+#define ENOPROTOOPT 1049
+#define ENOSPC 1050
+#define ENOSYS 1051
+#define ENOTCONN 1052
+#define ENOTDIR 1053
+#define ENOTEMPTY 1054
+#define ENOTRECOVERABLE 1055
+#define ENOTSOCK 1056
+#define ENOTSUP 1057
+#define ENOTTY 1058
+#define ENXIO 1059
+#define EOPNOTSUPP 1060
+#define EOVERFLOW 1061
+#define EOWNERDEAD 1062
+#define EPERM 1063
+#define EPIPE 1064
+#define EPROTO 1065
+#define EPROTONOSUPPORT 1066
+#define EPROTOTYPE 1067
+#define EROFS 1068
+#define ESPIPE 1069
+#define ESRCH 1070
+#define ESTALE 1071
+#define ETIMEDOUT 1072
+#define ETXTBSY 1073
+#define EWOULDBLOCK EAGAIN
+#define EXDEV 1075
+#define ENODATA 1076
+#define ETIME 1077
+#define ENOKEY 1078
+#define ESHUTDOWN 1079
+#define EHOSTDOWN 1080
+#define EBADFD 1081
+#define ENOMEDIUM 1082
+#define ENOTBLK 1083
+#define ENONET 1084
+#define EPFNOSUPPORT 1085
+#define ESOCKTNOSUPPORT 1086
+#define ESTRPIPE 1087
+#define EREMOTEIO 1088
+#define ERFKILL 1089
+#define EBADR 1090
+#define EUNATCH 1091
+#define EMEDIUMTYPE 1092
+#define EREMOTE 1093
+#define EKEYREJECTED 1094
+#define EUCLEAN 1095
+#define EBADSLT 1096
+#define ENOANO 1097
+#define ENOCSI 1098
+#define ENOSTR 1099
+#define ETOOMANYREFS 1100
+#define ENOPKG 1101
+#define EKEYREVOKED 1102
+#define EXFULL 1103
+#define ELNRNG 1104
+#define ENOTUNIQ 1105
+#define ERESTART 1106
+#define EUSERS 1107
+#define ECHRNG 1108
+#define ELIBBAD 1109
+#define EL2HLT 1110
+#define EL3HLT 1111
+#define EKEYEXPIRED 1112
+#define ECOMM 1113
+#define EBADE 1114
+#define EHWPOISON 1115
+#define EBADRQC 1116
+#define EPROGMISMATCH 1117
+
+/* Note: mlibc defines EIEIO=1524152434 as a sentinel value, but including it
+   here would cause glibc's errlist array to become enormous.  Not defined.  */
+
+#endif /* _BITS_ERRNO_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/fcntl.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/fcntl.h
new file mode 100644
index 0000000..5c1a740
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/fcntl.h
@@ -0,0 +1,156 @@
+#ifndef _FCNTL_H
+# error "Never include <bits/fcntl.h> directly; use <fcntl.h> instead."
+#endif
+
+#ifndef _BITS_FCNTL_H
+#define _BITS_FCNTL_H	1
+
+/* Ironclad file access mode flags.  */
+#define O_ACCMODE	(3 << 0)
+#define O_RDONLY	(1 << 0)
+#define O_WRONLY	(1 << 1)
+#define O_RDWR		(3 << 0)
+
+/* Ironclad open flags.  */
+#define O_APPEND	(1 << 2)
+#define O_CLOEXEC	(1 << 3)
+#define O_NOFOLLOW	(1 << 4)
+#define O_NONBLOCK	(1 << 5)
+#define O_CLOFORK	(1 << 6)	/* Ironclad-specific: close on fork.  */
+
+/* Flags emulated by userland.  */
+#define O_CREAT		(1 << 7)
+#define O_EXCL		(1 << 8)
+#define O_TRUNC		(1 << 9)
+
+/* Additional flags.  */
+#define O_SEARCH	(1 << 10)
+#define O_EXEC		(1 << 11)
+#define O_NOCTTY	(1 << 12)
+#define O_DSYNC		(1 << 13)
+#define O_RSYNC		(1 << 14)
+#define O_SYNC		(1 << 15)
+#define O_PATH		(1 << 16)
+#define O_DIRECTORY	(1 << 17)
+#define O_LARGEFILE	(1 << 18)
+#define O_NOATIME	(1 << 19)
+#define O_TMPFILE	(1 << 20)
+
+#define O_NDELAY	O_NONBLOCK
+
+/* Fcntl commands (matching mlibc abis/ironclad/fcntl.h).  */
+#define F_DUPFD		1
+#define F_DUPFD_CLOEXEC	2
+#define F_GETFD		3
+#define F_SETFD		4
+#define F_GETFL		5
+#define F_SETFL		6
+#define F_GETPIPE_SZ	7
+#define F_SETPIPE_SZ	8
+#define F_GETLK		9
+#define F_SETLK		10
+#define F_SETLKW	11
+#define F_DUPFD_CLOFORK	12	/* Ironclad-specific.  */
+/* Note: mlibc defines F_GETOWN=10, F_SETOWN=11 which conflict with F_SETLK/F_SETLKW.
+   These are marked as "stubbed" in mlibc and likely not implemented in the kernel.
+   We match mlibc's values for ABI compatibility.  */
+#define F_GETOWN	10
+#define F_SETOWN	11
+#define F_GETLK64	F_GETLK
+#define F_SETLK64	F_SETLK
+#define F_SETLKW64	F_SETLKW
+
+/* File descriptor flags.  */
+#define FD_CLOEXEC	1
+#define FD_CLOFORK	2	/* Ironclad-specific.  */
+
+/* File lock types.  */
+#define F_RDLCK		1
+#define F_UNLCK		2
+#define F_WRLCK		3
+
+/* For posix fcntl() and `l_type' field of a `struct flock'.  */
+#define F_EXLCK		4
+#define F_SHLCK		8
+
+/* Access mode flags for Ironclad - these have different values than Linux!
+   Ironclad: F_OK=1, R_OK=2, W_OK=4, X_OK=8
+   Linux:    F_OK=0, R_OK=4, W_OK=2, X_OK=1
+   Defining them here before io/fcntl.h ensures the correct values are used.
+   io/fcntl.h wraps its definitions in #ifndef guards.  */
+#define R_OK	2		/* Test for read permission.  */
+#define W_OK	4		/* Test for write permission.  */
+#define X_OK	8		/* Test for execute permission.  */
+#define F_OK	1		/* Test for existence.  */
+
+/* AT_* flags for Ironclad - these have different values than Linux!
+   Defining them here before io/fcntl.h ensures the correct values are used.
+   io/fcntl.h wraps its definitions in #ifndef guards.
+   Only constants defined in mlibc abis/ironclad/fcntl.h are included.  */
+#ifdef __USE_ATFILE
+# define AT_FDCWD		(-100)
+# define AT_SYMLINK_NOFOLLOW	2	/* Do not follow symbolic links.  */
+# define AT_REMOVEDIR		500	/* Remove directory instead of file.  */
+# define AT_SYMLINK_FOLLOW	0	/* Follow symbolic links.  */
+# define AT_EACCESS		512	/* Test access for effective IDs.  */
+# ifdef __USE_GNU
+#  define AT_EMPTY_PATH		1	/* Allow empty relative pathname.  */
+# endif
+#endif
+
+/* fadvise constants.  */
+#define POSIX_FADV_NORMAL	1
+#define POSIX_FADV_SEQUENTIAL	2
+#define POSIX_FADV_NOREUSE	3
+#define POSIX_FADV_DONTNEED	4
+#define POSIX_FADV_WILLNEED	5
+#define POSIX_FADV_RANDOM	6
+
+/* Lock structure for fcntl.  */
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#define flock64 flock
+
+/* Operations for BSD flock, also used by the kernel implementation.  */
+#ifdef __USE_MISC
+# define LOCK_SH	1	/* Shared lock.  */
+# define LOCK_EX	2	/* Exclusive lock.  */
+# define LOCK_NB	4	/* Or'd with one of the above to prevent
+				   blocking.  */
+# define LOCK_UN	8	/* Remove lock.  */
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_MISC
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_SYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use misc.  */
+
+#define O_FSYNC		O_SYNC
+
+#ifdef __USE_GNU
+/* Types of seals (matching mlibc abis/ironclad/fcntl.h).  */
+# define F_SEAL_SHRINK	0x0002	/* Prevent file from shrinking.  */
+# define F_SEAL_GROW	0x0004	/* Prevent file from growing.  */
+# define F_SEAL_WRITE	0x0008	/* Prevent writes.  */
+# define F_SEAL_SEAL	0x0010	/* Prevent further seals from being set.  */
+
+/* Seal fcntl commands (from mlibc).  */
+# define F_ADD_SEALS	1033	/* Add seals to file.  */
+# define F_GET_SEALS	1034	/* Get seals of file.  */
+#endif
+
+/* Note: SYNC_FILE_RANGE_*, SPLICE_F_*, file_handle, MAX_HANDLE_SZ are not
+   defined because Ironclad/mlibc does not support them.  */
+
+#endif /* _BITS_FCNTL_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ioctls.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ioctls.h
new file mode 100644
index 0000000..696825e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ioctls.h
@@ -0,0 +1,176 @@
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctls.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+#ifndef _BITS_IOCTLS_H
+#define _BITS_IOCTLS_H 1
+
+/* Include ioctl number construction macros (_IO, _IOR, _IOW, _IOWR).  */
+#include <asm/ioctl.h>
+
+/* Terminal ioctl commands.  */
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+/* TIOCPKT mode bits (for packet mode PTY master).  */
+#define TIOCPKT_DATA		0
+#define TIOCPKT_FLUSHREAD	1
+#define TIOCPKT_FLUSHWRITE	2
+#define TIOCPKT_STOP		4
+#define TIOCPKT_START		8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+#define TIOCPKT_IOCTL		64
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425
+#define TIOCSBRK	0x5427
+#define TIOCCBRK	0x5428
+#define TIOCGSID	0x5429
+#define TIOCGRS485	0x542E
+#define TIOCSRS485	0x542F
+#define TIOCSPTLCK	0x5430	/* PTY lock/unlock */
+#define TCGETX		0x5432
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+#define TIOCSIG		0x36
+#define TIOCVHANGUP	0x5437
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458
+#define TIOCSERGETLSR	0x5459
+#define TIOCSERGETMULTI 0x545A
+#define TIOCSERSETMULTI 0x545B
+#define TIOCMIWAIT	0x545C
+#define TIOCGICOUNT	0x545D
+
+/* Modem control line bits for TIOCMGET/TIOCMSET/TIOCMBIS/TIOCMBIC.  */
+#define TIOCM_LE	0x001	/* Line enable.  */
+#define TIOCM_DTR	0x002	/* Data terminal ready.  */
+#define TIOCM_RTS	0x004	/* Request to send.  */
+#define TIOCM_ST	0x008	/* Secondary transmit.  */
+#define TIOCM_SR	0x010	/* Secondary receive.  */
+#define TIOCM_CTS	0x020	/* Clear to send.  */
+#define TIOCM_CAR	0x040	/* Carrier detect.  */
+#define TIOCM_RNG	0x080	/* Ring.  */
+#define TIOCM_DSR	0x100	/* Data set ready.  */
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+
+/* Socket-level I/O control commands.  */
+#define SIOCADDRT	0x890B
+#define SIOCDELRT	0x890C
+#define SIOCRTMSG	0x890D
+#define SIOCGIFNAME	0x8910
+#define SIOCSIFLINK	0x8911
+#define SIOCGIFCONF	0x8912
+#define SIOCGIFFLAGS	0x8913
+#define SIOCSIFFLAGS	0x8914
+#define SIOCGIFADDR	0x8915
+#define SIOCSIFADDR	0x8916
+#define SIOCGIFDSTADDR	0x8917
+#define SIOCSIFDSTADDR	0x8918
+#define SIOCGIFBRDADDR	0x8919
+#define SIOCSIFBRDADDR	0x891A
+#define SIOCGIFNETMASK	0x891B
+#define SIOCSIFNETMASK	0x891C
+#define SIOCGIFMETRIC	0x891D
+#define SIOCSIFMETRIC	0x891E
+#define SIOCGIFMEM	0x891F
+#define SIOCSIFMEM	0x8920
+#define SIOCGIFMTU	0x8921
+#define SIOCSIFMTU	0x8922
+#define SIOCSIFNAME	0x8923
+#define SIOCSIFHWADDR	0x8924
+#define SIOCGIFENCAP	0x8925
+#define SIOCSIFENCAP	0x8926
+#define SIOCGIFHWADDR	0x8927
+#define SIOCGIFSLAVE	0x8929
+#define SIOCSIFSLAVE	0x8930
+#define SIOCADDMULTI	0x8931
+#define SIOCDELMULTI	0x8932
+#define SIOCGIFINDEX	0x8933
+#define SIOCSIFPFLAGS	0x8934
+#define SIOCGIFPFLAGS	0x8935
+#define SIOCDIFADDR	0x8936
+#define SIOCSIFHWBROADCAST 0x8937
+#define SIOCGIFCOUNT	0x8938
+
+#define SIOCGIFBR	0x8940
+#define SIOCSIFBR	0x8941
+
+#define SIOCGIFTXQLEN	0x8942
+#define SIOCSIFTXQLEN	0x8943
+
+#define SIOCDARP	0x8953
+#define SIOCGARP	0x8954
+#define SIOCSARP	0x8955
+
+#define SIOCDRARP	0x8960
+#define SIOCGRARP	0x8961
+#define SIOCSRARP	0x8962
+
+#define SIOCGIFMAP	0x8970
+#define SIOCSIFMAP	0x8971
+
+#define SIOCADDDLCI	0x8980
+#define SIOCDELDLCI	0x8981
+
+#define SIOCATMARK	0x8905
+#define SIOCPROTOPRIVATE 0x89E0
+
+#define FIOQSIZE	0x5460
+
+/* RTC device ioctls.  */
+#define RTC_RD_TIME	1
+#define RTC_SET_TIME	2
+
+/* PS/2 mouse ioctls.  */
+#define PS2MOUSE_2_1_SCALING	1
+#define PS2MOUSE_1_1_SCALING	2
+#define PS2MOUSE_SET_RES	3
+#define PS2MOUSE_SET_SAMPLE_RATE 4
+
+/* Partition UUID ioctl.  */
+#define DEV_PARTUUID	0x9821
+
+#endif /* _BITS_IOCTLS_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipc-perm.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipc-perm.h
new file mode 100644
index 0000000..0a47317
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipc-perm.h
@@ -0,0 +1,17 @@
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc-perm.h> directly; include <sys/ipc.h> instead."
+#endif
+
+/* Data structure used to pass permission information to IPC operations.
+   This must match mlibc's ipc64_perm definition exactly.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    __uid_t uid;			/* Owner's user ID.  */
+    __gid_t gid;			/* Owner's group ID.  */
+    __uid_t cuid;			/* Creator's user ID.  */
+    __gid_t cgid;			/* Creator's group ID.  */
+    __mode_t mode;			/* Read/write permission.  */
+    short int __seq;			/* Sequence number.  */
+    unsigned long int __unused[2];	/* Reserved for future use.  */
+  };
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipc.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipc.h
new file mode 100644
index 0000000..d6a658f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipc.h
@@ -0,0 +1,20 @@
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.  */
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.  */
+
+#include <bits/ipc-perm.h>
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipctypes.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipctypes.h
new file mode 100644
index 0000000..b59d449
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/ipctypes.h
@@ -0,0 +1,11 @@
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipctypes.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+/* Used in `struct shmid_ds'.  */
+typedef int __ipc_pid_t;
+
+#endif /* bits/ipctypes.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/local_lim.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/local_lim.h
new file mode 100644
index 0000000..f3848b2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/local_lim.h
@@ -0,0 +1,90 @@
+#ifndef _BITS_LOCAL_LIM_H
+#define _BITS_LOCAL_LIM_H 1
+
+/* Maximum length of arguments to `execve', including environment.  */
+#define ARG_MAX		131072
+
+/* Maximum simultaneous processes per real user ID.  */
+#define CHILD_MAX	999
+
+/* Maximum length of a hostname.  */
+#define HOST_NAME_MAX	64
+
+/* Maximum link count of a file.  */
+#define LINK_MAX	127
+
+/* Maximum length of login name.  */
+#define LOGIN_NAME_MAX	256
+
+/* Number of bytes in a terminal canonical input queue.  */
+#define MAX_CANON	255
+
+/* Number of bytes for which space is available in terminal input queue.  */
+#define MAX_INPUT	255
+
+/* Maximum length of a file name component.  */
+#define NAME_MAX	255
+
+/* Number of simultaneous supplementary group IDs per process.  */
+#define NGROUPS_MAX	65536
+
+/* Maximum files that one process can have open.  */
+#define OPEN_MAX	1024
+
+/* Maximum length of a path.  */
+#define PATH_MAX	4096
+
+/* Number of bytes in a pipe buffer.  */
+#define PIPE_BUF	4096
+
+/* Maximum number of realtime signals.  */
+#define RTSIG_MAX	32
+
+/* Maximum bytes in a message.  */
+#define SEM_VALUE_MAX	2147483647
+
+/* Maximum message size that can be sent on stream.  */
+#define STREAM_MAX	16
+
+/* Maximum length of a timezone name.  */
+#define TZNAME_MAX	6
+
+/* IOV_MAX is defined via bits/uio_lim.h -> __IOV_MAX -> bits/xopen_lim.h.  */
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
+
+/* Maximum tty name length.  */
+#define TTY_NAME_MAX	32
+
+/* Maximum login name length.  This includes the terminating null byte.  */
+#define LOGIN_NAME_MAX	256
+
+/* Maximum host name length.  */
+#define HOST_NAME_MAX	64
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* We have no predefined limit on the number of threads.  */
+#undef PTHREAD_THREADS_MAX
+
+/* Arrange for the definition of PTHREAD_STACK_MIN.  */
+#include <bits/pthread_stack_min.h>
+
+/* Maximum message queue priority level.  */
+#define MQ_PRIO_MAX	32768
+
+/* Maximum value of ssize_t.  */
+#define SSIZE_MAX	LONG_MAX
+
+#endif /* _BITS_LOCAL_LIM_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/mman.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/mman.h
new file mode 100644
index 0000000..bb08ce7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/mman.h
@@ -0,0 +1,52 @@
+#ifndef _SYS_MMAN_H
+# error "Never include <bits/mman.h> directly; use <sys/mman.h> instead."
+#endif
+
+#ifndef _BITS_MMAN_H
+#define _BITS_MMAN_H 1
+
+/* Protection flags.  */
+#define PROT_NONE	0x00	/* No access.  */
+#define PROT_READ	0x01	/* Pages can be read.  */
+#define PROT_WRITE	0x02	/* Pages can be written.  */
+#define PROT_EXEC	0x04	/* Pages can be executed.  */
+
+/* Sharing types.  */
+#define MAP_FILE	0x00	/* Compatibility flag (ignored).  */
+#define MAP_PRIVATE	0x01	/* Changes are private.  */
+#define MAP_SHARED	0x02	/* Share changes.  */
+#define MAP_FIXED	0x04	/* Interpret addr exactly.  */
+#define MAP_ANON	0x08	/* Don't use a file.  */
+#define MAP_ANONYMOUS	MAP_ANON
+#define MAP_NORESERVE 0x10	/* Don't reserve swap space.  */
+
+/* Error return from mmap.  */
+#define MAP_FAILED	((void *) -1)
+
+/* Flags for msync.  */
+#define MS_ASYNC	0x01	/* Sync memory asynchronously.  */
+#define MS_SYNC		0x02	/* Synchronous memory sync.  */
+#define MS_INVALIDATE	0x04	/* Invalidate the caches.  */
+
+/* Flags for mlockall.  */
+#define MCL_CURRENT	0x01	/* Lock all current mappings.  */
+#define MCL_FUTURE	0x02	/* Lock all future mappings.  */
+
+/* POSIX madvise constants (matching mlibc).  */
+#define POSIX_MADV_NORMAL	1
+#define POSIX_MADV_SEQUENTIAL	2
+#define POSIX_MADV_RANDOM	3
+#define POSIX_MADV_DONTNEED	4
+#define POSIX_MADV_WILLNEED	5
+
+/* BSD/Linux-style madvise constants - same values as POSIX_MADV_* on Ironclad.  */
+#define MADV_NORMAL	1
+#define MADV_SEQUENTIAL	2
+#define MADV_RANDOM	3
+#define MADV_DONTNEED	4
+#define MADV_WILLNEED	5
+
+/* Note: MADV_HUGEPAGE, MADV_NOHUGEPAGE, MADV_GUARD_*, MREMAP_*, MLOCK_ONFAULT
+   are not defined - Ironclad does not support them.  */
+
+#endif /* _BITS_MMAN_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/param.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/param.h
new file mode 100644
index 0000000..729cbb1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/param.h
@@ -0,0 +1,19 @@
+#ifndef _SYS_PARAM_H
+# error "Never use <bits/param.h> directly; include <sys/param.h> instead."
+#endif
+
+/* Ironclad uses standard 4K pages on x86_64.  */
+#define EXEC_PAGESIZE	4096
+
+#define	MAXSYMLINKS	20
+
+/* The following are not really correct but it is a value we used for a
+   long time and which seems to be usable.  People should not use NOFILE
+   and NCARGS anyway.  */
+#define NOFILE		256
+#define	NCARGS		131072
+
+/* BSD compatibility - maximum pathname length.  */
+#ifndef MAXPATHLEN
+# define MAXPATHLEN	4096
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/poll.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/poll.h
new file mode 100644
index 0000000..c5e30af
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/poll.h
@@ -0,0 +1,31 @@
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Ironclad poll flags - these match the kernel ABI.
+   Values differ from Linux.  */
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		0x01		/* There is data to read.  */
+#define POLLOUT		0x02		/* Writing now will not block.  */
+#define POLLPRI		0x04		/* There is urgent data to read.  */
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLHUP		0x08		/* Hung up.  */
+#define POLLERR		0x10		/* Error condition.  */
+#define POLLRDHUP	0x20		/* Peer closed connection.  */
+#define POLLNVAL	0x40		/* Invalid polling request.  */
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+/* These values are defined in XPG4.2.  */
+# define POLLWRNORM	0x80		/* Writing now will not block.  */
+# define POLLRDNORM	0x100		/* Normal data may be read.  */
+# define POLLWRBAND	0x200		/* Priority data may be written.  */
+# define POLLRDBAND	0x400		/* Priority data may be read.  */
+#endif
+
+/* Note: POLLMSG is not defined - not in mlibc/Ironclad.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/posix_opt.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/posix_opt.h
new file mode 100644
index 0000000..b2bfc53
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/posix_opt.h
@@ -0,0 +1,173 @@
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	200809L
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	200809L
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	200809L
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	200809L
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	200809L
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	200809L
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	200809L
+
+/* Some filesystems allow all users to change file ownership.  */
+#define	_POSIX_CHOWN_RESTRICTED	0
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	'\0'
+
+/* Filenames are not silently truncated.  */
+#define	_POSIX_NO_TRUNC	1
+
+/* X/Open realtime support is available.  */
+#define _XOPEN_REALTIME	1
+
+/* X/Open thread realtime support is available.  */
+#define _XOPEN_REALTIME_THREADS	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* Tell we have POSIX threads.  */
+#define _POSIX_THREADS	200809L
+
+/* We have the reentrant functions described in POSIX.  */
+#define _POSIX_REENTRANT_FUNCTIONS      1
+#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
+
+/* We provide priority scheduling for threads.  */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	200809L
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	200809L
+
+/* We support priority inheritance.  */
+#define _POSIX_THREAD_PRIO_INHERIT	200809L
+
+/* We support priority protection, though only for non-robust
+   mutexes.  */
+#define _POSIX_THREAD_PRIO_PROTECT	200809L
+
+#ifdef __USE_XOPEN2K8
+/* We support priority inheritance for robust mutexes.  */
+# define _POSIX_THREAD_ROBUST_PRIO_INHERIT	200809L
+
+/* We do not support priority protection for robust mutexes.  */
+# define _POSIX_THREAD_ROBUST_PRIO_PROTECT	-1
+#endif
+
+/* We support POSIX.1b semaphores.  */
+#define _POSIX_SEMAPHORES	200809L
+
+/* Real-time signals are supported.  */
+#define _POSIX_REALTIME_SIGNALS	200809L
+
+/* We support asynchronous I/O.  */
+#define _POSIX_ASYNCHRONOUS_IO	200809L
+#define _POSIX_ASYNC_IO		1
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	1
+/* Support for prioritization is also available.  */
+#define _POSIX_PRIORITIZED_IO	200809L
+
+/* The LFS support in asynchronous I/O is also available.  */
+#define _LFS64_ASYNCHRONOUS_IO	1
+
+/* The rest of the LFS is also available.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX shared memory objects are implemented.  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	200809L
+
+/* CPU-time clocks support needs to be checked at runtime.  */
+#define _POSIX_CPUTIME	0
+
+/* Clock support in threads must be also checked at runtime.  */
+#define _POSIX_THREAD_CPUTIME	0
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200809L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200809L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200809L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200809L
+
+/* We have POSIX timers.  */
+#define _POSIX_TIMERS	200809L
+
+/* The barrier functions are available.  */
+#define _POSIX_BARRIERS	200809L
+
+/* POSIX message queues are available.  */
+#define	_POSIX_MESSAGE_PASSING	200809L
+
+/* Thread process-shared synchronization is supported.  */
+#define _POSIX_THREAD_PROCESS_SHARED	200809L
+
+/* The monotonic clock might be available.  */
+#define _POSIX_MONOTONIC_CLOCK	0
+
+/* The clock selection interfaces are available.  */
+#define _POSIX_CLOCK_SELECTION	200809L
+
+/* Advisory information interfaces are available.  */
+#define _POSIX_ADVISORY_INFO	200809L
+
+/* IPv6 support is available.  */
+#define _POSIX_IPV6	200809L
+
+/* Raw socket support is available.  */
+#define _POSIX_RAW_SOCKETS	200809L
+
+/* We have at least one terminal.  */
+#define _POSIX2_CHAR_TERM	200809L
+
+/* Neither process nor thread sporadic server interfaces is available.  */
+#define _POSIX_SPORADIC_SERVER	-1
+#define _POSIX_THREAD_SPORADIC_SERVER	-1
+
+/* trace.h is not available.  */
+#define _POSIX_TRACE	-1
+#define _POSIX_TRACE_EVENT_FILTER	-1
+#define _POSIX_TRACE_INHERIT	-1
+#define _POSIX_TRACE_LOG	-1
+
+/* Typed memory objects are not available.  */
+#define _POSIX_TYPED_MEMORY_OBJECTS	-1
+
+#endif /* bits/posix_opt.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/pthread_stack_min-dynamic.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/pthread_stack_min-dynamic.h
new file mode 100644
index 0000000..2ac46cc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/pthread_stack_min-dynamic.h
@@ -0,0 +1,13 @@
+#ifndef PTHREAD_STACK_MIN
+# if defined __USE_DYNAMIC_STACK_SIZE && __USE_DYNAMIC_STACK_SIZE
+#  ifndef __ASSEMBLER__
+#   define __SC_THREAD_STACK_MIN_VALUE 75
+__BEGIN_DECLS
+extern long int __sysconf (int __name) __THROW;
+__END_DECLS
+#   define PTHREAD_STACK_MIN __sysconf (__SC_THREAD_STACK_MIN_VALUE)
+#  endif
+# else
+#  include <bits/pthread_stack_min.h>
+# endif
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/pthread_stack_min.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/pthread_stack_min.h
new file mode 100644
index 0000000..fac9f2d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/pthread_stack_min.h
@@ -0,0 +1,2 @@
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	16384
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/resource.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/resource.h
new file mode 100644
index 0000000..8da4e6b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/resource.h
@@ -0,0 +1,141 @@
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Ironclad resource limit values - these match the kernel ABI.
+   Unlike Linux/generic glibc which uses enum values starting at 0,
+   Ironclad uses explicit constants starting at 1.  */
+
+/* Kinds of resource limit (matching mlibc abis/ironclad/resource.h).  */
+enum __rlimit_resource
+  {
+    /* Largest core file that can be created, in bytes.  */
+    RLIMIT_CORE = 1,
+#define RLIMIT_CORE	1
+    /* Per-process CPU limit, in seconds.  */
+    RLIMIT_CPU = 2,
+#define RLIMIT_CPU	2
+    /* Maximum size of data segment, in bytes.  */
+    RLIMIT_DATA = 3,
+#define RLIMIT_DATA	3
+    /* Largest file that can be created, in bytes.  */
+    RLIMIT_FSIZE = 4,
+#define RLIMIT_FSIZE	4
+    /* Number of open files.  */
+    RLIMIT_NOFILE = 5,
+#define RLIMIT_NOFILE	5
+#define RLIMIT_OFILE	RLIMIT_NOFILE
+    /* Maximum size of stack segment, in bytes.  */
+    RLIMIT_STACK = 6,
+#define RLIMIT_STACK	6
+    /* Maximum size in bytes of the process address space.  */
+    RLIMIT_AS = 7,
+#define RLIMIT_AS	7
+#define RLIMIT_VMEM	RLIMIT_AS
+    /* Maximum bytes of memory that may be locked into RAM.  */
+    RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK	8
+    /* Maximum resident set size.  */
+    RLIMIT_RSS = 9,
+#define RLIMIT_RSS	9
+    /* Maximum number of processes.  */
+    RLIMIT_NPROC = 10,
+#define RLIMIT_NPROC	10
+    /* Maximum number of file locks.  */
+    RLIMIT_LOCKS = 11,
+#define RLIMIT_LOCKS	11
+    /* Maximum number of pending signals.  */
+    RLIMIT_SIGPENDING = 12,
+#define RLIMIT_SIGPENDING	12
+    /* Maximum bytes in POSIX message queues.  */
+    RLIMIT_MSGQUEUE = 13,
+#define RLIMIT_MSGQUEUE	13
+    /* Maximum nice priority allowed to raise to.  */
+    RLIMIT_NICE = 14,
+#define RLIMIT_NICE	14
+    /* Maximum realtime priority allowed.  */
+    RLIMIT_RTPRIO = 15,
+#define RLIMIT_RTPRIO	15
+    RLIMIT_NLIMITS = 16,
+    RLIM_NLIMITS = RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS	RLIMIT_NLIMITS
+#define RLIM_NLIMITS	RLIMIT_NLIMITS
+  };
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((rlim_t) -1)
+#else
+# define RLIM_INFINITY 0x7fffffffffffffffLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+  };
+#endif
+
+/* Whose usage statistics do you want?  */
+/* Ironclad uses positive values unlike Linux which uses 0 and -1.  */
+enum __rusage_who
+  {
+    /* The calling process.  */
+    RUSAGE_SELF = 1,
+#define RUSAGE_SELF	1
+    /* All of its terminated child processes.  */
+    RUSAGE_CHILDREN = 2
+#define RUSAGE_CHILDREN	2
+  };
+
+#include <bits/types/struct_timeval.h>
+#include <bits/types/struct_rusage.h>
+
+/* Priority limits.  */
+#define PRIO_MIN	(-20)	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+/* Ironclad uses 1-based values unlike Linux which uses 0-based.  */
+enum __priority_which
+  {
+    PRIO_PROCESS = 1,		/* WHO is a process ID.  */
+#define PRIO_PROCESS	1
+    PRIO_PGRP = 2,		/* WHO is a process group ID.  */
+#define PRIO_PGRP	2
+    PRIO_USER = 3		/* WHO is a user ID.  */
+#define PRIO_USER	3
+  };
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sched.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sched.h
new file mode 100644
index 0000000..0f2f079
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sched.h
@@ -0,0 +1,62 @@
+#ifndef _BITS_SCHED_H
+#define _BITS_SCHED_H 1
+
+#ifndef _SCHED_H
+# error "Never include <bits/sched.h> directly; use <sched.h> instead."
+#endif
+
+/* Ironclad scheduling algorithms (from kernel userland-syscall.ads).  */
+#define SCHED_OTHER		0
+#define SCHED_FIFO		1
+#define SCHED_RR		2
+
+#ifdef __USE_GNU
+/* Cloning flags.  These are used internally by glibc's pthread implementation.
+   On Ironclad, the clone() function maps to create_thread syscall which
+   ignores most flags - only TLS setup is actually used.
+   These values match Linux for source compatibility with glibc internals.  */
+# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
+# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
+# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
+# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
+# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
+# define CLONE_PIDFD   0x00001000 /* Set if a pidfd should be placed in parent.  */
+# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
+# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
+				     wake it up on mm_release.  */
+# define CLONE_PARENT  0x00008000 /* Set if we want to have the same
+				     parent as the cloner.  */
+# define CLONE_THREAD  0x00010000 /* Set to add to same thread group.  */
+# define CLONE_NEWNS   0x00020000 /* Set to create new namespace.  */
+# define CLONE_SYSVSEM 0x00040000 /* Set to shared SVID SEM_UNDO semantics.  */
+# define CLONE_SETTLS  0x00080000 /* Set TLS info.  */
+# define CLONE_PARENT_SETTID 0x00100000 /* Store TID in userlevel buffer
+					   before MM copy.  */
+# define CLONE_CHILD_CLEARTID 0x00200000 /* Register exit futex and memory
+					    location to clear.  */
+# define CLONE_DETACHED 0x00400000 /* Create clone detached.  */
+# define CLONE_UNTRACED 0x00800000 /* Set if the tracing process can't
+				      force CLONE_PTRACE on this clone.  */
+# define CLONE_CHILD_SETTID 0x01000000 /* Store TID in userlevel buffer in
+					  the child.  */
+#endif
+
+#include <bits/types/struct_sched_param.h>
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Clone current process / create thread.
+   On Ironclad, this maps to the create_thread syscall and is primarily
+   used internally by pthread. The flags argument is largely ignored.  */
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+		  int __flags, void *__arg, ...) __THROW;
+
+/* Get index of currently used CPU.
+   Note: May not be fully supported on Ironclad.  */
+extern int sched_getcpu (void) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* bits/sched.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/seek_whence.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/seek_whence.h
new file mode 100644
index 0000000..2a15454
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/seek_whence.h
@@ -0,0 +1,11 @@
+#ifndef _BITS_SEEK_WHENCE_H
+#define _BITS_SEEK_WHENCE_H 1
+
+/* Ironclad-specific SEEK_* values.  These differ from Linux.
+   From mlibc/abis/ironclad/seek-whence.h:
+   SEEK_SET=1, SEEK_CUR=2, SEEK_END=4  */
+#define SEEK_SET	1	/* Seek from beginning of file.  */
+#define SEEK_CUR	2	/* Seek from current position.  */
+#define SEEK_END	4	/* Seek from end of file.  */
+
+#endif /* bits/seek_whence.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/semaphore.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/semaphore.h
new file mode 100644
index 0000000..11e748c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/semaphore.h
@@ -0,0 +1,21 @@
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/shm.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/shm.h
new file mode 100644
index 0000000..13d3b3d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/shm.h
@@ -0,0 +1,66 @@
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <bits/wordsize.h>
+#include <bits/shmlba.h>
+
+/* Permission flag for shmget.  */
+#define SHM_R		0400		/* or S_IRUGO from <linux/stat.h> */
+#define SHM_W		0200		/* or S_IWUGO from <linux/stat.h> */
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+#define SHM_REMAP	040000		/* take-over region on attach */
+#define SHM_EXEC	0100000		/* execution access */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+__BEGIN_DECLS
+
+/* Type to count number of attaches.  */
+typedef __syscall_ulong_t shmatt_t;
+
+#include <bits/types/struct_shmid_ds.h>
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT	13
+# define SHM_INFO	14
+# define SHM_STAT_ANY	15
+
+/* shm_mode upper byte flags */
+# define SHM_DEST	01000	/* segment will be destroyed on last detach */
+# define SHM_LOCKED	02000	/* segment will not be swapped */
+
+struct shminfo
+  {
+    __syscall_ulong_t shmmax;
+    __syscall_ulong_t shmmin;
+    __syscall_ulong_t shmmni;
+    __syscall_ulong_t shmseg;
+    __syscall_ulong_t shmall;
+    __syscall_ulong_t __glibc_reserved1;
+    __syscall_ulong_t __glibc_reserved2;
+    __syscall_ulong_t __glibc_reserved3;
+    __syscall_ulong_t __glibc_reserved4;
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    __syscall_ulong_t shm_tot;	/* total allocated shm */
+    __syscall_ulong_t shm_rss;	/* total resident shm */
+    __syscall_ulong_t shm_swp;	/* total swapped shm */
+    __syscall_ulong_t swap_attempts;
+    __syscall_ulong_t swap_successes;
+  };
+
+#endif /* __USE_MISC */
+
+__END_DECLS
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/shmlba.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/shmlba.h
new file mode 100644
index 0000000..76a0752
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/shmlba.h
@@ -0,0 +1,11 @@
+#ifndef _SYS_SHM_H
+# error "Never use <bits/shmlba.h> directly; include <sys/shm.h> instead."
+#endif
+
+__BEGIN_DECLS
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+__END_DECLS
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sigaction.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sigaction.h
new file mode 100644
index 0000000..11b2a05
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sigaction.h
@@ -0,0 +1,59 @@
+#ifndef _BITS_SIGACTION_H
+#define _BITS_SIGACTION_H 1
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+#if defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+
+    /* Ironclad has the restorer before the mask.  */
+    void (*sa_restorer) (void);
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+
+    /* Special flags.  */
+    int sa_flags;
+  };
+
+/* Bits in `sa_flags'.  */
+#define SA_NOCLDSTOP	(1 << 0)  /* Don't send SIGCHLD when children stop.  */
+#define SA_ONSTACK	(1 << 1)  /* Call signal handler on alternate stack.  */
+#define SA_RESETHAND	(1 << 2)  /* Reset to SIG_DFL on entry to handler.  */
+#define SA_RESTART	(1 << 3)  /* Restart syscall on signal return.  */
+#define SA_SIGINFO	(1 << 4)  /* Signal handler with SA_SIGINFO args.  */
+#define SA_NOCLDWAIT	(1 << 5)  /* Don't create zombie on child death.  */
+#define SA_NODEFER	(1 << 6)  /* Don't block signal during handler.  */
+
+#ifdef __USE_XOPEN_EXTENDED
+# define SA_INTERRUPT	0	/* Historical; opposite of SA_RESTART.  */
+#endif
+
+/* Some aliases for the SA_ constants.  */
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define SIG_BLOCK	1	/* Block signals.  */
+#define SIG_UNBLOCK	2	/* Unblock signals.  */
+#define SIG_SETMASK	3	/* Set the set of blocked signals.  */
+
+#endif /* _BITS_SIGACTION_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sigcontext.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sigcontext.h
new file mode 100644
index 0000000..1d76172
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sigcontext.h
@@ -0,0 +1,111 @@
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* FPU state for x86_64.  */
+struct _fpx_sw_bytes
+{
+  __uint32_t magic1;
+  __uint32_t extended_size;
+  __uint64_t xstate_bv;
+  __uint32_t xstate_size;
+  __uint32_t __glibc_reserved1[7];
+};
+
+struct _fpreg
+{
+  unsigned short significand[4];
+  unsigned short exponent;
+};
+
+struct _fpxreg
+{
+  unsigned short significand[4];
+  unsigned short exponent;
+  unsigned short __glibc_reserved1[3];
+};
+
+struct _xmmreg
+{
+  __uint32_t element[4];
+};
+
+struct _fpstate
+{
+  /* FPU environment matching the 64-bit FXSAVE layout.  */
+  __uint16_t cwd;
+  __uint16_t swd;
+  __uint16_t ftw;
+  __uint16_t fop;
+  __uint64_t rip;
+  __uint64_t rdp;
+  __uint32_t mxcsr;
+  __uint32_t mxcr_mask;
+  struct _fpxreg _st[8];
+  struct _xmmreg _xmm[16];
+  __uint32_t __glibc_reserved1[24];
+};
+
+/* Signal context structure for x86_64 Ironclad.
+   Uses sc_ prefix for register names to match GCC's unwinding support.  */
+struct sigcontext
+{
+  __uint64_t sc_r8;
+  __uint64_t sc_r9;
+  __uint64_t sc_r10;
+  __uint64_t sc_r11;
+  __uint64_t sc_r12;
+  __uint64_t sc_r13;
+  __uint64_t sc_r14;
+  __uint64_t sc_r15;
+  __uint64_t sc_rdi;
+  __uint64_t sc_rsi;
+  __uint64_t sc_rbp;
+  __uint64_t sc_rbx;
+  __uint64_t sc_rdx;
+  __uint64_t sc_rax;
+  __uint64_t sc_rcx;
+  __uint64_t sc_ursp;    /* User RSP (stack pointer) */
+  __uint64_t sc_rip;
+  __uint64_t sc_eflags;
+  unsigned short sc_cs;
+  unsigned short sc_gs;
+  unsigned short sc_fs;
+  unsigned short __pad0;
+  __uint64_t sc_err;
+  __uint64_t sc_trapno;
+  __uint64_t sc_oldmask;
+  __uint64_t sc_cr2;
+  __extension__ union
+    {
+      struct _fpstate *fpstate;
+      __uint64_t __fpstate_word;
+    };
+  __uint64_t __reserved1[8];
+};
+
+struct _xsave_hdr
+{
+  __uint64_t xstate_bv;
+  __uint64_t __glibc_reserved1[2];
+  __uint64_t __glibc_reserved2[5];
+};
+
+struct _ymmh_state
+{
+  __uint32_t ymmh_space[64];
+};
+
+struct _xstate
+{
+  struct _fpstate fpstate;
+  struct _xsave_hdr xstate_hdr;
+  struct _ymmh_state ymmh;
+};
+
+#endif /* _BITS_SIGCONTEXT_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/siginfo-arch.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/siginfo-arch.h
new file mode 100644
index 0000000..6d738d4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/siginfo-arch.h
@@ -0,0 +1,7 @@
+/* Architecture-specific adjustments to siginfo_t.  Ironclad version.  */
+#ifndef _BITS_SIGINFO_ARCH_H
+#define _BITS_SIGINFO_ARCH_H 1
+
+/* This architecture has no adjustments to make to siginfo_t.  */
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/siginfo-consts.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/siginfo-consts.h
new file mode 100644
index 0000000..85e6acc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/siginfo-consts.h
@@ -0,0 +1,150 @@
+#ifndef _BITS_SIGINFO_CONSTS_H
+#define _BITS_SIGINFO_CONSTS_H 1
+
+#ifndef _SIGNAL_H
+#error "Don't include <bits/siginfo-consts.h> directly; use <signal.h> instead."
+#endif
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
+  SI_DETHREAD = -7,		/* Sent by execve killing subsidiary
+				   threads.  */
+  SI_TKILL,			/* Sent by tkill.  */
+  SI_SIGIO,			/* Sent by queued SIGIO. */
+  SI_ASYNCIO,			/* Sent by AIO completion.  */
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+  SI_TIMER,			/* Sent by timer expiration.  */
+  SI_QUEUE,			/* Sent by sigqueue.  */
+  SI_USER,			/* Sent by kill, sigsend.  */
+  SI_KERNEL = 0x80		/* Send by kernel.  */
+
+#define SI_ASYNCNL	SI_ASYNCNL
+#define SI_DETHREAD	SI_DETHREAD
+#define SI_TKILL	SI_TKILL
+#define SI_SIGIO	SI_SIGIO
+#define SI_ASYNCIO	SI_ASYNCIO
+#define SI_MESGQ	SI_MESGQ
+#define SI_TIMER	SI_TIMER
+#define SI_QUEUE	SI_QUEUE
+#define SI_USER		SI_USER
+#define SI_KERNEL	SI_KERNEL
+};
+
+
+# if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+#  define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+#  define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+#  define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+#  define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+#  define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+#  define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+#  define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK,			/* Internal stack error.  */
+#  define ILL_BADSTK	ILL_BADSTK
+  ILL_BADIADDR			/* Unimplemented instruction address.  */
+#  define ILL_BADIADDR ILL_BADIADDR
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+#  define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+#  define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+#  define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+#  define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+#  define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+#  define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+#  define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+#  define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+#  define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+#  define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+#  define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existent physical address.  */
+#  define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+#  define BUS_OBJERR	BUS_OBJERR
+};
+# endif
+
+# ifdef __USE_XOPEN_EXTENDED
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+#  define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+#  define TRAP_TRACE	TRAP_TRACE
+};
+# endif
+
+# if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+#  define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+#  define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+#  define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+#  define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+#  define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+#  define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+#  define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+#  define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+#  define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+#  define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+#  define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+#  define POLL_HUP	POLL_HUP
+};
+# endif
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/signum-arch.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/signum-arch.h
new file mode 100644
index 0000000..91fcd91
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/signum-arch.h
@@ -0,0 +1,92 @@
+#ifndef _BITS_SIGNUM_ARCH_H
+#define _BITS_SIGNUM_ARCH_H 1
+
+#ifndef _SIGNAL_H
+#error "Never include <bits/signum-arch.h> directly; use <signal.h> instead."
+#endif
+
+/* Ironclad signal numbers and SIG_* constants differ from the generic defaults.
+   We must undef the ones that differ before redefining.  */
+
+/* Ironclad uses different SIG_DFL/SIG_IGN values than the generic defaults.
+   The kernel expects:
+   - SIG_ERR = -1 (Integer_Address'Last)
+   - SIG_IGN = -2 (Integer_Address'Last - 1)
+   - SIG_DFL = -3 (Integer_Address'Last - 2)
+   See Ironclad kernel source: userland-syscall.ads lines 1089-1091.  */
+#undef SIG_ERR
+#undef SIG_DFL
+#undef SIG_IGN
+#define SIG_ERR	((__sighandler_t) -1)	/* Error return.  */
+#define SIG_DFL	((__sighandler_t) -2)	/* Default action.  */
+#define SIG_IGN	((__sighandler_t) -3)	/* Ignore signal.  */
+
+#undef SIGHUP
+#undef SIGINT
+#undef SIGQUIT
+#undef SIGCONT
+#undef SIGBUS
+#undef SIGABRT
+#undef SIGCHLD
+#undef SIGFPE
+#undef SIGKILL
+#undef SIGILL
+#undef SIGPIPE
+#undef SIGSEGV
+#undef SIGSTOP
+#undef SIGALRM
+#undef SIGTERM
+#undef SIGTSTP
+#undef SIGTTIN
+#undef SIGTTOU
+#undef SIGUSR1
+#undef SIGUSR2
+#undef SIGIO
+#undef SIGPOLL
+#undef SIGPROF
+#undef SIGSYS
+#undef SIGTRAP
+#undef SIGURG
+#undef SIGVTALRM
+#undef SIGXCPU
+#undef SIGXFSZ
+#undef SIGWINCH
+#undef SIGPWR
+#undef __SIGRTMIN
+#undef __SIGRTMAX
+
+#define SIGHUP     1
+#define SIGINT     2
+#define SIGQUIT    3
+#define SIGCONT    4
+#define SIGBUS     5
+#define SIGABRT    6
+#define SIGCHLD    7
+#define SIGFPE     8
+#define SIGKILL    9
+#define SIGILL    10
+#define SIGPIPE   11
+#define SIGSEGV   12
+#define SIGSTOP   13
+#define SIGALRM   14
+#define SIGTERM   15
+#define SIGTSTP   16
+#define SIGTTIN   17
+#define SIGTTOU   18
+#define SIGUSR1   19
+#define SIGUSR2   20
+#define SIGIO     21
+#define SIGPOLL   SIGIO
+#define SIGPROF   22
+#define SIGSYS    23
+#define SIGTRAP   24
+#define SIGURG    25
+#define SIGVTALRM 26
+#define SIGXCPU   27
+#define SIGXFSZ   28
+#define SIGWINCH  29
+#define SIGPWR    30
+#define __SIGRTMIN 31
+#define __SIGRTMAX 38
+
+#endif /* _BITS_SIGNUM_ARCH_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sockaddr.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sockaddr.h
new file mode 100644
index 0000000..5b60ecd
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/sockaddr.h
@@ -0,0 +1,23 @@
+/*
+ * Never include this file directly; use <sys/socket.h> instead.
+ */
+
+#ifndef _BITS_SOCKADDR_H
+#define _BITS_SOCKADDR_H	1
+
+/* Ironclad uses unsigned int for sa_family_t (matches mlibc).  */
+typedef unsigned int sa_family_t;
+
+/* This macro is used to declare the initial common members
+   of the data types used for socket addresses, `struct sockaddr',
+   `struct sockaddr_in', `struct sockaddr_un', etc.  */
+
+#define	__SOCKADDR_COMMON(sa_prefix) \
+  sa_family_t sa_prefix##family
+
+#define __SOCKADDR_COMMON_SIZE	(sizeof (unsigned int))
+
+/* Size of struct sockaddr_storage.  */
+#define _SS_SIZE 128
+
+#endif	/* bits/sockaddr.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/socket.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/socket.h
new file mode 100644
index 0000000..0e8fc66
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/socket.h
@@ -0,0 +1,292 @@
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H
+
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define __need_size_t
+#include <stddef.h>
+
+#include <sys/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+/* Get the architecture-dependent definition of enum __socket_type.  */
+#include <bits/socket_type.h>
+
+/* Protocol families - Ironclad values.  */
+#define PF_INET		1	/* IP protocol family.  */
+#define PF_INET6	2	/* IP version 6.  */
+#define PF_UNIX		3	/* Local to host (pipes and file-domain).  */
+#define PF_LOCAL	PF_UNIX	/* POSIX name for PF_LOCAL.  */
+#define PF_UNSPEC	4	/* Unspecified.  */
+#define PF_NETLINK	5
+#define PF_BRIDGE	6	/* Multiprotocol bridge.  */
+#define PF_APPLETALK	7	/* Appletalk DDP.  */
+#define PF_BLUETOOTH	8	/* Bluetooth sockets.  */
+#define PF_DECnet	9	/* Reserved for DECnet project.  */
+#define PF_IPX		10	/* Novell Internet Protocol.  */
+#define PF_ISDN		11	/* mISDN sockets.  */
+#define PF_SNA		12	/* Linux SNA Project */
+#define PF_PACKET	13	/* Packet family.  */
+#define PF_AX25		14	/* Amateur Radio AX.25.  */
+#define PF_NETROM	15	/* Amateur radio NetROM.  */
+#define PF_ROSE		16	/* Amateur Radio X.25 PLP.  */
+#define PF_TIPC		30	/* TIPC sockets.  */
+#define PF_ALG		38	/* Algorithm sockets.  */
+#define PF_MAX		46	/* For now..  */
+
+/* Note: PF_FILE and PF_ROUTE are not defined - not in mlibc/Ironclad.  */
+
+/* Address families.  */
+#define AF_INET		PF_INET
+#define AF_INET6	PF_INET6
+#define AF_UNIX		PF_UNIX
+#define AF_LOCAL	PF_LOCAL
+#define AF_UNSPEC	PF_UNSPEC
+#define AF_NETLINK	PF_NETLINK
+#define AF_BRIDGE	PF_BRIDGE
+#define AF_APPLETALK	PF_APPLETALK
+#define AF_BLUETOOTH	PF_BLUETOOTH
+#define AF_DECnet	PF_DECnet
+#define AF_IPX		PF_IPX
+#define AF_ISDN		PF_ISDN
+#define AF_SNA		PF_SNA
+#define AF_PACKET	PF_PACKET
+#define AF_AX25		PF_AX25
+#define AF_NETROM	PF_NETROM
+#define AF_ROSE		PF_ROSE
+#define AF_TIPC		PF_TIPC
+#define AF_ALG		PF_ALG
+#define AF_MAX		PF_MAX
+/* Note: AF_FILE, AF_ROUTE, PF_FILE, PF_ROUTE not defined - not in mlibc.  */
+
+/* Socket level values (matching mlibc).  */
+#define SOL_SOCKET	1
+#define SOL_IPV6	41
+#define SOL_PACKET	263
+#define SOL_NETLINK	270
+/* Note: SOL_RAW, SOL_IP not defined - not in mlibc/Ironclad.  */
+
+/* Socket options - Ironclad values.  */
+#define SO_ACCEPTCONN	1
+#define SO_BROADCAST	2
+#define SO_DEBUG	3
+#define SO_DONTROUTE	4
+#define SO_ERROR	5
+#define SO_KEEPALIVE	6
+#define SO_LINGER	7
+#define SO_OOBINLINE	8
+#define SO_RCVBUF	9
+#define SO_RCVLOWAT	10
+#define SO_RCVTIMEO	11
+#define SO_REUSEADDR	12
+#define SO_SNDBUF	13
+#define SO_SNDLOWAT	14
+#define SO_SNDTIMEO	15
+#define SO_TYPE		16
+#define SO_SNDBUFFORCE	17
+#define SO_PEERCRED	18
+#define SO_ATTACH_FILTER	19
+#define SO_PASSCRED	20
+#define SO_RCVBUFFORCE	21
+#define SO_DETACH_FILTER	22
+#define SO_PROTOCOL	23
+#define SO_REUSEPORT	24
+#define SO_TIMESTAMP	25
+#define SO_PEERSEC	26
+#define SO_BINDTODEVICE	27
+#define SO_DOMAIN	28
+#define SO_PASSSEC	29
+#define SO_TIMESTAMPNS	30
+#define SO_PRIORITY	31
+#define SO_MARK		32
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	1
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.
+   Ironclad uses 4-byte sa_family_t, so sa_data is 12 bytes for 16-byte total.  */
+struct __attribute_struct_may_alias__ sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family (4 bytes).  */
+    char sa_data[12];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  */
+#define __ss_aligntype	unsigned long int
+#define _SS_PADSIZE \
+  (_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))
+
+struct __attribute_struct_may_alias__ sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    char __ss_padding[_SS_PADSIZE];
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  - Ironclad values.  */
+enum
+  {
+    MSG_CTRUNC		= 0x1,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC	MSG_CTRUNC
+    MSG_DONTROUTE	= 0x2,	/* Don't use local routing.  */
+#define MSG_DONTROUTE	MSG_DONTROUTE
+    MSG_EOR		= 0x4,	/* End of record.  */
+#define MSG_EOR		MSG_EOR
+    MSG_OOB		= 0x8,	/* Process out-of-band data.  */
+#define MSG_OOB		MSG_OOB
+    MSG_NOSIGNAL	= 0x10,	/* Do not generate SIGPIPE.  */
+#define MSG_NOSIGNAL	MSG_NOSIGNAL
+    MSG_PEEK		= 0x20,	/* Peek at incoming messages.  */
+#define MSG_PEEK	MSG_PEEK
+    MSG_TRUNC		= 0x40,
+#define MSG_TRUNC	MSG_TRUNC
+    MSG_WAITALL		= 0x80,	/* Wait for a full request.  */
+#define MSG_WAITALL	MSG_WAITALL
+    MSG_FIN		= 0x200,
+#define MSG_FIN		MSG_FIN
+    MSG_CONFIRM		= 0x800, /* Confirm path validity.  */
+#define MSG_CONFIRM	MSG_CONFIRM
+    MSG_DONTWAIT	= 0x1000, /* Nonblocking IO.  */
+#define MSG_DONTWAIT	MSG_DONTWAIT
+    MSG_CMSG_CLOEXEC	= 0x2000, /* Set close_on_exit for file
+				     descriptor received through
+				     SCM_RIGHTS.  */
+#define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
+    MSG_MORE		= 0x4000,  /* Sender will send more.  */
+#define MSG_MORE	MSG_MORE
+    MSG_FASTOPEN	= 0x20000000 /* Send data in TCP SYN.  */
+#define MSG_FASTOPEN	MSG_FASTOPEN
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  Ironclad version matches mlibc.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    int msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+
+    int msg_flags;		/* Flags on received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.
+   Ironclad version matches mlibc.  */
+struct cmsghdr
+  {
+    socklen_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if __glibc_c99_flexarr_available
+    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
+#endif
+  };
+
+/* Ancillary data object manipulation macros.  */
+#if __glibc_c99_flexarr_available
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
+#endif
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			 & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+/* Given a length, return the additional padding necessary such that
+   len + __CMSG_PADDING(len) == CMSG_ALIGN (len).  */
+#define __CMSG_PADDING(len) ((sizeof (size_t) \
+                              - ((len) & (sizeof (size_t) - 1))) \
+                             & (sizeof (size_t) - 1))
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
+{
+  /* We may safely assume that __cmsg lies between __mhdr->msg_control and
+     __mhdr->msg_controllen because the user is required to obtain the first
+     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs
+     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet
+     trust the value of __cmsg->cmsg_len and therefore do not use it in any
+     pointer arithmetic until we check its value.  */
+
+  unsigned char * __msg_control_ptr = (unsigned char *) __mhdr->msg_control;
+  unsigned char * __cmsg_ptr = (unsigned char *) __cmsg;
+
+  size_t __size_needed = sizeof (struct cmsghdr)
+                         + __CMSG_PADDING (__cmsg->cmsg_len);
+
+  /* The current header is malformed, too small to be a full header.  */
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    return (struct cmsghdr *) 0;
+
+  /* There isn't enough space between __cmsg and the end of the buffer to
+  hold the current cmsg *and* the next one.  */
+  if (((size_t)
+         (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr)
+       < __size_needed)
+      || ((size_t)
+            (__msg_control_ptr + __mhdr->msg_controllen - __cmsg_ptr
+             - __size_needed)
+          < __cmsg->cmsg_len))
+
+    return (struct cmsghdr *) 0;
+
+  /* Now, we trust cmsg_len and can use it to find the next header.  */
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  */
+#define SCM_RIGHTS      0x1
+#define SCM_CREDENTIALS 0x2
+
+#ifdef __USE_GNU
+/* User visible structure for SCM_CREDENTIALS message */
+struct ucred
+{
+  pid_t pid;			/* PID of sending process.  */
+  uid_t uid;			/* UID of sending process.  */
+  gid_t gid;			/* GID of sending process.  */
+};
+#endif
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+#endif	/* bits/socket.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/socket_type.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/socket_type.h
new file mode 100644
index 0000000..d6255b0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/socket_type.h
@@ -0,0 +1,14 @@
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket_type.h> directly; use <sys/socket.h> instead."
+#endif
+
+/* Types of sockets - Ironclad uses bit flags.  */
+#define SOCK_DGRAM     (1 << 0)
+#define SOCK_RAW       (1 << 1)
+#define SOCK_STREAM    (1 << 2)
+#define SOCK_SEQPACKET (1 << 3)
+
+/* Flags */
+#define SOCK_NONBLOCK (1 << 15)
+#define SOCK_CLOEXEC  (1 << 16)
+#define SOCK_CLOFORK  (1 << 17)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/stat.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/stat.h
new file mode 100644
index 0000000..7d44ab3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/stat.h
@@ -0,0 +1,79 @@
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STAT_H
+#define _BITS_STAT_H	1
+
+#include <bits/wordsize.h>
+
+/* Ironclad stat structure - matches mlibc's definition.  */
+struct stat
+  {
+    __dev_t st_dev;		/* Device.  */
+    __ino_t st_ino;		/* File serial number.  */
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __off_t st_size;		/* Size of file, in bytes.  */
+#ifdef __USE_XOPEN2K8
+    struct timespec st_atim;	/* Time of last access.  */
+    struct timespec st_mtim;	/* Time of last modification.  */
+    struct timespec st_ctim;	/* Time of last status change.  */
+    struct timespec st_btim;	/* Time of creation (birth).  */
+# define st_atime st_atim.tv_sec
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+# define st_btime st_btim.tv_sec
+# define st_birthtim st_btim
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    unsigned long int st_atimensec;
+    __time_t st_mtime;		/* Time of last modification.  */
+    unsigned long int st_mtimensec;
+    __time_t st_ctime;		/* Time of last status change.  */
+    unsigned long int st_ctimensec;
+    __time_t st_btime;		/* Time of creation.  */
+    unsigned long int st_btimensec;
+#endif
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+    __blkcnt_t st_blocks;	/* Number 512-byte blocks allocated.  */
+  };
+
+/* stat64 is the same as stat on Ironclad.  */
+#define stat64 stat
+
+/* File type and permission bits.  */
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* Protection bits.  */
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
+
+/* Ironclad doesn't have message queues, semaphores, or shared memory
+   as filesystem objects, so these always return 0.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+#ifdef __USE_ATFILE
+# define UTIME_NOW	((1l << 30) - 1l)
+# define UTIME_OMIT	((1l << 30) - 2l)
+#endif
+
+#endif /* _BITS_STAT_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/stdio_lim.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/stdio_lim.h
new file mode 100644
index 0000000..e76253c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/stdio_lim.h
@@ -0,0 +1,10 @@
+#ifndef _BITS_STDIO_LIM_H
+#define _BITS_STDIO_LIM_H 1
+
+#ifndef _STDIO_H
+# error "Never include <bits/stdio_lim.h> directly; use <stdio.h> instead."
+#endif
+
+#define FILENAME_MAX 4096
+
+#endif /* bits/stdio_lim.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/syscall.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/syscall.h
new file mode 100644
index 0000000..3549fbd
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/syscall.h
@@ -0,0 +1,17 @@
+#ifndef _BITS_SYSCALL_H
+#define _BITS_SYSCALL_H
+
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."
+#endif
+
+/* Ironclad syscall numbers are defined in <arch-syscall.h> using SYS_* naming.
+   This file is intentionally minimal - all definitions come from arch-syscall.h.
+
+   For user programs: use SYS_* constants (e.g., SYS_read, SYS_write).
+   The SYS_* names match Ironclad kernel naming conventions.  */
+
+/* Include arch-specific syscall definitions.  */
+#include <arch-syscall.h>
+
+#endif /* _BITS_SYSCALL_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-baud.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-baud.h
new file mode 100644
index 0000000..0cc0869
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-baud.h
@@ -0,0 +1,44 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-baud.h> directly; use <termios.h> instead."
+#endif
+
+/* Standard baud rate definitions.  */
+#define B0	0000000
+#define B50	0000001
+#define B75	0000002
+#define B110	0000003
+#define B134	0000004
+#define B150	0000005
+#define B200	0000006
+#define B300	0000007
+#define B600	0000010
+#define B1200	0000011
+#define B1800	0000012
+#define B2400	0000013
+#define B4800	0000014
+#define B9600	0000015
+#define B19200	0000016
+#define B38400	0000017
+
+#ifdef __USE_MISC
+# define EXTA B19200
+# define EXTB B38400
+#endif
+
+#define B57600   0010001
+#define B115200  0010002
+#define B230400  0010003
+#define B460800  0010004
+#define B500000  0010005
+#define B576000  0010006
+#define B921600  0010007
+#define B1000000 0010010
+#define B1152000 0010011
+#define B1500000 0010012
+#define B2000000 0010013
+#define B2500000 0010014
+#define B3000000 0010015
+#define B3500000 0010016
+#define B4000000 0010017
+
+#define SPEED_MAX B4000000
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_cc.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_cc.h
new file mode 100644
index 0000000..855d8ff
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_cc.h
@@ -0,0 +1,19 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_cc.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad c_cc indices - matches mlibc's definition exactly.
+   WARNING: These differ from Linux!  */
+
+/* Indices for the c_cc array in struct termios */
+#define VEOF     0
+#define VEOL     1
+#define VERASE   2
+#define VINTR    3
+#define VKILL    4
+#define VMIN     5
+#define VQUIT    6
+#define VSTART   7
+#define VSTOP    8
+#define VSUSP    9
+#define VTIME   10
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_cflag.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_cflag.h
new file mode 100644
index 0000000..cac7d55
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_cflag.h
@@ -0,0 +1,23 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_cflag.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad c_cflag bits - matches mlibc's definition exactly.  */
+
+#define CSIZE   0x0003
+#define CS5     0x0000
+#define CS6     0x0001
+#define CS7     0x0002
+#define CS8     0x0003
+
+#define CSTOPB  0x0004
+#define CREAD   0x0008
+#define PARENB  0x0010
+#define PARODD  0x0020
+#define HUPCL   0x0040
+#define CLOCAL  0x0080
+
+#ifdef __USE_MISC
+# define CBAUD   0x100F
+/* Note: CRTSCTS is not defined - not in mlibc/Ironclad ABI.  */
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_iflag.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_iflag.h
new file mode 100644
index 0000000..a06a0a3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_iflag.h
@@ -0,0 +1,18 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_iflag.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad c_iflag bits - matches mlibc's definition exactly.  */
+
+#define BRKINT  0x0001
+#define ICRNL   0x0002
+#define IGNBRK  0x0004
+#define IGNCR   0x0008
+#define IGNPAR  0x0010
+#define INLCR   0x0020
+#define INPCK   0x0040
+#define ISTRIP  0x0080
+#define IXANY   0x0100
+#define IXOFF   0x0200
+#define IXON    0x0400
+#define PARMRK  0x0800
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_lflag.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_lflag.h
new file mode 100644
index 0000000..815e3f2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_lflag.h
@@ -0,0 +1,18 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_lflag.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad c_lflag bits - matches mlibc's definition exactly.  */
+
+#define ECHO    0x0001
+#define ECHOE   0x0002
+#define ECHOK   0x0004
+#define ECHONL  0x0008
+#define ICANON  0x0010
+#define IEXTEN  0x0020
+#define ISIG    0x0040
+#define NOFLSH  0x0080
+#define TOSTOP  0x0100
+
+/* Note: ECHOCTL, ECHOPRT, ECHOKE, FLUSHO, PENDIN are not defined -
+   not in mlibc/Ironclad ABI.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_oflag.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_oflag.h
new file mode 100644
index 0000000..b4c411b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-c_oflag.h
@@ -0,0 +1,42 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-c_oflag.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad c_oflag bits - matches mlibc's definition exactly.  */
+
+#define OPOST   0x0001
+#define ONLCR   0x0002
+#define OCRNL   0x0004
+#define ONOCR   0x0008
+#define ONLRET  0x0010
+#define OFDEL   0x0020
+#define OFILL   0x0040
+
+#define NLDLY   0x0080
+#define NL0     0x0000
+#define NL1     0x0080
+
+#define CRDLY   0x0300
+#define CR0     0x0000
+#define CR1     0x0100
+#define CR2     0x0200
+#define CR3     0x0300
+
+#define TABDLY  0x0C00
+#define TAB0    0x0000
+#define TAB1    0x0400
+#define TAB2    0x0800
+#define TAB3    0x0C00
+/* Note: XTABS is not defined - not in mlibc/Ironclad ABI.  */
+
+#define BSDLY   0x1000
+#define BS0     0x0000
+#define BS1     0x1000
+
+#define VTDLY   0x2000
+#define VT0     0x0000
+#define VT1     0x2000
+
+#define FFDLY   0x4000
+#define FF0     0x0000
+#define FF1     0x4000
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-cbaud.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-cbaud.h
new file mode 100644
index 0000000..01f72e5
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-cbaud.h
@@ -0,0 +1,31 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-cbaud.h> directly; use <termios.h> instead."
+#endif
+
+/* CBAUD is already defined in termios-c_cflag.h for Ironclad.  */
+#ifdef __USE_MISC
+# ifndef CBAUD
+#  define CBAUD	 000000010017 /* Baud speed mask (not in POSIX).  */
+# endif
+# define CBAUDEX 000000010000 /* Extra baud speed mask, included in CBAUD.  */
+# define CIBAUD	 002003600000 /* Input baud rate.  */
+# define IBSHIFT 16
+#endif
+
+/* Extra output baud rates (not in POSIX).  */
+#define  __BOTHER    0010000
+#define  __B57600    0010001
+#define  __B115200   0010002
+#define  __B230400   0010003
+#define  __B460800   0010004
+#define  __B500000   0010005
+#define  __B576000   0010006
+#define  __B921600   0010007
+#define  __B1000000  0010010
+#define  __B1152000  0010011
+#define  __B1500000  0010012
+#define  __B2000000  0010013
+#define  __B2500000  0010014
+#define  __B3000000  0010015
+#define  __B3500000  0010016
+#define  __B4000000  0010017
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-misc.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-misc.h
new file mode 100644
index 0000000..25d1dc6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-misc.h
@@ -0,0 +1,5 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-misc.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad-specific termios definitions - currently empty.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-struct.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-struct.h
new file mode 100644
index 0000000..d5d04f7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-struct.h
@@ -0,0 +1,26 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-struct.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad termios structure - matches mlibc's definition exactly.
+   WARNING: This differs significantly from Linux!
+   - NCCS is 11, not 32
+   - No c_line field
+   - Uses c_ibaud/c_obaud instead of c_ispeed/c_ospeed unions  */
+
+#define NCCS 11
+
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_cc[NCCS];		/* control characters */
+    speed_t c_ibaud;		/* input baud rate */
+    speed_t c_obaud;		/* output baud rate */
+  };
+
+/* Ironclad does not have c_ispeed/c_ospeed - use c_ibaud/c_obaud */
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 0
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 0
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-tcflow.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-tcflow.h
new file mode 100644
index 0000000..e36a548
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios-tcflow.h
@@ -0,0 +1,8 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios-tcflow.h> directly; use <termios.h> instead."
+#endif
+
+/* tcsetattr uses these.  */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios.h
new file mode 100644
index 0000000..3fe113a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/termios.h
@@ -0,0 +1,68 @@
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+/* Ironclad uses 4-byte cc_t, matching mlibc's definition.
+   This is DIFFERENT from Linux which uses 1-byte cc_t!  */
+typedef unsigned int	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#ifdef _TERMIOS_H
+# include <bits/termios-struct.h>
+#endif
+
+#include <bits/termios-c_cc.h>
+#include <bits/termios-c_iflag.h>
+#include <bits/termios-c_oflag.h>
+
+/* c_cflag bit meaning */
+#include <bits/termios-c_cflag.h>
+
+#ifdef __USE_MISC
+#define __B0	 0000000	/* hang up */
+#define __B50	 0000001
+#define __B75	 0000002
+#define __B110	 0000003
+#define __B134	 0000004
+#define __B150	 0000005
+#define __B200	 0000006
+#define __B300	 0000007
+#define __B600	 0000010
+#define __B1200	 0000011
+#define __B1800	 0000012
+#define __B2400	 0000013
+#define __B4800	 0000014
+#define __B9600  0000015
+#define __B19200 0000016
+#define __B38400 0000017
+#include <bits/termios-cbaud.h>
+
+# define __EXTA	 __B19200
+# define __EXTB	 __B38400
+# define BOTHER  __BOTHER
+#endif
+
+#include <bits/termios-c_lflag.h>
+
+#ifdef __USE_MISC
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+# define TIOCSER_TEMT    0x01   /* Transmitter physically empty */
+#endif
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+#include <bits/termios-tcflow.h>
+
+#include <bits/termios-misc.h>
+
+#include <bits/termios-baud.h>
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/time.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/time.h
new file mode 100644
index 0000000..29f11e8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/time.h
@@ -0,0 +1,35 @@
+/* Never include this file directly; use <time.h> instead.  */
+
+#ifndef _BITS_TIME_H
+#define _BITS_TIME_H 1
+
+#include <bits/types.h>
+
+/* ISO/IEC 9899:1999 7.23.1: Components of time
+   The macro `CLOCKS_PER_SEC' is an expression with type `clock_t' that is
+   the number per second of the value returned by the `clock' function.  */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems.  */
+#define CLOCKS_PER_SEC  ((__clock_t) 1000000)
+
+#if (!defined __STRICT_ANSI__ || defined __USE_POSIX) \
+   && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+extern long int __sysconf (int);
+# define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
+#endif
+
+#ifdef __USE_POSIX199309
+/* Ironclad clock identifiers (from kernel userland-syscall.ads).  */
+# define CLOCK_REALTIME			0
+# define CLOCK_MONOTONIC		1
+# define CLOCK_PROCESS_CPUTIME_ID	2
+# define CLOCK_THREAD_CPUTIME_ID	3
+
+/* Flag to indicate time is absolute.  */
+# define TIMER_ABSTIME			1
+#endif
+
+#endif /* bits/time.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/__sigset_t.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/__sigset_t.h
new file mode 100644
index 0000000..4ab0f1a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/__sigset_t.h
@@ -0,0 +1,11 @@
+#ifndef ____sigset_t_defined
+#define ____sigset_t_defined
+
+/* Ironclad supports POSIX signals.  Use same size as Linux for compatibility.  */
+#define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))
+typedef struct
+{
+  unsigned long int __val[_SIGSET_NWORDS];
+} __sigset_t;
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/idtype_t.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/idtype_t.h
new file mode 100644
index 0000000..fc084c7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/idtype_t.h
@@ -0,0 +1,14 @@
+#ifndef __idtype_t_defined
+#define __idtype_t_defined
+
+/* The following values are used by the `waitid' function.  */
+typedef enum
+{
+  P_ALL,		/* Wait for any child.  */
+  P_PID,		/* Wait for specified process.  */
+  P_PGID,		/* Wait for members of process group.  */
+  P_PIDFD,		/* Wait for the child referred by the PID file
+			   descriptor.  */
+} idtype_t;
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/siginfo_t.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/siginfo_t.h
new file mode 100644
index 0000000..43c4e00
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/siginfo_t.h
@@ -0,0 +1,151 @@
+#ifndef __siginfo_t_defined
+#define __siginfo_t_defined 1
+
+#include <bits/wordsize.h>
+#include <bits/types.h>
+#include <bits/types/__sigval_t.h>
+
+#define __SI_MAX_SIZE	128
+#if __WORDSIZE == 64
+# define __SI_PAD_SIZE	((__SI_MAX_SIZE / sizeof (int)) - 4)
+#else
+# define __SI_PAD_SIZE	((__SI_MAX_SIZE / sizeof (int)) - 3)
+#endif
+
+/* Some fields of siginfo_t have architecture-specific variations.  */
+#include <bits/siginfo-arch.h>
+#ifndef __SI_ALIGNMENT
+# define __SI_ALIGNMENT		/* nothing */
+#endif
+#ifndef __SI_BAND_TYPE
+# define __SI_BAND_TYPE		long int
+#endif
+#ifndef __SI_CLOCK_T
+# define __SI_CLOCK_T		__clock_t
+#endif
+#ifndef __SI_ERRNO_THEN_CODE
+# define __SI_ERRNO_THEN_CODE	1
+#endif
+#ifndef __SI_HAVE_SIGSYS
+# define __SI_HAVE_SIGSYS	1
+#endif
+#ifndef __SI_SIGFAULT_ADDL
+# define __SI_SIGFAULT_ADDL	/* nothing */
+#endif
+
+typedef struct
+  {
+    int si_signo;		/* Signal number.  */
+#if __SI_ERRNO_THEN_CODE
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+#else
+    int si_code;
+    int si_errno;
+#endif
+#if __WORDSIZE == 64
+    int __pad0;			/* Explicit padding.  */
+#endif
+
+    union
+      {
+	int _pad[__SI_PAD_SIZE];
+
+	 /* kill().  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	  } _kill;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    __sigval_t si_sigval;	/* Signal value.  */
+	  } _timer;
+
+	/* POSIX.1b signals.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    __sigval_t si_sigval;	/* Signal value.  */
+	  } _rt;
+
+	/* SIGCHLD.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Which child.	 */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    int si_status;	/* Exit value or signal.  */
+	    __SI_CLOCK_T si_utime;
+	    __SI_CLOCK_T si_stime;
+	  } _sigchld;
+
+	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
+	struct
+	  {
+	    void *si_addr;	    /* Faulting insn/memory ref.  */
+	    __SI_SIGFAULT_ADDL
+	    short int si_addr_lsb;  /* Valid LSB of the reported address.  */
+	    union
+	      {
+		/* used when si_code=SEGV_BNDERR */
+		struct
+		  {
+		    void *_lower;
+		    void *_upper;
+		  } _addr_bnd;
+		/* used when si_code=SEGV_PKUERR */
+		__uint32_t _pkey;
+	      } _bounds;
+	  } _sigfault;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    __SI_BAND_TYPE si_band;	/* Band event for SIGPOLL.  */
+	    int si_fd;
+	  } _sigpoll;
+
+	/* SIGSYS.  */
+#if __SI_HAVE_SIGSYS
+	struct
+	  {
+	    void *_call_addr;	/* Calling user insn.  */
+	    int _syscall;	/* Triggering system call number.  */
+	    unsigned int _arch; /* AUDIT_ARCH_* of syscall.  */
+	  } _sigsys;
+#endif
+      } _sifields;
+  } siginfo_t __SI_ALIGNMENT;
+
+
+/* X/Open requires some more fields with fixed names.  */
+#define si_pid		_sifields._kill.si_pid
+#define si_uid		_sifields._kill.si_uid
+#define si_timerid	_sifields._timer.si_tid
+#define si_overrun	_sifields._timer.si_overrun
+#define si_status	_sifields._sigchld.si_status
+#define si_utime	_sifields._sigchld.si_utime
+#define si_stime	_sifields._sigchld.si_stime
+#define si_value	_sifields._rt.si_sigval
+#define si_int		_sifields._rt.si_sigval.sival_int
+#define si_ptr		_sifields._rt.si_sigval.sival_ptr
+#define si_addr		_sifields._sigfault.si_addr
+#define si_addr_lsb	_sifields._sigfault.si_addr_lsb
+#define si_lower	_sifields._sigfault._bounds._addr_bnd._lower
+#define si_upper	_sifields._sigfault._bounds._addr_bnd._upper
+#define si_pkey		_sifields._sigfault._bounds._pkey
+#define si_band		_sifields._sigpoll.si_band
+#define si_fd		_sifields._sigpoll.si_fd
+#if __SI_HAVE_SIGSYS
+# define si_call_addr	_sifields._sigsys._call_addr
+# define si_syscall	_sifields._sigsys._syscall
+# define si_arch	_sifields._sigsys._arch
+#endif
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/struct_shmid_ds.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/struct_shmid_ds.h
new file mode 100644
index 0000000..46d3f7d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/types/struct_shmid_ds.h
@@ -0,0 +1,36 @@
+#ifndef _SYS_SHM_H
+# error "Never include <bits/types/struct_shmid_ds.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types/time_t.h>
+
+/* Data structure describing a shared memory segment.
+   This must match mlibc's shmid_ds definition exactly.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    size_t shm_segsz;			/* size of segment in bytes */
+    __time_t shm_atime;			/* time of last shmat() */
+    __time_t shm_dtime;			/* time of last shmdt() */
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+    __pid_t shm_cpid;			/* pid of creator */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    unsigned long int shm_nattch;	/* number of current attaches */
+  };
+
+/* 64-bit time variant - on 64-bit systems, this is the same as shmid_ds. */
+#if __TIMESIZE == 64
+# define __shmid64_ds shmid_ds
+#else
+struct __shmid64_ds
+{
+  struct ipc_perm shm_perm;
+  size_t shm_segsz;
+  __time64_t shm_atime;
+  __time64_t shm_dtime;
+  __time64_t shm_ctime;
+  __pid_t shm_cpid;
+  __pid_t shm_lpid;
+  unsigned long int shm_nattch;
+};
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/typesizes.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/typesizes.h
new file mode 100644
index 0000000..138e55d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/typesizes.h
@@ -0,0 +1,55 @@
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* Ironclad uses 64-bit types for most things.  */
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__UQUAD_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __NLINK_T_TYPE		__U32_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__UQUAD_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define __BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__UQUAD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSWORD_T_TYPE		__SWORD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SQUAD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SQUAD_TYPE
+#define __SUSECONDS64_T_TYPE	__SQUAD_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__SLONGWORD_TYPE
+#define __TIMER_T_TYPE		void *
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __FSID_T_TYPE		__ULONGWORD_TYPE
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
+#define __CPU_MASK_TYPE 	__ULONGWORD_TYPE
+
+/* Ironclad uses 64-bit types, so off_t matches off64_t.  */
+#define __OFF_T_MATCHES_OFF64_T		1
+#define __INO_T_MATCHES_INO64_T		1
+#define __RLIM_T_MATCHES_RLIM64_T	1
+#define __STATFS_MATCHES_STATFS64	1
+#define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+#endif /* bits/typesizes.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/uio_lim.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/uio_lim.h
new file mode 100644
index 0000000..f0ff4b2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/uio_lim.h
@@ -0,0 +1,8 @@
+#ifndef _BITS_UIO_LIM_H
+#define _BITS_UIO_LIM_H 1
+
+/* Maximum length of the 'struct iovec' array in a single call to
+   readv or writev.  This matches mlibc's __MLIBC_IOV_MAX for Ironclad.  */
+#define __IOV_MAX	1024
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/unistd_ext.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/unistd_ext.h
new file mode 100644
index 0000000..b644d66
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/unistd_ext.h
@@ -0,0 +1,17 @@
+#ifndef _UNISTD_H
+# error "Never include <bits/unistd_ext.h> directly; use <unistd.h> instead."
+#endif
+
+#ifdef __USE_GNU
+
+/* Return the kernel thread ID (TID) of the current thread.  The
+   returned value is not subject to caching.  Using the TID to change
+   properties of a thread that has been created using pthread_create
+   can lead to undefined behavior.  Note that a TID uniquely identifies
+   a thread only while this thread is running; a TID can be reused once
+   a thread has exited.  */
+extern __pid_t gettid (void) __THROW;
+
+/* Ironclad does not support close_range - no declaration or constants.  */
+
+#endif /* __USE_GNU  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/utsname.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/utsname.h
new file mode 100644
index 0000000..38b94be
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/utsname.h
@@ -0,0 +1,10 @@
+#ifndef _SYS_UTSNAME_H
+# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
+#endif
+
+/* Length of the entries in `struct utsname' is 65.  */
+#define _UTSNAME_LENGTH 65
+
+/* Ironclad provides the domain name in struct utsname.
+   Define _UTSNAME_DOMAIN_LENGTH to activate this entry.  */
+#define _UTSNAME_DOMAIN_LENGTH _UTSNAME_LENGTH
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/waitflags.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/waitflags.h
new file mode 100644
index 0000000..e17c7dd
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/waitflags.h
@@ -0,0 +1,20 @@
+#ifndef _BITS_WAITFLAGS_H
+#define _BITS_WAITFLAGS_H 1
+
+/* Ironclad uses different flag values than Linux.  */
+
+/* Bits in the third argument to `waitpid'.  */
+#define WCONTINUED	1	/* Report continued child.  */
+#define WNOHANG		2	/* Don't block waiting.  */
+#define WUNTRACED	4	/* Report status of stopped children.  */
+#define WEXITED		8	/* Report dead child.  */
+#define WNOWAIT		16	/* Don't reap, just poll.  */
+#define WSTOPPED	32	/* Report stopped child.  */
+
+#define __WNOTHREAD	0x20000000 /* Don't wait on thread group.  */
+#define __WALL		0x40000000 /* Wait for any child.  */
+#define __WCLONE	0x80000000 /* Wait for cloned process.  */
+
+/* Note: WCOREFLAG is defined in sys/wait.h as __WCOREFLAG.  */
+
+#endif /* _BITS_WAITFLAGS_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/bits/waitstatus.h glibc-workdir/sysdeps/unix/sysv/ironclad/bits/waitstatus.h
new file mode 100644
index 0000000..b7d334b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/bits/waitstatus.h
@@ -0,0 +1,48 @@
+#ifndef _BITS_WAITSTATUS_H
+#define _BITS_WAITSTATUS_H 1
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitstatus.h> directly; use <sys/wait.h> instead."
+#endif
+
+/* Ironclad wait status encoding:
+   bits 0-7:   exit status (WEXITSTATUS)
+   bit 8:      continued (WIFCONTINUED)
+   bit 9:      exited (WIFEXITED)
+   bit 10:     signaled (WIFSIGNALED)
+   bit 11:     stopped (WIFSTOPPED)
+   bits 16-23: stop signal (WSTOPSIG)
+   bits 24-31: termination signal (WTERMSIG)
+*/
+
+/* Extract exit status.  */
+#define __WEXITSTATUS(status)	((status) & 0x000000FF)
+
+/* Test for continued.  */
+#define __WIFCONTINUED(status)	(((status) & 0x00000100) != 0)
+
+/* Test for normal exit.  */
+#define __WIFEXITED(status)	(((status) & 0x00000200) != 0)
+
+/* Test for termination by signal.  */
+#define __WIFSIGNALED(status)	(((status) & 0x00000400) != 0)
+
+/* Test for stopped.  */
+#define __WIFSTOPPED(status)	(((status) & 0x00000800) != 0)
+
+/* Extract stop signal.  */
+#define __WSTOPSIG(status)	(((status) & 0x00FF0000) >> 16)
+
+/* Extract termination signal.  */
+#define __WTERMSIG(status)	(((status) & 0xFF000000) >> 24)
+
+/* Test for core dump.  */
+#define __WCOREDUMP(status)	(((status) & 0x80) != 0)
+
+/* Macros for constructing status values.  */
+#define	__W_EXITCODE(ret, sig)	((ret) | ((sig) << 24) | 0x200)
+#define	__W_STOPCODE(sig)	(((sig) << 16) | 0x800)
+#define	__W_CONTINUED		0x100
+#define	__WCOREFLAG		0x80
+
+#endif /* _BITS_WAITSTATUS_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/brk.c glibc-workdir/sysdeps/unix/sysv/ironclad/brk.c
new file mode 100644
index 0000000..c329c3c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/brk.c
@@ -0,0 +1,23 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <brk_call.h>
+
+/* This must be initialized data because commons can't have aliases.  */
+void *__curbrk = NULL;
+
+/* These track the emulated brk region.  No longer used since we disabled
+   brk emulation, but kept for compatibility.  */
+void *__brk_start = NULL;
+void *__brk_end = NULL;
+
+/* Ironclad note: brk is not supported.  We always return failure to force
+   malloc to use mmap exclusively.  See sbrk.c for details.  */
+int
+__brk (void *addr)
+{
+  (void) addr;  /* Unused.  */
+  __set_errno (ENOMEM);
+  return -1;
+}
+weak_alias (__brk, brk)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/brk_call.h glibc-workdir/sysdeps/unix/sysv/ironclad/brk_call.h
new file mode 100644
index 0000000..0a616df
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/brk_call.h
@@ -0,0 +1,14 @@
+/* Ironclad does not have a brk syscall.  Rather than emulating brk with
+   mmap (which has state-sharing issues between ld.so and libc.so), we
+   simply make brk/sbrk always fail.  This forces malloc to use mmap
+   exclusively, which is the same approach mlibc uses on Ironclad.
+
+   This header is kept for compatibility but __brk_call always returns
+   failure.  */
+
+static inline void *
+__brk_call (void *addr)
+{
+  (void) addr;  /* Unused.  */
+  return NULL;  /* Always fail.  */
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/chdir.c glibc-workdir/sysdeps/unix/sysv/ironclad/chdir.c
new file mode 100644
index 0000000..804c089
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/chdir.c
@@ -0,0 +1,36 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Change the current directory to PATH.
+
+   Ironclad's chdir syscall takes a file descriptor, not a path.
+   We must open the directory first, then pass the fd to chdir.  */
+
+int
+__chdir (const char *path)
+{
+  if (path == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Open the directory.
+     Ironclad open syscall: (dirfd, path, path_len, flags).  */
+  /* Ironclad syscall is named 'open' not 'openat'.  */
+  int fd = INLINE_SYSCALL_CALL (open, AT_FDCWD, path,
+				__builtin_strlen (path), O_RDONLY | O_DIRECTORY);
+  if (fd < 0)
+    return -1;
+
+  /* Ironclad chdir syscall takes a file descriptor.  */
+  int ret = INLINE_SYSCALL_CALL (chdir, fd);
+
+  /* Close the fd - the kernel has recorded the directory.  */
+  INLINE_SYSCALL_CALL (close, fd);
+
+  return ret;
+}
+weak_alias (__chdir, chdir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/check_fds.c glibc-workdir/sysdeps/unix/sysv/ironclad/check_fds.c
new file mode 100644
index 0000000..bdf1370
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/check_fds.c
@@ -0,0 +1,73 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+/* Try to get a machine dependent instruction which will make the
+   program crash.  This is used in case everything else fails.  */
+#include <abort-instr.h>
+#ifndef ABORT_INSTRUCTION
+/* No such instruction is available.  */
+# define ABORT_INSTRUCTION
+#endif
+
+#include <not-cancel.h>
+
+
+/* Ironclad version: We skip the device number check because Ironclad
+   uses sequential device handles (1-50) rather than traditional
+   major/minor device numbers.  We still verify S_ISCHR.  */
+static void
+check_one_fd (int fd, int mode)
+{
+  if (__builtin_expect (__fcntl64_nocancel (fd, F_GETFD), 0) == -1
+      && errno == EBADF)
+    {
+      const char *name;
+
+      /* For writable descriptors we use /dev/full.  */
+      if ((mode & O_ACCMODE) == O_WRONLY)
+	name = _PATH_DEV "full";
+      else
+	name = _PATH_DEVNULL;
+
+      /* Something is wrong with this descriptor, it's probably not
+	 opened.  Open /dev/null so that the SUID program we are
+	 about to start does not accidentally use this descriptor.  */
+      int nullfd = __open_nocancel (name, mode, 0);
+
+      /* We are very paranoid here.  With all means we try to ensure
+	 that we are actually opening the /dev/null device and nothing
+	 else.
+
+	 Note that the following code assumes that STDIN_FILENO,
+	 STDOUT_FILENO, STDERR_FILENO are the three lowest file
+	 descriptor numbers, in this order.
+
+	 Ironclad note: We skip the st_rdev check because Ironclad
+	 doesn't use traditional major/minor device numbers.  */
+      struct __stat64_t64 st;
+      if (__glibc_unlikely (nullfd != fd)
+	  || __glibc_likely (__fstat64_time64 (fd, &st) != 0)
+	  || __glibc_unlikely (S_ISCHR (st.st_mode) == 0))
+	/* We cannot even give an error message here since it would
+	   run into the same problems.  */
+	while (1)
+	  /* Try for ever and ever.  */
+	  ABORT_INSTRUCTION;
+    }
+}
+
+
+void
+__libc_check_standard_fds (void)
+{
+  /* Check all three standard file descriptors.  The O_NOFOLLOW flag
+     is really paranoid but some people actually are.  If /dev/null
+     should happen to be a symlink to somewhere else and not the
+     device commonly known as "/dev/null" we bail out.  */
+  check_one_fd (STDIN_FILENO, O_RDONLY | O_NOFOLLOW);
+  check_one_fd (STDOUT_FILENO, O_WRONLY | O_NOFOLLOW);
+  check_one_fd (STDERR_FILENO, O_WRONLY | O_NOFOLLOW);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/chmod.c glibc-workdir/sysdeps/unix/sysv/ironclad/chmod.c
new file mode 100644
index 0000000..471c83f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/chmod.c
@@ -0,0 +1,19 @@
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+/* Declare __fchmodat - defined in fchmodat.c.  */
+extern int __fchmodat (int fd, const char *file, mode_t mode, int flag);
+
+/* Ironclad has no standalone chmod syscall - it uses fchmodat with
+   path length arguments.  Route through __fchmodat with AT_FDCWD
+   to get proper path length handling.  */
+
+int
+__chmod (const char *file, mode_t mode)
+{
+  return __fchmodat (AT_FDCWD, file, mode, 0);
+}
+
+libc_hidden_def (__chmod)
+weak_alias (__chmod, chmod)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/chown.c glibc-workdir/sysdeps/unix/sysv/ironclad/chown.c
new file mode 100644
index 0000000..3a41898
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/chown.c
@@ -0,0 +1,16 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sysdep.h>
+
+/* Change the owner and group of FILE.
+   Ironclad fchown syscall: (fd, pathname, len, uid, gid, flags).  */
+int
+__chown (const char *file, uid_t owner, gid_t group)
+{
+  size_t len = strlen (file);
+  /* Ironclad syscall is named 'fchown' not 'fchownat' - it takes path args.  */
+  return INLINE_SYSCALL_CALL (fchown, AT_FDCWD, file, len, owner, group, 0);
+}
+libc_hidden_def (__chown)
+weak_alias (__chown, chown)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clock_getres.c glibc-workdir/sysdeps/unix/sysv/ironclad/clock_getres.c
new file mode 100644
index 0000000..c665aaa
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clock_getres.c
@@ -0,0 +1,24 @@
+#include <time.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+/* Ironclad uses a multiplexed clock syscall.
+   Operation 0 = get resolution.  */
+#define CLOCK_OP_GETRES 0
+
+/* Ironclad is 64-bit only, so clock_getres/clock_getres64 are identical.
+   On 64-bit systems, __clock_getres64 is already a macro for __clock_getres.  */
+int
+__clock_getres64 (clockid_t clock_id, struct __timespec64 *res)
+{
+  /* Ironclad clock syscall: operation, clock_id, timespec.  */
+  return INLINE_SYSCALL_CALL (clock, CLOCK_OP_GETRES, clock_id, res);
+}
+libc_hidden_def (__clock_getres)
+
+versioned_symbol (libc, __clock_getres, clock_getres, GLIBC_2_17);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_2, GLIBC_2_17)
+strong_alias (__clock_getres, __clock_getres_2);
+compat_symbol (libc, __clock_getres_2, clock_getres, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clock_gettime.c glibc-workdir/sysdeps/unix/sysv/ironclad/clock_gettime.c
new file mode 100644
index 0000000..e557ff6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clock_gettime.c
@@ -0,0 +1,24 @@
+#include <time.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+/* Ironclad uses a multiplexed clock syscall.
+   Operation 1 = get clock.  */
+#define CLOCK_OP_GET 1
+
+/* Ironclad is 64-bit only, so clock_gettime/clock_gettime64 are identical.
+   On 64-bit systems, __clock_gettime64 is already a macro for __clock_gettime.  */
+int
+__clock_gettime64 (clockid_t clock_id, struct __timespec64 *tp)
+{
+  /* Ironclad clock syscall: operation, clock_id, timespec.  */
+  return INLINE_SYSCALL_CALL (clock, CLOCK_OP_GET, clock_id, tp);
+}
+libc_hidden_def (__clock_gettime)
+
+versioned_symbol (libc, __clock_gettime, clock_gettime, GLIBC_2_17);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_2, GLIBC_2_17)
+strong_alias (__clock_gettime, __clock_gettime_2);
+compat_symbol (libc, __clock_gettime_2, clock_gettime, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clock_nanosleep.c glibc-workdir/sysdeps/unix/sysv/ironclad/clock_nanosleep.c
new file mode 100644
index 0000000..da830cd
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clock_nanosleep.c
@@ -0,0 +1,37 @@
+#include <time.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+#include <shlib-compat.h>
+
+int
+__clock_nanosleep_time64 (clockid_t clock_id, int flags,
+			  const struct __timespec64 *req,
+			  struct __timespec64 *rem)
+{
+  /* Ironclad's clock_nanosleep syscall returns positive errno on error.  */
+  int r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep, clock_id, flags, req, rem);
+  return -r;
+}
+
+#if __TIMESIZE != 64
+libc_hidden_def (__clock_nanosleep_time64)
+
+int
+__clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req,
+                   struct timespec *rem)
+{
+  int r;
+  struct __timespec64 treq64, trem64;
+
+  treq64 = valid_timespec_to_timespec64 (*req);
+  r = __clock_nanosleep_time64 (clock_id, flags, &treq64,
+                                rem != NULL ? &trem64 : NULL);
+
+  if (r == EINTR && rem != NULL && (flags & TIMER_ABSTIME) == 0)
+    *rem = valid_timespec64_to_timespec (trem64);
+
+  return r;
+}
+#endif
+libc_hidden_def (__clock_nanosleep)
+versioned_symbol (libc, __clock_nanosleep, clock_nanosleep, GLIBC_2_17);
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clock_settime.c glibc-workdir/sysdeps/unix/sysv/ironclad/clock_settime.c
new file mode 100644
index 0000000..c07edee
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clock_settime.c
@@ -0,0 +1,17 @@
+#include <time.h>
+#include <sysdep.h>
+
+/* Ironclad uses a multiplexed clock syscall.
+   Operation 2 = set clock.  */
+#define CLOCK_OP_SET 2
+
+/* Ironclad is 64-bit only, so clock_settime/clock_settime64 are identical.
+   On 64-bit systems, __clock_settime64 is already a macro for __clock_settime.  */
+int
+__clock_settime64 (clockid_t clock_id, const struct __timespec64 *tp)
+{
+  /* Ironclad clock syscall: operation, clock_id, timespec.  */
+  return INLINE_SYSCALL_CALL (clock, CLOCK_OP_SET, clock_id, tp);
+}
+libc_hidden_def (__clock_settime)
+weak_alias (__clock_settime, clock_settime)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clone-internal.c glibc-workdir/sysdeps/unix/sysv/ironclad/clone-internal.c
new file mode 100644
index 0000000..3e20d84
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clone-internal.c
@@ -0,0 +1,50 @@
+#include <sysdep.h>
+#include <stddef.h>
+#include <errno.h>
+#include <sched.h>
+#include <clone_internal.h>
+#include <libc-pointer-arith.h>	/* For cast_to_pointer.  */
+#include <stackinfo.h>		/* For _STACK_GROWS_{UP,DOWN}.  */
+
+int
+__clone_internal_fallback (struct clone_args *cl_args,
+			   int (*func) (void *arg), void *arg)
+{
+  /* Map clone3 arguments to clone arguments.  NB: No need to check
+     invalid clone3 specific bits in flags nor exit_signal since this
+     is an internal function.  */
+  int flags = cl_args->flags | cl_args->exit_signal;
+  void *stack = cast_to_pointer (cl_args->stack);
+  int ret;
+
+#if !_STACK_GROWS_DOWN && !_STACK_GROWS_UP
+# error "Define either _STACK_GROWS_DOWN or _STACK_GROWS_UP"
+#endif
+
+#if _STACK_GROWS_DOWN
+  stack += cl_args->stack_size;
+#endif
+  ret = __clone (func, stack, flags, arg,
+		 cast_to_pointer (cl_args->parent_tid),
+		 cast_to_pointer (cl_args->tls),
+		 cast_to_pointer (cl_args->child_tid));
+  return ret;
+}
+
+int
+__clone3_internal (struct clone_args *cl_args, int (*func) (void *args),
+		   void *arg)
+{
+  /* Ironclad doesn't support clone3 syscall, return ENOSYS.  */
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+int
+__clone_internal (struct clone_args *cl_args,
+		  int (*func) (void *arg), void *arg)
+{
+  return __clone_internal_fallback (cl_args, func, arg);
+}
+
+libc_hidden_def (__clone_internal)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clone-pidfd-support.c glibc-workdir/sysdeps/unix/sysv/ironclad/clone-pidfd-support.c
new file mode 100644
index 0000000..0437bd4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clone-pidfd-support.c
@@ -0,0 +1,9 @@
+#include <stdbool.h>
+#include <clone_internal.h>
+
+bool
+__clone_pidfd_supported (void)
+{
+  /* Ironclad doesn't support CLONE_PIDFD yet.  */
+  return false;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/clone3.h glibc-workdir/sysdeps/unix/sysv/ironclad/clone3.h
new file mode 100644
index 0000000..c99166b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/clone3.h
@@ -0,0 +1,45 @@
+#ifndef _CLONE3_H
+#define _CLONE3_H	1
+
+#include <features.h>
+#include <stddef.h>
+#include <bits/types.h>
+
+
+/* Flags for the clone3 syscall (for API compatibility).  */
+#define CLONE_CLEAR_SIGHAND 0x100000000ULL
+#define CLONE_INTO_CGROUP 0x200000000ULL
+
+/* The unsigned 64-bit and 8-byte aligned integer type.  */
+typedef __U64_TYPE __aligned_uint64_t __attribute__ ((__aligned__ (8)));
+
+/* This struct is provided for API compatibility.  Ironclad may not
+   support clone3, but the structure is needed for compilation.  */
+
+struct clone_args
+{
+  /* Flags bit mask.  */
+  __aligned_uint64_t flags;
+  /* Where to store PID file descriptor (pid_t *).  */
+  __aligned_uint64_t pidfd;
+  /* Where to store child TID, in child's memory (pid_t *).  */
+  __aligned_uint64_t child_tid;
+  /* Where to store child TID, in parent's memory (int *). */
+  __aligned_uint64_t parent_tid;
+  /* Signal to deliver to parent on child termination */
+  __aligned_uint64_t exit_signal;
+  /* The lowest address of stack.  */
+  __aligned_uint64_t stack;
+  /* Size of stack.  */
+  __aligned_uint64_t stack_size;
+  /* Location of new TLS.  */
+  __aligned_uint64_t tls;
+  /* Pointer to a pid_t array.  */
+  __aligned_uint64_t set_tid;
+  /* Number of elements in set_tid. */
+  __aligned_uint64_t set_tid_size;
+  /* File descriptor for target cgroup of child.  */
+  __aligned_uint64_t cgroup;
+};
+
+#endif /* clone3.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/close.c glibc-workdir/sysdeps/unix/sysv/ironclad/close.c
new file mode 100644
index 0000000..5c793de
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/close.c
@@ -0,0 +1,12 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+int
+__close (int fd)
+{
+  return SYSCALL_CANCEL (close, fd);
+}
+libc_hidden_def (__close)
+strong_alias (__close, __libc_close)
+weak_alias (__close, close)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/close_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/close_nocancel.c
new file mode 100644
index 0000000..f045b1d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/close_nocancel.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+int
+__close_nocancel (int fd)
+{
+  return INLINE_SYSCALL_CALL (close, fd);
+}
+libc_hidden_def (__close_nocancel)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/close_nocancel_nostatus.c glibc-workdir/sysdeps/unix/sysv/ironclad/close_nocancel_nostatus.c
new file mode 100644
index 0000000..c73dc62
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/close_nocancel_nostatus.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+void
+__close_nocancel_nostatus (int fd)
+{
+  INTERNAL_SYSCALL_CALL (close, fd);
+}
+libc_hidden_def (__close_nocancel_nostatus)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/closedir.c glibc-workdir/sysdeps/unix/sysv/ironclad/closedir.c
new file mode 100644
index 0000000..37b917a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/closedir.c
@@ -0,0 +1,36 @@
+#include <errno.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <dirstream.h>
+#include <not-cancel.h>
+
+/* Close the directory stream DIRP.
+   Return 0 if successful, -1 if not.  */
+int
+__closedir (DIR *dirp)
+{
+  int fd;
+
+  if (dirp == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* We do not try to synchronize access here.  If some other thread
+     still uses this handle it is a big mistake and that thread
+     deserves all the bad data it gets.  */
+
+  fd = dirp->fd;
+
+#if IS_IN (libc)
+  __libc_lock_fini (dirp->lock);
+#endif
+
+  free ((void *) dirp);
+
+  return __close_nocancel (fd);
+}
+weak_alias (__closedir, closedir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/closefrom_fallback.c glibc-workdir/sysdeps/unix/sysv/ironclad/closefrom_fallback.c
new file mode 100644
index 0000000..235b2e5
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/closefrom_fallback.c
@@ -0,0 +1,24 @@
+#include <errno.h>
+#include <not-cancel.h>
+#include <stdbool.h>
+#include <sys/resource.h>
+
+/* Close all file descriptors >= FROM.
+   Ironclad doesn't have /proc/self/fd or close_range syscall,
+   so we iterate through possible fds up to RLIMIT_NOFILE.  */
+_Bool
+__closefrom_fallback (int from, _Bool dirfd_fallback __attribute__ ((unused)))
+{
+  struct rlimit64 rl;
+  int max_fd;
+
+  if (__getrlimit64 (RLIMIT_NOFILE, &rl) == 0)
+    max_fd = (rl.rlim_cur == RLIM64_INFINITY) ? 1024 : (int) rl.rlim_cur;
+  else
+    max_fd = 1024;  /* Reasonable default if getrlimit fails.  */
+
+  for (int fd = from; fd < max_fd; fd++)
+    __close_nocancel (fd);  /* Ignore errors - fd may not be open.  */
+
+  return true;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/connect.c glibc-workdir/sysdeps/unix/sysv/ironclad/connect.c
new file mode 100644
index 0000000..4940b14
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/connect.c
@@ -0,0 +1,11 @@
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+int
+__libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t len)
+{
+  return SYSCALL_CANCEL (connect, fd, addr.__sockaddr__, len);
+}
+weak_alias (__libc_connect, connect)
+weak_alias (__libc_connect, __connect)
+libc_hidden_weak (__connect)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/device-nrs.h glibc-workdir/sysdeps/unix/sysv/ironclad/device-nrs.h
new file mode 100644
index 0000000..77890eb
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/device-nrs.h
@@ -0,0 +1,17 @@
+#ifndef _DEVICE_NRS_H
+#define _DEVICE_NRS_H	1
+
+#include <sys/sysmacros.h>
+
+/* Ironclad doesn't use traditional major/minor device numbers.
+   Devices are assigned sequential handles (1-50) as they register.
+   Don't define DEV_NULL_MAJOR/DEV_NULL_MINOR so daemon.c skips
+   the device number check (it still verifies S_ISCHR).  */
+
+/* DEV_TTY_P: Test whether given device is a tty.
+   Ironclad doesn't use major/minor numbers, so we can't test this way.
+   Return false (0) to disable this check; callers will use other methods
+   like isatty() or tcgetattr() to detect ttys.  */
+#define DEV_TTY_P(statp) 0
+
+#endif	/* device-nrs.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dirfd.c glibc-workdir/sysdeps/unix/sysv/ironclad/dirfd.c
new file mode 100644
index 0000000..76fe5c6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dirfd.c
@@ -0,0 +1,13 @@
+#include <dirent.h>
+#include <dirstream.h>
+
+#undef dirfd
+
+int
+__dirfd (DIR *dirp)
+{
+  return dirp->fd;
+}
+
+weak_alias (__dirfd, dirfd)
+libc_hidden_def (dirfd)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dirstream.h glibc-workdir/sysdeps/unix/sysv/ironclad/dirstream.h
new file mode 100644
index 0000000..8ce3fbf
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dirstream.h
@@ -0,0 +1,38 @@
+#ifndef	_DIRSTREAM_H
+#define	_DIRSTREAM_H	1
+
+#include <sys/types.h>
+
+#include <libc-lock.h>
+
+/* Directory stream type.
+
+   The miscellaneous Unix `readdir' implementations read directory data
+   into a buffer and return `struct dirent *' pointers into it.  */
+
+struct __dirstream
+  {
+    int fd;			/* File descriptor.  */
+
+    __libc_lock_define (, lock) /* Mutex lock for this structure.  */
+
+    size_t allocation;		/* Space allocated for the block.  */
+    size_t size;		/* Total valid data in the block.  */
+    size_t offset;		/* Current offset into the block.  */
+
+    off_t filepos;		/* Position of next entry to read.  */
+
+    int errcode;		/* Delayed error code.  */
+
+    /* Directory block.  We must make sure that this block starts
+       at an address that is aligned adequately enough to store
+       dirent entries.  Using the alignment of "void *" is not
+       sufficient because dirents on 32-bit platforms can require
+       64-bit alignment.  We use "long double" here to be consistent
+       with what malloc uses.  */
+    char data[0] __attribute__ ((aligned (__alignof__ (long double))));
+  };
+
+#define _DIR_dirfd(dirp)	((dirp)->fd)
+
+#endif	/* dirstream.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-early_allocate.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-early_allocate.c
new file mode 100644
index 0000000..36805a3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-early_allocate.c
@@ -0,0 +1,34 @@
+/* Ironclad does not have a brk syscall, so we use mmap directly for
+   early memory allocation.  This avoids the state-sharing issues that
+   arise when trying to emulate brk between ld.so and libc.so.  */
+
+/* Mark symbols hidden in static PIE for early self relocation to work.  */
+#if BUILD_PIE_DEFAULT
+# pragma GCC visibility push(hidden)
+#endif
+#include <startup.h>
+
+#include <ldsodefs.h>
+#include <stddef.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+void *
+_dl_early_allocate (size_t size)
+{
+  unsigned long int sc_err;
+  void *result;
+  int prot = PROT_READ | PROT_WRITE;
+  int flags = MAP_PRIVATE | MAP_ANONYMOUS;
+
+  /* Use mmap directly for early allocation.  */
+  result = (void *) INTERNAL_SYSCALL_NCS_ERR (SYS_mmap, sc_err, 6,
+                                              NULL, size, prot, flags, 0, 0);
+
+  if (sc_err != 0 || result == MAP_FAILED)
+    return NULL;
+
+  return result;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-execstack.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-execstack.c
new file mode 100644
index 0000000..850a981
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-execstack.c
@@ -0,0 +1,11 @@
+#include <ldsodefs.h>
+#include <errno.h>
+
+/* There is no portable way to know the bounds of the initial thread's stack
+   so as to mprotect it.  Return ENOSYS.  */
+
+int
+_dl_make_stack_executable (const void *stack_endp)
+{
+  return ENOSYS;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-getcwd.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-getcwd.c
new file mode 100644
index 0000000..4bd5657
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-getcwd.c
@@ -0,0 +1 @@
+#include "getcwd.c"
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-openat64.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-openat64.c
new file mode 100644
index 0000000..d513c0a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-openat64.c
@@ -0,0 +1,16 @@
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+int
+openat64 (int dfd, const char *file, int oflag, ...)
+{
+  assert (!__OPEN_NEEDS_MODE (oflag));
+
+  /* Ironclad open syscall: dirfd, path, path_len, flags.
+     Compute path_len first to avoid clobbering later arguments.  */
+  size_t path_len = __builtin_strlen (file);
+  /* Ironclad syscall is named 'open' not 'openat'.  */
+  return INLINE_SYSCALL (open, 4, dfd, file, path_len, oflag | O_LARGEFILE);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-opendir.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-opendir.c
new file mode 100644
index 0000000..c1cdc05
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-opendir.c
@@ -0,0 +1 @@
+#include <opendir.c>
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-osinfo.h glibc-workdir/sysdeps/unix/sysv/ironclad/dl-osinfo.h
new file mode 100644
index 0000000..e7df877
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-osinfo.h
@@ -0,0 +1,45 @@
+/* Ironclad version - based on generic with proper includes.  */
+
+#include <endian.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_stack_chk_guard (void *dl_random)
+{
+  union
+  {
+    uintptr_t num;
+    unsigned char bytes[sizeof (uintptr_t)];
+  } ret = { 0 };
+
+  if (dl_random == NULL)
+    {
+      ret.bytes[sizeof (ret) - 1] = 255;
+      ret.bytes[sizeof (ret) - 2] = '\n';
+    }
+  else
+    {
+      memcpy (ret.bytes, dl_random, sizeof (ret));
+#if BYTE_ORDER == LITTLE_ENDIAN
+      ret.num &= ~(uintptr_t) 0xff;
+#elif BYTE_ORDER == BIG_ENDIAN
+      ret.num &= ~((uintptr_t) 0xff << (8 * (sizeof (ret) - 1)));
+#else
+# error "BYTE_ORDER unknown"
+#endif
+    }
+  return ret.num;
+}
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_pointer_guard (void *dl_random, uintptr_t stack_chk_guard)
+{
+  uintptr_t ret;
+  if (dl_random == NULL)
+    ret = stack_chk_guard;
+  else
+    memcpy (&ret, (char *) dl_random + sizeof (ret), sizeof (ret));
+  return ret;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-parse_auxv.h glibc-workdir/sysdeps/unix/sysv/ironclad/dl-parse_auxv.h
new file mode 100644
index 0000000..f6ea8f8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-parse_auxv.h
@@ -0,0 +1,40 @@
+#include <elf.h>
+#include <entry.h>
+#include <fpu_control.h>
+#include <ldsodefs.h>
+#include <link.h>
+#include <unistd.h>
+
+/* Use AT_RANDOM (25) as maximum since Ironclad doesn't have all Linux auxv.  */
+typedef ElfW(Addr) dl_parse_auxv_t[AT_RANDOM + 1];
+
+/* Copy the auxiliary vector into AUXV_VALUES and set up GLRO
+   variables.  */
+static inline
+void _dl_parse_auxv (ElfW(auxv_t) *av, dl_parse_auxv_t auxv_values)
+{
+  auxv_values[AT_ENTRY] = (ElfW(Addr)) ENTRY_POINT;
+  auxv_values[AT_PAGESZ] = EXEC_PAGESIZE;
+  auxv_values[AT_FPUCW] = _FPU_DEFAULT;
+
+  for (; av->a_type != AT_NULL; av++)
+    if (av->a_type <= AT_RANDOM)
+      auxv_values[av->a_type] = av->a_un.a_val;
+
+  GLRO(dl_pagesize) = auxv_values[AT_PAGESZ];
+  __libc_enable_secure = auxv_values[AT_SECURE];
+  GLRO(dl_platform) = (void *) auxv_values[AT_PLATFORM];
+  GLRO(dl_hwcap) = auxv_values[AT_HWCAP];
+  GLRO(dl_clktck) = auxv_values[AT_CLKTCK];
+  GLRO(dl_fpu_control) = auxv_values[AT_FPUCW];
+  _dl_random = (void *) auxv_values[AT_RANDOM];
+
+  /* Ironclad doesn't have SYSINFO_EHDR, hwcap2/3/4, or MINSIGSTKSZ auxv.  */
+  GLRO(dl_hwcap2) = 0;
+  GLRO(dl_hwcap3) = 0;
+  GLRO(dl_hwcap4) = 0;
+  GLRO(dl_minsigstacksize) = CONSTANT_MINSIGSTKSZ;
+  /* Ironclad doesn't have vDSO */
+
+  DL_PLATFORM_AUXV
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-sysdep.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-sysdep.c
new file mode 100644
index 0000000..5eec3cf
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-sysdep.c
@@ -0,0 +1,209 @@
+/* Ironclad dl-sysdep - based on Linux version.  */
+
+#include <_itoa.h>
+#include <assert.h>
+#include <dl-auxv.h>
+#include <dl-osinfo.h>
+#include <dl-parse_auxv.h>
+#include <dl-tunables.h>
+#include <elf.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ldsodefs.h>
+#include <libc-internal.h>
+#include <libintl.h>
+#include <not-cancel.h>
+#include <stdlib.h>
+#include <string.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+#include <tls.h>
+#include <unistd.h>
+#include <dl-symbol-redir-ifunc.h>
+
+#include <dl-machine.h>
+#include <dl-hwcap-check.h>
+
+#ifdef SHARED
+extern char **_environ attribute_hidden;
+extern char _end[] attribute_hidden;
+
+/* Protect SUID program against misuse of file descriptors.  */
+extern void __libc_check_standard_fds (void);
+
+int __libc_enable_secure attribute_relro = 0;
+rtld_hidden_data_def (__libc_enable_secure)
+/* This variable contains the lowest stack address ever used.  */
+void *__libc_stack_end attribute_relro = NULL;
+rtld_hidden_data_def(__libc_stack_end)
+void *_dl_random attribute_relro = NULL;
+
+#ifndef DL_STACK_END
+# define DL_STACK_END(cookie) ((void *) (cookie))
+#endif
+
+/* Arguments passed to dl_main.  */
+struct dl_main_arguments
+{
+  const ElfW(Phdr) *phdr;
+  ElfW(Word) phnum;
+  ElfW(Addr) user_entry;
+};
+
+/* Separate function, so that dl_main can be called without the large
+   array on the stack.  */
+static void
+_dl_sysdep_parse_arguments (void **start_argptr,
+			    struct dl_main_arguments *args)
+{
+  _dl_argc = (intptr_t) *start_argptr;
+  _dl_argv = (char **) (start_argptr + 1); /* Necessary aliasing violation.  */
+  _environ = _dl_argv + _dl_argc + 1;
+  for (char **tmp = _environ; ; ++tmp)
+    if (*tmp == NULL)
+      {
+	/* Another necessary aliasing violation.  */
+	GLRO(dl_auxv) = (ElfW(auxv_t) *) (tmp + 1);
+	break;
+      }
+
+  dl_parse_auxv_t auxv_values = { 0, };
+  _dl_parse_auxv (GLRO(dl_auxv), auxv_values);
+
+  args->phdr = (const ElfW(Phdr) *) auxv_values[AT_PHDR];
+  args->phnum = auxv_values[AT_PHNUM];
+  args->user_entry = auxv_values[AT_ENTRY];
+}
+
+ElfW(Addr)
+_dl_sysdep_start (void **start_argptr,
+		  void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,
+				   ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))
+{
+  __libc_stack_end = DL_STACK_END (start_argptr);
+
+  struct dl_main_arguments dl_main_args;
+  _dl_sysdep_parse_arguments (start_argptr, &dl_main_args);
+
+  dl_hwcap_check ();
+
+  __tunables_init (_environ);
+
+  /* Initialize DSO sorting algorithm after tunables.  */
+  _dl_sort_maps_init ();
+
+  __brk (NULL);			/* Initialize the break.  */
+
+#ifdef DL_PLATFORM_INIT
+  DL_PLATFORM_INIT;
+#endif
+
+  /* Determine the length of the platform name.  */
+  if (GLRO(dl_platform) != NULL)
+    GLRO(dl_platformlen) = strlen (GLRO(dl_platform));
+
+  if (__sbrk (0) == _end)
+    /* The dynamic linker was run as a program, and so the initial break
+       starts just after our bss, at &_end.  The malloc in dl-minimal.c
+       will consume the rest of this page, so tell the kernel to move the
+       break up that far.  When the user program examines its break, it
+       will see this new value and not clobber our data.  */
+    __sbrk (GLRO(dl_pagesize)
+	    - (((uintptr_t) _end) & (GLRO(dl_pagesize) - 1)));
+
+  /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
+     allocated.  If necessary we are doing it ourself.  If it is not
+     possible we stop the program.  */
+  if (__builtin_expect (__libc_enable_secure, 0))
+    __libc_check_standard_fds ();
+
+  (*dl_main) (dl_main_args.phdr, dl_main_args.phnum,
+              &dl_main_args.user_entry, GLRO(dl_auxv));
+  return dl_main_args.user_entry;
+}
+
+void
+_dl_sysdep_start_cleanup (void)
+{
+}
+
+void
+_dl_show_auxv (void)
+{
+  char buf[64];
+  ElfW(auxv_t) *av;
+
+  /* Terminate string.  */
+  buf[63] = '\0';
+
+  for (av = GLRO(dl_auxv); av->a_type != AT_NULL; ++av)
+    {
+      static const struct
+      {
+	const char label[22];
+	enum { unknown = 0, dec, hex, str, ignore } form : 8;
+      } auxvars[] =
+	{
+	  [AT_EXECFD - 2] =		{ "EXECFD:            ", dec },
+	  [AT_EXECFN - 2] =		{ "EXECFN:            ", str },
+	  [AT_PHDR - 2] =		{ "PHDR:              0x", hex },
+	  [AT_PHENT - 2] =		{ "PHENT:             ", dec },
+	  [AT_PHNUM - 2] =		{ "PHNUM:             ", dec },
+	  [AT_PAGESZ - 2] =		{ "PAGESZ:            ", dec },
+	  [AT_BASE - 2] =		{ "BASE:              0x", hex },
+	  [AT_FLAGS - 2] =		{ "FLAGS:             0x", hex },
+	  [AT_ENTRY - 2] =		{ "ENTRY:             0x", hex },
+	  [AT_NOTELF - 2] =		{ "NOTELF:            ", hex },
+	  [AT_UID - 2] =		{ "UID:               ", dec },
+	  [AT_EUID - 2] =		{ "EUID:              ", dec },
+	  [AT_GID - 2] =		{ "GID:               ", dec },
+	  [AT_EGID - 2] =		{ "EGID:              ", dec },
+	  [AT_PLATFORM - 2] =		{ "PLATFORM:          ", str },
+	  [AT_HWCAP - 2] =		{ "HWCAP:             0x", hex },
+	  [AT_CLKTCK - 2] =		{ "CLKTCK:            ", dec },
+	  [AT_SECURE - 2] =		{ "SECURE:            ", dec },
+	  [AT_RANDOM - 2] =		{ "RANDOM:            0x", hex },
+	};
+      unsigned int idx = (unsigned int) (av->a_type - 2);
+
+      if ((unsigned int) av->a_type < 2u
+	  || (idx < sizeof (auxvars) / sizeof (auxvars[0])
+	      && auxvars[idx].form == ignore))
+	continue;
+
+      assert (AT_NULL == 0);
+      assert (AT_IGNORE == 1);
+
+      if (idx < sizeof (auxvars) / sizeof (auxvars[0])
+	  && auxvars[idx].form != unknown)
+	{
+	  const char *val = (char *) av->a_un.a_val;
+
+	  if (__builtin_expect (auxvars[idx].form, dec) == dec)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 10, 0);
+	  else if (__builtin_expect (auxvars[idx].form, hex) == hex)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 16, 0);
+
+	  _dl_printf ("AT_%s%s\n", auxvars[idx].label, val);
+
+	  continue;
+	}
+
+      /* Unknown value: print a generic line.  */
+      char buf2[17];
+      buf2[sizeof (buf2) - 1] = '\0';
+      const char *val2 = _itoa ((unsigned long int) av->a_un.a_val,
+				buf2 + sizeof buf2 - 1, 16, 0);
+      const char *val =  _itoa ((unsigned long int) av->a_type,
+				buf + sizeof buf - 1, 16, 0);
+      _dl_printf ("AT_??? (0x%s): 0x%s\n", val, val2);
+    }
+}
+
+#endif /* SHARED */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dl-tls_init_tp.c glibc-workdir/sysdeps/unix/sysv/ironclad/dl-tls_init_tp.c
new file mode 100644
index 0000000..d03383d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dl-tls_init_tp.c
@@ -0,0 +1,95 @@
+#include <kernel-features.h>
+#include <ldsodefs.h>
+#include <list.h>
+#include <pthreadP.h>
+#include <tls.h>
+#include <rseq-internal.h>
+#include <thread_pointer.h>
+#include <dl-symbol-redir-ifunc.h>
+
+#define TUNABLE_NAMESPACE pthread
+#include <dl-tunables.h>
+
+#ifndef __ASSUME_SET_ROBUST_LIST
+bool __nptl_set_robust_list_avail;
+rtld_hidden_data_def (__nptl_set_robust_list_avail)
+#endif
+
+bool __nptl_initial_report_events;
+rtld_hidden_def (__nptl_initial_report_events)
+
+#ifdef SHARED
+/* Dummy implementation.  See __rtld_mutex_init.  */
+static int
+rtld_mutex_dummy (pthread_mutex_t *lock)
+{
+  return 0;
+}
+#endif
+
+const unsigned int __rseq_flags;
+
+/* RSEQ stub variables for Ironclad (RSEQ not supported).  */
+size_t _rseq_align attribute_hidden = RSEQ_MIN_ALIGN;
+unsigned int _rseq_size attribute_hidden = 0;
+ptrdiff_t _rseq_offset attribute_hidden = 0;
+
+void
+__tls_pre_init_tp (void)
+{
+  /* The list data structures are not consistent until
+     initialized.  */
+  INIT_LIST_HEAD (&GL (dl_stack_used));
+  INIT_LIST_HEAD (&GL (dl_stack_user));
+  INIT_LIST_HEAD (&GL (dl_stack_cache));
+
+#ifdef SHARED
+  ___rtld_mutex_lock = rtld_mutex_dummy;
+  ___rtld_mutex_unlock = rtld_mutex_dummy;
+#endif
+}
+
+void
+__tls_init_tp (void)
+{
+  struct pthread *pd = THREAD_SELF;
+
+  /* Set up thread stack list management.  */
+  list_add (&pd->list, &GL (dl_stack_user));
+
+   /* Early initialization of the TCB.
+      Ironclad doesn't support set_tid_address syscall, so we get the
+      tid using gettid instead.  */
+   pd->tid = INTERNAL_SYSCALL_CALL (gettid);
+   THREAD_SETMEM (pd, specific[0], &pd->specific_1stblock[0]);
+   THREAD_SETMEM (pd, stack_mode, ALLOCATE_GUARD_USER);
+
+  /* Before initializing GL (dl_stack_user), the debugger could not
+     find us and had to set __nptl_initial_report_events.  Propagate
+     its setting.  */
+  THREAD_SETMEM (pd, report_events, __nptl_initial_report_events);
+
+  /* Initialize the robust mutex data.
+     Note: Ironclad doesn't support set_robust_list, so we skip the syscall.  */
+  {
+#if __PTHREAD_MUTEX_HAVE_PREV
+    pd->robust_prev = &pd->robust_head;
+#endif
+    pd->robust_head.list = &pd->robust_head;
+    pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
+                                    - offsetof (pthread_mutex_t,
+                                                __data.__list.__next));
+    /* Ironclad doesn't have set_robust_list syscall - skip it.  */
+#ifndef __ASSUME_SET_ROBUST_LIST
+    __nptl_set_robust_list_avail = false;
+#endif
+  }
+
+  /* Ironclad doesn't support RSEQ - always mark as disabled.  */
+  _rseq_size = 0;
+
+  /* Set initial thread's stack block from 0 up to __libc_stack_end.
+     It will be bigger than it actually is, but for unwind.c/pt-longjmp.c
+     purposes this is good enough.  */
+  THREAD_SETMEM (pd, stackblock_size, (size_t) __libc_stack_end);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dup.c glibc-workdir/sysdeps/unix/sysv/ironclad/dup.c
new file mode 100644
index 0000000..d4b9351
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dup.c
@@ -0,0 +1,15 @@
+/* Ironclad does not have a native dup syscall.  We implement it using
+   fcntl(F_DUPFD).  A SYS_dup alias to SYS_fcntl in arch-syscall.h
+   doesn't work because it only passes one argument, leaving the fcntl
+   command (rsi) as garbage.  */
+
+#include <fcntl.h>
+#include <unistd.h>
+
+int
+__dup (int fd)
+{
+  return __fcntl (fd, F_DUPFD, 0);
+}
+libc_hidden_def (__dup)
+weak_alias (__dup, dup)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dup2.c glibc-workdir/sysdeps/unix/sysv/ironclad/dup2.c
new file mode 100644
index 0000000..6f2cf5f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dup2.c
@@ -0,0 +1,43 @@
+/* Ironclad does not have a native dup2 syscall.  We implement it using
+   close() followed by fcntl(F_DUPFD).  This is the POSIX-compliant
+   approach and works because F_DUPFD returns the lowest available fd
+   >= the requested fd, and we just closed the target fd.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/* Duplicate FD to FD2, closing the old FD2 and making FD2 be
+   open the same file as FD is.  Return FD2 or -1.  */
+int
+__dup2 (int fd, int fd2)
+{
+  int save;
+
+  if (fd2 < 0)
+    {
+      __set_errno (EBADF);
+      return -1;
+    }
+
+  /* Check if FD is valid by trying to get the file status flags.  */
+  if (__fcntl (fd, F_GETFL) < 0)
+    return -1;
+
+  /* Degenerate case: fd == fd2.  */
+  if (fd == fd2)
+    return fd2;
+
+  /* Close fd2.  This is not atomic, but it's the best we can do
+     without a native dup2 syscall.  Ignore errors from close since
+     fd2 might not be open.  */
+  save = errno;
+  (void) __close (fd2);
+  __set_errno (save);
+
+  /* Duplicate fd to the lowest available fd >= fd2.  Since we just
+     closed fd2, this should return fd2.  */
+  return __fcntl (fd, F_DUPFD, fd2);
+}
+libc_hidden_def (__dup2)
+weak_alias (__dup2, dup2)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/dup3.c glibc-workdir/sysdeps/unix/sysv/ironclad/dup3.c
new file mode 100644
index 0000000..e25d6be
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/dup3.c
@@ -0,0 +1,56 @@
+/* Ironclad does not have a native dup3 syscall.  We implement it using
+   close() followed by fcntl(F_DUPFD or F_DUPFD_CLOEXEC).  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/* Duplicate FD to FD2, closing the old FD2 and making FD2 be
+   open the same file as FD is, with flags according to FLAGS.
+   Return FD2 or -1.  */
+int
+__dup3 (int fd, int fd2, int flags)
+{
+  int save;
+  int fcntl_cmd;
+
+  if (fd2 < 0)
+    {
+      __set_errno (EBADF);
+      return -1;
+    }
+
+  /* dup3 with fd == fd2 is required to fail with EINVAL.  */
+  if (fd == fd2)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Only O_CLOEXEC is supported as a flag.  */
+  if (flags & ~O_CLOEXEC)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Check if FD is valid by trying to get the file status flags.  */
+  if (__fcntl (fd, F_GETFL) < 0)
+    return -1;
+
+  /* Choose F_DUPFD_CLOEXEC if O_CLOEXEC is requested.  */
+  fcntl_cmd = (flags & O_CLOEXEC) ? F_DUPFD_CLOEXEC : F_DUPFD;
+
+  /* Close fd2.  This is not atomic, but it's the best we can do
+     without a native dup3 syscall.  Ignore errors from close since
+     fd2 might not be open.  */
+  save = errno;
+  (void) __close (fd2);
+  __set_errno (save);
+
+  /* Duplicate fd to the lowest available fd >= fd2.  Since we just
+     closed fd2, this should return fd2.  */
+  return __fcntl (fd, fcntl_cmd, fd2);
+}
+libc_hidden_def (__dup3)
+weak_alias (__dup3, dup3)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/euidaccess.c glibc-workdir/sysdeps/unix/sysv/ironclad/euidaccess.c
new file mode 100644
index 0000000..62fc2e3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/euidaccess.c
@@ -0,0 +1,16 @@
+/* Ironclad-specific version that uses faccessat with AT_EACCESS.
+   This avoids the portability check in sysdeps/posix/euidaccess.c
+   which assumes R_OK/W_OK/X_OK match S_IROTH/S_IWOTH/S_IXOTH.
+   Ironclad uses different values for the access mode constants.  */
+
+#include <fcntl.h>
+#include <unistd.h>
+
+int
+__euidaccess (const char *path, int mode)
+{
+  return __faccessat (AT_FDCWD, path, mode, AT_EACCESS);
+}
+
+weak_alias (__euidaccess, euidaccess)
+weak_alias (__euidaccess, eaccess)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/execve.c glibc-workdir/sysdeps/unix/sysv/ironclad/execve.c
new file mode 100644
index 0000000..9b1b508
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/execve.c
@@ -0,0 +1,38 @@
+#include <errno.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Replace the current process, executing PATH with arguments ARGV and
+   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.
+
+   Ironclad exec syscall signature:
+   (path, path_len, argv, argv_len, envp, envp_len)
+   where argv_len and envp_len are the array counts (not including NULL).  */
+
+int
+__execve (const char *path, char *const argv[], char *const envp[])
+{
+  if (path == NULL || argv == NULL || envp == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Count argv entries.  */
+  int argv_len;
+  for (argv_len = 0; argv[argv_len] != NULL; argv_len++)
+    ;
+
+  /* Count envp entries.  */
+  int envp_len;
+  for (envp_len = 0; envp[envp_len] != NULL; envp_len++)
+    ;
+
+  size_t path_len = __builtin_strlen (path);
+
+  /* Ironclad syscall is named 'exec' not 'execve'.  */
+  return INLINE_SYSCALL_CALL (exec, path, path_len, argv, argv_len,
+			      envp, envp_len);
+}
+weak_alias (__execve, execve)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/faccessat.c glibc-workdir/sysdeps/unix/sysv/ironclad/faccessat.c
new file mode 100644
index 0000000..17ab5e3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/faccessat.c
@@ -0,0 +1,58 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+#include <ldsodefs.h>
+
+
+int
+__faccessat (int fd, const char *file, int mode, int flag)
+{
+  /* Ironclad does not have faccessat2, so we use faccessat directly
+     for simple cases and stat-based checking for flags.  */
+  if (flag & ~(AT_SYMLINK_NOFOLLOW | AT_EACCESS))
+    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
+
+  if ((flag == 0 || ((flag & ~AT_EACCESS) == 0 && ! __libc_enable_secure)))
+    {
+      /* Ironclad access syscall: (dirfd, path, path_len, mode, flags).
+	 Compute path_len first to avoid clobbering later arguments.  */
+      size_t path_len = __builtin_strlen (file);
+      /* Ironclad syscall is named 'access' not 'faccessat'.  */
+      return INLINE_SYSCALL (access, 5, fd, file, path_len, mode, 0);
+    }
+
+  /* For AT_SYMLINK_NOFOLLOW or AT_EACCESS, use stat-based checking.  */
+  struct __stat64_t64 stats;
+  if (__fstatat64_time64 (fd, file, &stats, flag & AT_SYMLINK_NOFOLLOW))
+    return -1;
+
+  mode &= (X_OK | W_OK | R_OK);	/* Clear any bogus bits. */
+
+  if (mode == F_OK)
+    return 0;			/* The file exists. */
+
+  uid_t uid = (flag & AT_EACCESS) ? __geteuid () : __getuid ();
+
+  /* The super-user can read and write any file, and execute any file
+     that anyone can execute. */
+  if (uid == 0 && ((mode & X_OK) == 0
+		   || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))
+    return 0;
+
+  int granted = (uid == stats.st_uid
+		 ? (unsigned int) (stats.st_mode & (mode << 6)) >> 6
+		 : (stats.st_gid == ((flag & AT_EACCESS)
+				     ? __getegid () : __getgid ())
+		    || __group_member (stats.st_gid))
+		 ? (unsigned int) (stats.st_mode & (mode << 3)) >> 3
+		 : (stats.st_mode & mode));
+
+  if (granted == mode)
+    return 0;
+
+  return INLINE_SYSCALL_ERROR_RETURN_VALUE (EACCES);
+}
+weak_alias (__faccessat, faccessat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fallocate.c glibc-workdir/sysdeps/unix/sysv/ironclad/fallocate.c
new file mode 100644
index 0000000..f1a4597
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fallocate.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - fallocate is provided by fallocate64.c via weak_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fallocate64.c glibc-workdir/sysdeps/unix/sysv/ironclad/fallocate64.c
new file mode 100644
index 0000000..f05ae8a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fallocate64.c
@@ -0,0 +1,50 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+
+/* Reserve storage for the data of the file associated with FD.
+   Ironclad doesn't have a fallocate syscall, so we implement it
+   using ftruncate (like mlibc does).
+
+   This implementation only supports mode=0 (default allocation).
+   Other modes (FALLOC_FL_KEEP_SIZE, etc.) are not supported.  */
+int
+fallocate64 (int fd, int mode, __off64_t offset, __off64_t len)
+{
+  /* Only mode=0 is supported (allocate space, extend file if needed).  */
+  if (mode != 0)
+    {
+      __set_errno (EOPNOTSUPP);
+      return -1;
+    }
+
+  if (offset < 0 || len <= 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Check for overflow.  */
+  __off64_t new_size = offset + len;
+  if (new_size < offset)
+    {
+      __set_errno (EFBIG);
+      return -1;
+    }
+
+  /* Get current file size.  */
+  struct stat64 st;
+  if (__fstat64 (fd, &st) < 0)
+    return -1;
+
+  /* Only extend the file if the new size is larger.  */
+  if (new_size > st.st_size)
+    return __ftruncate64 (fd, new_size);
+
+  return 0;
+}
+
+#ifdef __OFF_T_MATCHES_OFF64_T
+weak_alias (fallocate64, fallocate)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fchdir.c glibc-workdir/sysdeps/unix/sysv/ironclad/fchdir.c
new file mode 100644
index 0000000..971fb66
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fchdir.c
@@ -0,0 +1,13 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Change the current directory to FD.
+   Ironclad's chdir syscall takes a file descriptor directly.  */
+
+int
+__fchdir (int fd)
+{
+  return INLINE_SYSCALL_CALL (chdir, fd);
+}
+weak_alias (__fchdir, fchdir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fchmod.c glibc-workdir/sysdeps/unix/sysv/ironclad/fchmod.c
new file mode 100644
index 0000000..8de9958
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fchmod.c
@@ -0,0 +1,16 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+/* Change the permissions of the file referenced by FD to MODE.
+   Ironclad fchmod syscall: (fd, pathname, len, mode, flags).
+   For fchmod on an fd, pass empty path with AT_EMPTY_PATH flag.  */
+
+int
+__fchmod (int fd, mode_t mode)
+{
+  /* Ironclad requires AT_EMPTY_PATH with empty string to operate on fd.  */
+  return INLINE_SYSCALL_CALL (fchmod, fd, "", 0, mode, AT_EMPTY_PATH);
+}
+weak_alias (__fchmod, fchmod)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fchmodat.c glibc-workdir/sysdeps/unix/sysv/ironclad/fchmodat.c
new file mode 100644
index 0000000..153039d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fchmodat.c
@@ -0,0 +1,24 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+/* Change the mode of FILE relative to FD.
+   Ironclad fchmod syscall: (fd, pathname, len, mode, flags).  */
+
+int
+__fchmodat (int fd, const char *file, mode_t mode, int flag)
+{
+  if (file == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path_len first to avoid clobbering later arguments.  */
+  size_t path_len = __builtin_strlen (file);
+  /* Ironclad syscall is named 'fchmod' not 'fchmodat'.  */
+  return INLINE_SYSCALL_CALL (fchmod, fd, file, path_len, mode, flag);
+}
+weak_alias (__fchmodat, fchmodat)
+libc_hidden_def (fchmodat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fchown.c glibc-workdir/sysdeps/unix/sysv/ironclad/fchown.c
new file mode 100644
index 0000000..06c71da
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fchown.c
@@ -0,0 +1,17 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Change the owner and group of the file referenced by FD.
+   Ironclad fchown syscall: (fd, pathname, len, uid, gid, flags).
+   For fchown on an fd, pass empty path with AT_EMPTY_PATH flag.  */
+
+int
+__fchown (int fd, uid_t owner, gid_t group)
+{
+  /* Ironclad requires AT_EMPTY_PATH with empty string to operate on fd.
+     Ironclad syscall is named 'fchown' not 'fchownat'.  */
+  return INLINE_SYSCALL_CALL (fchown, fd, "", 0, owner, group, AT_EMPTY_PATH);
+}
+weak_alias (__fchown, fchown)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fchownat.c glibc-workdir/sysdeps/unix/sysv/ironclad/fchownat.c
new file mode 100644
index 0000000..765f0fb
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fchownat.c
@@ -0,0 +1,23 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Change owner and group of FILE relative to FD.
+   Ironclad fchown syscall: (fd, pathname, len, uid, gid, flags).  */
+
+int
+__fchownat (int fd, const char *file, uid_t owner, gid_t group, int flag)
+{
+  if (file == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path_len first to avoid clobbering later arguments.  */
+  size_t path_len = __builtin_strlen (file);
+  /* Ironclad syscall is named 'fchown' not 'fchownat'.  */
+  return INLINE_SYSCALL_CALL (fchown, fd, file, path_len, owner, group, flag);
+}
+weak_alias (__fchownat, fchownat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl.c glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl.c
new file mode 100644
index 0000000..a9349db
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl.c
@@ -0,0 +1,21 @@
+#include <fcntl.h>
+#include <stdarg.h>
+#include <sysdep-cancel.h>
+
+int
+__fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  if (cmd == F_SETLKW || cmd == F_SETLKW64)
+    return SYSCALL_CANCEL (fcntl, fd, cmd, arg);
+
+  return INLINE_SYSCALL_CALL (fcntl, fd, cmd, arg);
+}
+libc_hidden_def (__fcntl)
+weak_alias (__fcntl, fcntl)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl64.c glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl64.c
new file mode 100644
index 0000000..0d7d33c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl64.c
@@ -0,0 +1,35 @@
+#define fcntl __no_decl_fcntl
+#define __fcntl __no_decl___fcntl
+#include <fcntl.h>
+#undef fcntl
+#undef __fcntl
+#include <stdarg.h>
+#include <errno.h>
+#include <sysdep-cancel.h>
+
+int
+__libc_fcntl64 (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  /* For blocking lock commands, use cancellation-enabled syscall.  */
+  if (cmd == F_SETLKW || cmd == F_SETLKW64)
+    return SYSCALL_CANCEL (fcntl, fd, cmd, arg);
+
+  return __fcntl64_nocancel_adjusted (fd, cmd, arg);
+}
+libc_hidden_def (__libc_fcntl64)
+weak_alias (__libc_fcntl64, __fcntl64)
+libc_hidden_weak (__fcntl64)
+weak_alias (__libc_fcntl64, fcntl64)
+
+/* Ironclad is 64-bit only, so fcntl/fcntl64 are identical.  */
+weak_alias (__libc_fcntl64, __libc_fcntl)
+weak_alias (__libc_fcntl64, __fcntl)
+weak_alias (__libc_fcntl64, __GI___fcntl)
+weak_alias (__libc_fcntl64, fcntl)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl_nocancel.c
new file mode 100644
index 0000000..a02685d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fcntl_nocancel.c
@@ -0,0 +1,23 @@
+#include <fcntl.h>
+#include <stdarg.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+int
+__fcntl64_nocancel (int fd, int cmd, ...)
+{
+  void *arg;
+  va_list ap;
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return __fcntl64_nocancel_adjusted (fd, cmd, arg);
+}
+hidden_def (__fcntl64_nocancel)
+
+int
+__fcntl64_nocancel_adjusted (int fd, int cmd, void *arg)
+{
+  return INLINE_SYSCALL_CALL (fcntl, fd, cmd, arg);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fdatasync.c glibc-workdir/sysdeps/unix/sysv/ironclad/fdatasync.c
new file mode 100644
index 0000000..f1d4c6b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fdatasync.c
@@ -0,0 +1,11 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+/* Synchronize the data of file FD to disk.  */
+int
+fdatasync (int fd)
+{
+  /* Ironclad fsync: fd, datasync_flag (0 for fsync, 1 for fdatasync) */
+  return SYSCALL_CANCEL (fsync, fd, 1);
+}
+libc_hidden_def (fdatasync)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fdopendir.c glibc-workdir/sysdeps/unix/sysv/ironclad/fdopendir.c
new file mode 100644
index 0000000..818d952
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fdopendir.c
@@ -0,0 +1,41 @@
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include <not-cancel.h>
+
+
+DIR *
+__fdopendir (int fd)
+{
+  struct __stat64_t64 statbuf;
+
+  if (__glibc_unlikely (__fstat64_time64 (fd, &statbuf) < 0))
+    return NULL;
+  if (__glibc_unlikely (! S_ISDIR (statbuf.st_mode)))
+    {
+      __set_errno (ENOTDIR);
+      return NULL;
+    }
+
+  int flags = __fcntl64_nocancel (fd, F_GETFL);
+  if (__glibc_unlikely (flags == -1))
+    return NULL;
+  /* Fail early for descriptors opened with O_PATH.  */
+  if (__glibc_unlikely (flags & O_PATH))
+    {
+      __set_errno (EBADF);
+      return NULL;
+    }
+  /* Make sure the descriptor allows for reading.  */
+  if (__glibc_unlikely ((flags & O_ACCMODE) == O_WRONLY))
+    {
+      __set_errno (EINVAL);
+      return NULL;
+    }
+
+  return __alloc_dir (fd, false, flags, &statbuf);
+}
+weak_alias (__fdopendir, fdopendir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstat.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstat.c
new file mode 100644
index 0000000..449edcb
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstat.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - fstat is provided by fstat64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstat64.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstat64.c
new file mode 100644
index 0000000..32d29eb
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstat64.c
@@ -0,0 +1,21 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+
+int
+__fstat64 (int fd, struct stat64 *buf)
+{
+  if (fd < 0)
+    {
+      __set_errno (EBADF);
+      return -1;
+    }
+  return __fstatat64 (fd, "", buf, AT_EMPTY_PATH);
+}
+
+hidden_def (__fstat64)
+weak_alias (__fstat64, fstat64)
+
+/* Ironclad is 64-bit only, so fstat/fstat64 are identical.  */
+strong_alias (__fstat64, __fstat)
+weak_alias (__fstat64, fstat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstatat.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstatat.c
new file mode 100644
index 0000000..d8e30b7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstatat.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - fstatat is provided by fstatat64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstatat64.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstatat64.c
new file mode 100644
index 0000000..c2a73dc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstatat64.c
@@ -0,0 +1,19 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Ironclad stat syscall: (dirfd, path, path_len, statbuf, flags).  */
+int
+__fstatat64 (int fd, const char *file, struct stat64 *buf, int flag)
+{
+  size_t path_len = __builtin_strlen (file);
+  /* Ironclad syscall is named 'stat' not 'fstatat'.  */
+  return INLINE_SYSCALL_CALL (stat, fd, file, path_len, buf, flag);
+}
+
+hidden_def (__fstatat64)
+weak_alias (__fstatat64, fstatat64)
+
+/* Ironclad is 64-bit only, so fstatat/fstatat64 are identical.  */
+strong_alias (__fstatat64, __fstatat)
+weak_alias (__fstatat64, fstatat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstatfs.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstatfs.c
new file mode 100644
index 0000000..7225c2a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstatfs.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - fstatfs is provided by fstatfs64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstatfs64.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstatfs64.c
new file mode 100644
index 0000000..7b681be
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstatfs64.c
@@ -0,0 +1,19 @@
+#define __fstatfs __fstatfs_disable
+#define fstatfs fstatfs_disable
+#include <sys/statfs.h>
+#include <errno.h>
+#undef __fstatfs
+#undef fstatfs
+
+/* Ironclad doesn't have fstatfs syscall, return ENOSYS.  */
+int
+__fstatfs64 (int fd, struct statfs64 *buf)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+weak_alias (__fstatfs64, fstatfs64)
+
+/* Ironclad is 64-bit only, so fstatfs/fstatfs64 are identical.  */
+strong_alias (__fstatfs64, __fstatfs)
+weak_alias (__fstatfs64, fstatfs)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstatvfs.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstatvfs.c
new file mode 100644
index 0000000..f5d1147
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstatvfs.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - fstatvfs is provided by fstatvfs64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fstatvfs64.c glibc-workdir/sysdeps/unix/sysv/ironclad/fstatvfs64.c
new file mode 100644
index 0000000..b80a2f0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fstatvfs64.c
@@ -0,0 +1,41 @@
+/* Disable the declarations so we can define with struct statvfs64 *.  */
+#define __fstatvfs __fstatvfs_disable
+#define fstatvfs fstatvfs_disable
+#include <errno.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <kernel_stat.h>
+
+/* External declaration for statvfs64.  */
+extern int __statvfs64 (const char *file, struct statvfs64 *buf);
+
+/* Return information about the filesystem on which FD resides.
+
+   Note: Ironclad doesn't provide a direct way to get the mount point
+   from a file descriptor.  We validate that fd is valid by calling
+   fstat, then fall back to checking "/" which works for most cases
+   since "/" will match the root mount.  This matches mlibc's behavior.
+
+   A more sophisticated implementation could try to resolve the fd's
+   path through other means if needed.  */
+int
+__fstatvfs64 (int fd, struct statvfs64 *buf)
+{
+  struct stat64 st;
+
+  /* Validate the file descriptor by calling fstat.  */
+  if (__fstat64 (fd, &st) < 0)
+    return -1;
+
+  /* Use statvfs on "/" as a fallback.
+     This will return information about the root filesystem.  */
+  return __statvfs64 ("/", buf);
+}
+weak_alias (__fstatvfs64, fstatvfs64)
+
+#undef __fstatvfs
+#undef fstatvfs
+
+/* Ironclad is 64-bit only, so fstatvfs/fstatvfs64 are identical.  */
+strong_alias (__fstatvfs64, __fstatvfs)
+weak_alias (__fstatvfs64, fstatvfs)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/fsync.c glibc-workdir/sysdeps/unix/sysv/ironclad/fsync.c
new file mode 100644
index 0000000..76983bf
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/fsync.c
@@ -0,0 +1,11 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+/* Synchronize the file FD to disk.  */
+int
+fsync (int fd)
+{
+  /* Ironclad fsync: fd, datasync_flag (0 for fsync, 1 for fdatasync) */
+  return SYSCALL_CANCEL (fsync, fd, 0);
+}
+libc_hidden_def (fsync)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ftruncate.c glibc-workdir/sysdeps/unix/sysv/ironclad/ftruncate.c
new file mode 100644
index 0000000..0447f99
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ftruncate.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - ftruncate is provided by ftruncate64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ftruncate64.c glibc-workdir/sysdeps/unix/sysv/ironclad/ftruncate64.c
new file mode 100644
index 0000000..15dec11
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ftruncate64.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Truncate the file referenced by FD to LENGTH bytes.
+   Ironclad ftruncate syscall (44) takes: fd, length.  */
+int
+__ftruncate64 (int fd, off64_t length)
+{
+  return INLINE_SYSCALL_CALL (truncate, fd, length);
+}
+weak_alias (__ftruncate64, ftruncate64)
+
+/* Ironclad is 64-bit only, so ftruncate/ftruncate64 are identical.  */
+strong_alias (__ftruncate64, __ftruncate)
+weak_alias (__ftruncate64, ftruncate)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/futex-internal.c glibc-workdir/sysdeps/unix/sysv/ironclad/futex-internal.c
new file mode 100644
index 0000000..7ec5fa8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/futex-internal.c
@@ -0,0 +1,120 @@
+#include <errno.h>
+#include <stdint.h>
+#include <sysdep.h>
+#include <time.h>
+#include <futex-internal.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad futex syscall interface.
+   Syscall 69: futex(op, &item, count, &timespec)
+   - op 0b01 = wait
+   - op 0b10 = wake
+   - item = { uint64_t addr, uint32_t expected, uint32_t flags }
+
+   The struct and constants are defined in lowlevellock-futex.h.  */
+
+/* Internal helper for futex wait with absolute timeout.  */
+static int
+__futex_abstimed_wait_common (unsigned int *futex_word,
+                              unsigned int expected,
+                              clockid_t clockid,
+                              const struct __timespec64 *abstime,
+                              int private, int cancel)
+{
+  struct __ironclad_futex_item item;
+  item.addr = (uint64_t)(uintptr_t)futex_word;
+  item.expected = expected;
+  item.flags = 0;
+
+  struct __timespec64 ts;
+
+  if (abstime == NULL)
+    {
+      /* No timeout - infinite wait.  */
+      ts.tv_sec = (int64_t)-1;
+      ts.tv_nsec = (int64_t)-1;
+    }
+  else
+    {
+      /* Convert absolute time to relative time for Ironclad.
+         Ironclad expects relative timeout, not absolute.  */
+      struct __timespec64 now;
+      __clock_gettime64 (clockid, &now);
+
+      ts.tv_sec = abstime->tv_sec - now.tv_sec;
+      ts.tv_nsec = abstime->tv_nsec - now.tv_nsec;
+
+      if (ts.tv_nsec < 0)
+        {
+          ts.tv_sec--;
+          ts.tv_nsec += 1000000000;
+        }
+
+      /* Already timed out?  */
+      if (ts.tv_sec < 0)
+        return ETIMEDOUT;
+    }
+
+  (void)private;  /* Ironclad doesn't distinguish private/shared.  */
+  (void)clockid;  /* Clock already handled in timeout conversion.  */
+  (void)cancel;   /* TODO: implement cancellation support.  */
+
+  unsigned long int err;
+  long int ret = INTERNAL_SYSCALL_NCS_ERR (__IRONCLAD_NR_futex, err, 4,
+                                           IRONCLAD_FUTEX_WAIT, &item, 1, &ts);
+  (void)ret;
+
+  if (err == 0)
+    return 0;
+  else if (err == EAGAIN)
+    return EAGAIN;
+  else if (err == ETIMEDOUT)
+    return ETIMEDOUT;
+  else if (err == EINTR)
+    return EINTR;
+  else
+    return (int)err;
+}
+
+int
+__futex_abstimed_wait_cancelable64 (unsigned int *futex_word,
+                                    unsigned int expected, clockid_t clockid,
+                                    const struct __timespec64 *abstime,
+                                    int private)
+{
+  return __futex_abstimed_wait_common (futex_word, expected, clockid,
+                                       abstime, private, 1);
+}
+
+int
+__futex_abstimed_wait64 (unsigned int *futex_word, unsigned int expected,
+                         clockid_t clockid,
+                         const struct __timespec64 *abstime, int private)
+{
+  return __futex_abstimed_wait_common (futex_word, expected, clockid,
+                                       abstime, private, 0);
+}
+
+int
+__futex_lock_pi64 (int *futex_word, clockid_t clockid,
+                   const struct __timespec64 *abstime, int private)
+{
+  /* Ironclad doesn't support priority inheritance futex.  */
+  (void)futex_word;
+  (void)clockid;
+  (void)abstime;
+  (void)private;
+  return ENOSYS;
+}
+
+int
+__futex_lock_pi2 (int *futex_word, clockid_t clockid,
+                  const struct __timespec64 *abstime, int private)
+{
+  /* Ironclad doesn't support priority inheritance futex.  */
+  (void)futex_word;
+  (void)clockid;
+  (void)abstime;
+  (void)private;
+  return ENOSYS;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/futimens.c glibc-workdir/sysdeps/unix/sysv/ironclad/futimens.c
new file mode 100644
index 0000000..2f5b8a4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/futimens.c
@@ -0,0 +1,22 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <time.h>
+#include <sysdep.h>
+
+
+/* Change the access time of the file associated with FD to TSP[0] and
+   the modification time of FILE to TSP[1].
+
+   This uses Ironclad's utimes syscall with AT_EMPTY_PATH.  */
+/* Ironclad is 64-bit only, so futimens/futimens64 are identical.
+   On 64-bit systems, __futimens64 is already a macro for __futimens.  */
+int
+__futimens64 (int fd, const struct __timespec64 tsp64[2])
+{
+  if (fd < 0)
+    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EBADF);
+
+  return __utimensat64_helper (fd, NULL, &tsp64[0], 0);
+}
+weak_alias (__futimens, futimens)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getcwd.c glibc-workdir/sysdeps/unix/sysv/ironclad/getcwd.c
new file mode 100644
index 0000000..562a819
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getcwd.c
@@ -0,0 +1,21 @@
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/param.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* Get the code for the generic version.  */
+#define GETCWD_RETURN_TYPE	static char *
+#include <sysdeps/posix/getcwd.c>
+
+char *
+__getcwd (char *buf, size_t size)
+{
+  return __getcwd_generic (buf, size);
+}
+libc_hidden_def (__getcwd)
+weak_alias (__getcwd, getcwd)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getdents64.c glibc-workdir/sysdeps/unix/sysv/ironclad/getdents64.c
new file mode 100644
index 0000000..f53b963
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getdents64.c
@@ -0,0 +1,18 @@
+#include <string.h>
+#include <dirent.h>
+#include <errno.h>
+#include <limits.h>
+
+/* The kernel dirent64 structure matches 'struct dirent64'.  */
+ssize_t
+__getdents64 (int fd, void *buf, size_t nbytes)
+{
+  /* The system call takes an unsigned int argument, and some length
+     checks in the kernel use an int type.  */
+  if (nbytes > INT_MAX)
+    nbytes = INT_MAX;
+  /* Ironclad syscall is named 'getdents' not 'getdents64'.  */
+  return INLINE_SYSCALL_CALL (getdents, fd, buf, nbytes);
+}
+libc_hidden_def (__getdents64)
+weak_alias (__getdents64, getdents64)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getdomainname.c glibc-workdir/sysdeps/unix/sysv/ironclad/getdomainname.c
new file mode 100644
index 0000000..1931fb7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getdomainname.c
@@ -0,0 +1,13 @@
+/* Ironclad does not support getdomainname.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+int
+getdomainname (char *name, size_t len)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+libc_hidden_def (getdomainname)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getdtsz.c glibc-workdir/sysdeps/unix/sysv/ironclad/getdtsz.c
new file mode 100644
index 0000000..41deb99
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getdtsz.c
@@ -0,0 +1,13 @@
+/* Return the maximum number of file descriptors
+   the current process could possibly have.
+
+   Ironclad's default RLIMIT_NOFILE is unlimited (RLIM_INFINITY),
+   which overflows when cast to int.  Return 1024 directly
+   like mlibc does.  */
+int
+__getdtablesize (void)
+{
+  return 1024;
+}
+
+weak_alias (__getdtablesize, getdtablesize)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getegid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getegid.c
new file mode 100644
index 0000000..7eeab17
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getegid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+gid_t
+__getegid (void)
+{
+  return INLINE_SYSCALL_CALL (getegid);
+}
+weak_alias (__getegid, getegid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getentropy.c glibc-workdir/sysdeps/unix/sysv/ironclad/getentropy.c
new file mode 100644
index 0000000..c29569e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getentropy.c
@@ -0,0 +1,13 @@
+#include <sys/random.h>
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
+   success and -1 on failure.  */
+int
+getentropy (void *buffer, size_t length)
+{
+  return INLINE_SYSCALL_CALL (getentropy, buffer, length);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/geteuid.c glibc-workdir/sysdeps/unix/sysv/ironclad/geteuid.c
new file mode 100644
index 0000000..72f4b07
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/geteuid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+uid_t
+__geteuid (void)
+{
+  return INLINE_SYSCALL_CALL (geteuid);
+}
+weak_alias (__geteuid, geteuid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getgid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getgid.c
new file mode 100644
index 0000000..21e419c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getgid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+gid_t
+__getgid (void)
+{
+  return INLINE_SYSCALL_CALL (getgid);
+}
+weak_alias (__getgid, getgid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getgroups.c glibc-workdir/sysdeps/unix/sysv/ironclad/getgroups.c
new file mode 100644
index 0000000..7cec72f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getgroups.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+int
+__getgroups (int size, gid_t list[])
+{
+  return INLINE_SYSCALL_CALL (getgroups, size, list);
+}
+weak_alias (__getgroups, getgroups)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/gethostname.c glibc-workdir/sysdeps/unix/sysv/ironclad/gethostname.c
new file mode 100644
index 0000000..4348954
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/gethostname.c
@@ -0,0 +1,42 @@
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/utsname.h>
+
+/* Ironclad doesn't have a gethostname syscall.
+   Implement it via uname(), like mlibc does.  */
+
+int
+__gethostname (char *name, size_t len)
+{
+  struct utsname buf;
+
+  if (name == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (__uname (&buf) < 0)
+    return -1;
+
+  size_t nodename_len = strlen (buf.nodename);
+
+  if (nodename_len >= len)
+    {
+      /* POSIX says truncate and don't null-terminate if too long.
+         Some implementations return ENAMETOOLONG, but truncation
+         is more compatible.  */
+      memcpy (name, buf.nodename, len);
+      /* If len > 0, ensure null termination for safety.  */
+      if (len > 0)
+        name[len - 1] = '\0';
+    }
+  else
+    {
+      memcpy (name, buf.nodename, nodename_len + 1);
+    }
+
+  return 0;
+}
+weak_alias (__gethostname, gethostname)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getloadavg.c glibc-workdir/sysdeps/unix/sysv/ironclad/getloadavg.c
new file mode 100644
index 0000000..0bec3cd
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getloadavg.c
@@ -0,0 +1,27 @@
+#include <stdlib.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* Get load average values.  NELEM is the number of samples (1 to 3).
+   Returns number of samples read, or -1 on error.  */
+int
+getloadavg (double loadavg[], int nelem)
+{
+  if (nelem <= 0)
+    return 0;
+
+  if (nelem > 3)
+    nelem = 3;
+
+  /* Ironclad returns load averages as integers (scaled by 100) */
+  int samples[3];
+  int ret = INLINE_SYSCALL_CALL (loadavg, samples, 3);
+
+  if (ret < 0)
+    return -1;
+
+  for (int i = 0; i < nelem; i++)
+    loadavg[i] = samples[i] / 100.0;
+
+  return nelem;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getpeername.c glibc-workdir/sysdeps/unix/sysv/ironclad/getpeername.c
new file mode 100644
index 0000000..85f3f48
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getpeername.c
@@ -0,0 +1,11 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* Get the address of the peer connected to socket FD.
+   Ironclad getpeername syscall takes: fd, addr, addrlen.  */
+int
+__getpeername (int fd, struct sockaddr *addr, socklen_t *len)
+{
+  return INLINE_SYSCALL_CALL (getpeername, fd, addr, len);
+}
+weak_alias (__getpeername, getpeername)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getpgid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getpgid.c
new file mode 100644
index 0000000..0b86acc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getpgid.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+pid_t
+__getpgid (pid_t pid)
+{
+  return INLINE_SYSCALL_CALL (getpgid, pid);
+}
+libc_hidden_def (__getpgid)
+weak_alias (__getpgid, getpgid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getpgrp.c glibc-workdir/sysdeps/unix/sysv/ironclad/getpgrp.c
new file mode 100644
index 0000000..09ceb4b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getpgrp.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+/* getpgrp() is equivalent to getpgid(0).  */
+pid_t
+getpgrp (void)
+{
+  return INLINE_SYSCALL_CALL (getpgid, 0);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getpid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getpid.c
new file mode 100644
index 0000000..1b5fac8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getpid.c
@@ -0,0 +1,11 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+pid_t
+__getpid (void)
+{
+  return INLINE_SYSCALL_CALL (getpid);
+}
+libc_hidden_def (__getpid)
+weak_alias (__getpid, getpid)
+libc_hidden_def (getpid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getppid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getppid.c
new file mode 100644
index 0000000..e0b0c27
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getppid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+pid_t
+__getppid (void)
+{
+  return INLINE_SYSCALL_CALL (getppid);
+}
+weak_alias (__getppid, getppid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getpriority.c glibc-workdir/sysdeps/unix/sysv/ironclad/getpriority.c
new file mode 100644
index 0000000..d32ee2f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getpriority.c
@@ -0,0 +1,10 @@
+#include <sys/resource.h>
+#include <sysdep.h>
+
+int
+__getpriority (enum __priority_which which, id_t who)
+{
+  return INLINE_SYSCALL_CALL (getprio, which, who);
+}
+libc_hidden_def (__getpriority)
+weak_alias (__getpriority, getpriority)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getpt.c glibc-workdir/sysdeps/unix/sysv/ironclad/getpt.c
new file mode 100644
index 0000000..c1041b1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getpt.c
@@ -0,0 +1,48 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's openpty syscall returns both master and slave fds.
+   For posix_openpt, we only want the master, so we close the slave.  */
+
+int
+__posix_openpt (int oflag)
+{
+  int fds[2];
+
+  /* Ignore oflag - Ironclad openpty doesn't support flags.  */
+  (void) oflag;
+
+  int ret = INLINE_SYSCALL_CALL (openpty, fds);
+  if (ret < 0)
+    return -1;
+
+  /* Close the slave fd - posix_openpt only returns the master.  */
+  __close (fds[1]);
+
+  /* Set O_CLOEXEC if requested.  */
+  if (oflag & O_CLOEXEC)
+    __fcntl (fds[0], F_SETFD, FD_CLOEXEC);
+
+  /* Set O_NONBLOCK if requested.  */
+  if (oflag & O_NONBLOCK)
+    {
+      int flags = __fcntl (fds[0], F_GETFL);
+      if (flags >= 0)
+        __fcntl (fds[0], F_SETFL, flags | O_NONBLOCK);
+    }
+
+  return fds[0];
+}
+weak_alias (__posix_openpt, posix_openpt)
+
+/* getpt is a glibc extension that's equivalent to posix_openpt(O_RDWR).  */
+int
+__getpt (void)
+{
+  return __posix_openpt (O_RDWR);
+}
+libc_hidden_def (__getpt)
+weak_alias (__getpt, getpt)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getrandom-internal.h glibc-workdir/sysdeps/unix/sysv/ironclad/getrandom-internal.h
new file mode 100644
index 0000000..802f5d8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getrandom-internal.h
@@ -0,0 +1,15 @@
+#ifndef _GETRANDOM_INTERNAL_H
+#define _GETRANDOM_INTERNAL_H
+
+#include <pthreadP.h>
+
+/* Ironclad stub declarations - no vDSO support.
+   Implementations are in getrandom-stubs.c.  */
+
+extern void __getrandom_early_init (_Bool) attribute_hidden;
+
+extern void __getrandom_fork_subprocess (void) attribute_hidden;
+extern void __getrandom_vdso_release (struct pthread *curp) attribute_hidden;
+extern void __getrandom_reset_state (struct pthread *curp) attribute_hidden;
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getrandom.c glibc-workdir/sysdeps/unix/sysv/ironclad/getrandom.c
new file mode 100644
index 0000000..f22f305
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getrandom.c
@@ -0,0 +1,56 @@
+#include <sys/random.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <sysdep.h>
+
+void
+__getrandom_early_init (_Bool initial)
+{
+  /* Nothing to do for Ironclad.  */
+}
+
+void
+__getrandom_reset_state (struct pthread *curp)
+{
+  /* Nothing to do for Ironclad.  */
+}
+
+void
+__getrandom_vdso_release (struct pthread *curp)
+{
+  /* Nothing to do for Ironclad.  */
+}
+
+void
+__getrandom_fork_subprocess (void)
+{
+  /* Nothing to do for Ironclad.  */
+}
+
+ssize_t
+__getrandom_nocancel (void *buffer, size_t length, unsigned int flags)
+{
+  /* Ironclad uses getentropy syscall (2 args) instead of getrandom (3 args).
+     Flags are ignored since getentropy doesn't support them.  */
+  (void) flags;
+  return INLINE_SYSCALL_CALL (getentropy, buffer, length);
+}
+
+/* Write up to LENGTH bytes of randomness starting at BUFFER.
+   Return the number of bytes written, or -1 on error.  */
+ssize_t
+__getrandom (void *buffer, size_t length, unsigned int flags)
+{
+  /* Ironclad uses getentropy syscall (2 args) instead of getrandom (3 args).
+     Flags are ignored since getentropy doesn't support them.  */
+  (void) flags;
+  int ret = INLINE_SYSCALL_CALL (getentropy, buffer, length);
+  if (ret == 0) {
+    return length;
+  } else {
+    return ret;
+  }
+}
+libc_hidden_def (__getrandom)
+weak_alias (__getrandom, getrandom)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getrlimit.c glibc-workdir/sysdeps/unix/sysv/ironclad/getrlimit.c
new file mode 100644
index 0000000..33433e3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getrlimit.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - getrlimit is provided by getrlimit64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getrlimit64.c glibc-workdir/sysdeps/unix/sysv/ironclad/getrlimit64.c
new file mode 100644
index 0000000..36e7227
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getrlimit64.c
@@ -0,0 +1,32 @@
+#include <errno.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+/* Add this redirection so the strong_alias linking getrlimit64 to
+   {__}getrlimit does not throw a type error.  */
+#undef getrlimit
+#undef __getrlimit
+#define getrlimit getrlimit_redirect
+#define __getrlimit __getrlimit_redirect
+#include <sys/resource.h>
+#undef getrlimit
+#undef __getrlimit
+
+/* Put the soft and hard limits for RESOURCE in *RLIMITS.
+   Returns 0 if successful, -1 if not (and sets errno).  */
+int
+__getrlimit64 (enum __rlimit_resource resource, struct rlimit64 *rlimits)
+{
+  /* Ironclad rlimit: resource, new_limit (NULL for get), old_limit.  */
+  return INLINE_SYSCALL_CALL (rlimit, resource, NULL, rlimits);
+}
+libc_hidden_def (__getrlimit64)
+
+/* Ironclad is 64-bit only, so getrlimit/getrlimit64 are identical.  */
+strong_alias (__getrlimit64, __GI_getrlimit)
+strong_alias (__getrlimit64, __GI___getrlimit)
+strong_alias (__getrlimit64, __getrlimit)
+weak_alias (__getrlimit64, getrlimit)
+weak_alias (__getrlimit64, getrlimit64)
+libc_hidden_weak (getrlimit64)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getrusage.c glibc-workdir/sysdeps/unix/sysv/ironclad/getrusage.c
new file mode 100644
index 0000000..ad0b274
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getrusage.c
@@ -0,0 +1,53 @@
+#include <sys/resource.h>
+#include <errno.h>
+#include <string.h>
+#include <sysdep.h>
+
+/* Ironclad kernel only returns ru_utime and ru_stime (32 bytes total).
+   This struct matches what the kernel writes.  */
+struct ironclad_rusage
+{
+  struct timeval ru_utime;
+  struct timeval ru_stime;
+};
+
+/* Get resource usage for WHO.  Returns 0 on success, -1 on failure.
+
+   Note: Ironclad uses RUSAGE_SELF=1 and RUSAGE_CHILDREN=2, which are
+   defined in bits/resource.h.  No translation needed since we control
+   the headers and all packages are rebuilt.
+
+   This wrapper is needed because:
+   1. Ironclad kernel only writes ru_utime/ru_stime (32 bytes), not the
+      full struct rusage, so we use a smaller buffer.
+   2. Ironclad returns nanoseconds in tv_usec, but POSIX expects
+      microseconds, so we divide by 1000.  */
+int
+__getrusage (enum __rusage_who who, struct rusage *usage)
+{
+  if (usage == NULL)
+    {
+      __set_errno (EFAULT);
+      return -1;
+    }
+
+  /* Clear the full struct since kernel only fills first 32 bytes.  */
+  memset (usage, 0, sizeof (*usage));
+
+  /* Use a small buffer matching what the kernel actually writes.  */
+  struct ironclad_rusage krusage;
+  int ret = INLINE_SYSCALL_CALL (getrusage, who, &krusage);
+
+  if (ret == 0)
+    {
+      /* Copy and convert nanoseconds to microseconds.
+         Ironclad returns nanoseconds in tv_usec field.  */
+      usage->ru_utime.tv_sec = krusage.ru_utime.tv_sec;
+      usage->ru_utime.tv_usec = krusage.ru_utime.tv_usec / 1000;
+      usage->ru_stime.tv_sec = krusage.ru_stime.tv_sec;
+      usage->ru_stime.tv_usec = krusage.ru_stime.tv_usec / 1000;
+    }
+
+  return ret;
+}
+weak_alias (__getrusage, getrusage)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getsid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getsid.c
new file mode 100644
index 0000000..b6fe3f7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getsid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+pid_t
+getsid (pid_t pid)
+{
+  return INLINE_SYSCALL_CALL (getsid, pid);
+}
+libc_hidden_def (getsid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getsockname.c glibc-workdir/sysdeps/unix/sysv/ironclad/getsockname.c
new file mode 100644
index 0000000..6dc1dc8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getsockname.c
@@ -0,0 +1,9 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+int
+__getsockname (int fd, __SOCKADDR_ARG addr, socklen_t *len)
+{
+  return INLINE_SYSCALL_CALL (getsockname, fd, addr.__sockaddr__, len);
+}
+weak_alias (__getsockname, getsockname)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getsockopt.c glibc-workdir/sysdeps/unix/sysv/ironclad/getsockopt.c
new file mode 100644
index 0000000..553d817
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getsockopt.c
@@ -0,0 +1,12 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* Get socket options.
+   Ironclad getsockopt syscall takes: fd, level, optname, optval, optlen.  */
+int
+__getsockopt (int fd, int level, int optname,
+              void *optval, socklen_t *optlen)
+{
+  return INLINE_SYSCALL_CALL (getsockopt, fd, level, optname, optval, optlen);
+}
+weak_alias (__getsockopt, getsockopt)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getsysstats.c glibc-workdir/sysdeps/unix/sysv/ironclad/getsysstats.c
new file mode 100644
index 0000000..a0f58d8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getsysstats.c
@@ -0,0 +1,94 @@
+#include <sys/sysinfo.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <stdint.h>
+
+/* Structure matching Ironclad's cpuinfo.  */
+struct ironclad_cpuinfo
+{
+  uint64_t conf_cores;
+  uint64_t onln_cores;
+  char model_name[64];
+  char vendor_name[64];
+  uint32_t base_mhz;
+  uint32_t max_mhz;
+  uint32_t ref_mhz;
+};
+
+/* Structure matching Ironclad's meminfo.  */
+struct ironclad_meminfo
+{
+  uint64_t phys_total;
+  uint64_t phys_available;
+  uint64_t phys_free;
+  uint64_t shared_usage;
+  uint64_t kernel_usage;
+  uint64_t table_usage;
+  uint64_t poison_usage;
+};
+
+/* Return the number of processors configured.  */
+int
+__get_nprocs_conf (void)
+{
+  struct ironclad_cpuinfo cpu;
+
+  if (syscall (SYS_getcpuinfo, &cpu) == 0)
+    return (int) cpu.conf_cores;
+
+  /* Fallback to 1 if syscall fails.  */
+  return 1;
+}
+libc_hidden_def (__get_nprocs_conf)
+weak_alias (__get_nprocs_conf, get_nprocs_conf)
+
+/* Return the number of processors currently online.  */
+int
+__get_nprocs (void)
+{
+  struct ironclad_cpuinfo cpu;
+
+  if (syscall (SYS_getcpuinfo, &cpu) == 0)
+    return (int) cpu.onln_cores;
+
+  /* Fallback to 1 if syscall fails.  */
+  return 1;
+}
+libc_hidden_def (__get_nprocs)
+weak_alias (__get_nprocs, get_nprocs)
+
+/* Return the total number of physical pages.
+   Note: We use phys_available (usable RAM) rather than phys_total
+   to match mlibc behavior. phys_total includes memory reserved by
+   firmware/kernel that applications can't use.  */
+long int
+__get_phys_pages (void)
+{
+  struct ironclad_meminfo mem;
+  long int pagesize = __getpagesize ();
+
+  if (syscall (SYS_meminfo, &mem) == 0 && pagesize > 0)
+    return (long int) (mem.phys_available / pagesize);
+
+  /* Fallback if syscall fails.  */
+  return -1;
+}
+libc_hidden_def (__get_phys_pages)
+weak_alias (__get_phys_pages, get_phys_pages)
+
+/* Return the number of currently free physical pages.
+   Note: We use phys_free (currently unused RAM) to match mlibc.  */
+long int
+__get_avphys_pages (void)
+{
+  struct ironclad_meminfo mem;
+  long int pagesize = __getpagesize ();
+
+  if (syscall (SYS_meminfo, &mem) == 0 && pagesize > 0)
+    return (long int) (mem.phys_free / pagesize);
+
+  /* Fallback if syscall fails.  */
+  return -1;
+}
+libc_hidden_def (__get_avphys_pages)
+weak_alias (__get_avphys_pages, get_avphys_pages)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/gettid.c glibc-workdir/sysdeps/unix/sysv/ironclad/gettid.c
new file mode 100644
index 0000000..16fb6be
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/gettid.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+pid_t
+__gettid (void)
+{
+  return INLINE_SYSCALL_CALL (gettid);
+}
+libc_hidden_def (__gettid)
+weak_alias (__gettid, gettid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/getuid.c glibc-workdir/sysdeps/unix/sysv/ironclad/getuid.c
new file mode 100644
index 0000000..871d7d7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/getuid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+uid_t
+__getuid (void)
+{
+  return INLINE_SYSCALL_CALL (getuid);
+}
+weak_alias (__getuid, getuid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/glob64-lstat-compat.c glibc-workdir/sysdeps/unix/sysv/ironclad/glob64-lstat-compat.c
new file mode 100644
index 0000000..d3c2e3a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/glob64-lstat-compat.c
@@ -0,0 +1,28 @@
+#include <dirent.h>
+#include <glob.h>
+#include <sys/stat.h>
+#include <shlib-compat.h>
+
+#define dirent dirent64
+#define __readdir(dirp) __readdir64 (dirp)
+
+#define glob_t glob64_t
+#define __glob __glob64_lstat_compat
+#define globfree globfree64
+
+#define COMPILE_GLOB64	1
+#define struct_stat    struct stat64
+#define struct_stat64  struct stat64
+
+#define GLOB_ATTRIBUTE attribute_compat_text_section
+
+/* Avoid calling gl_lstat with GLOB_ALTDIRFUNC.  */
+#define GLOB_LSTAT   gl_stat
+#define GLOB_STAT64  __stat64
+#define GLOB_LSTAT64 __stat64
+
+#include <posix/glob.c>
+
+#if SHLIB_COMPAT(libc, GLIBC_2_1, GLIBC_2_27)
+compat_symbol (libc, __glob64_lstat_compat, glob64, GLIBC_2_1);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/glob64-time64.c glibc-workdir/sysdeps/unix/sysv/ironclad/glob64-time64.c
new file mode 100644
index 0000000..1da0313
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/glob64-time64.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - glob64_time64 is an alias to glob64.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/glob64.c glibc-workdir/sysdeps/unix/sysv/ironclad/glob64.c
new file mode 100644
index 0000000..5af5d9b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/glob64.c
@@ -0,0 +1,23 @@
+#include <dirent.h>
+#include <glob.h>
+#include <sys/stat.h>
+
+#define dirent dirent64
+#define __readdir(dirp) __readdir64 (dirp)
+
+#define glob_t glob64_t
+#define __glob __glob64
+#define globfree(pglob) globfree64 (pglob)
+
+#define COMPILE_GLOB64	1
+#define struct_stat    struct stat64
+#define struct_stat64  struct stat64
+#define GLOB_LSTAT     gl_lstat
+#define GLOB_STAT64    __stat64
+#define GLOB_LSTAT64   __lstat64
+
+#include <posix/glob.c>
+
+libc_hidden_def (__glob64)
+versioned_symbol (libc, __glob64, glob64, GLIBC_2_27);
+libc_hidden_ver (__glob64, glob64)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ifaddrs.c glibc-workdir/sysdeps/unix/sysv/ironclad/ifaddrs.c
new file mode 100644
index 0000000..d1c1473
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ifaddrs.c
@@ -0,0 +1,32 @@
+/* Ironclad ifaddrs - stub implementation.  */
+
+#include <ifaddrs.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* Create a linked list of `struct ifaddrs' structures, one for each
+   network interface on the host machine.  If successful, store the
+   list in *IFAP and return 0.  On errors, return -1 and set `errno'.  */
+int
+__getifaddrs (struct ifaddrs **ifap)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+weak_alias (__getifaddrs, getifaddrs)
+libc_hidden_def (__getifaddrs)
+libc_hidden_weak (getifaddrs)
+
+void
+__freeifaddrs (struct ifaddrs *ifa)
+{
+  while (ifa != NULL)
+    {
+      struct ifaddrs *next = ifa->ifa_next;
+      free (ifa);
+      ifa = next;
+    }
+}
+weak_alias (__freeifaddrs, freeifaddrs)
+libc_hidden_def (__freeifaddrs)
+libc_hidden_weak (freeifaddrs)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ifreq.c glibc-workdir/sysdeps/unix/sysv/ironclad/ifreq.c
new file mode 100644
index 0000000..68191ad
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ifreq.c
@@ -0,0 +1,12 @@
+/* Ironclad ifreq - stub implementation.  */
+
+#include "ifreq.h"
+
+void
+__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
+{
+  /* Ironclad doesn't support the SIOCGIFCONF ioctl.
+     Return empty result.  */
+  *num_ifs = 0;
+  *ifreqs = NULL;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/include/bits/pthread_stack_min-dynamic.h glibc-workdir/sysdeps/unix/sysv/ironclad/include/bits/pthread_stack_min-dynamic.h
new file mode 100644
index 0000000..a111f72
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/include/bits/pthread_stack_min-dynamic.h
@@ -0,0 +1,7 @@
+/* Don't define PTHREAD_STACK_MIN to __sysconf (_SC_THREAD_STACK_MIN)
+   for glibc build.  Ironclad version.  */
+#ifdef _ISOMAC
+# include <sysdeps/unix/sysv/ironclad/bits/pthread_stack_min.h>
+#else
+# include <bits/pthread_stack_min.h>
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/include/sys/shm.h glibc-workdir/sysdeps/unix/sysv/ironclad/include/sys/shm.h
new file mode 100644
index 0000000..85177a6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/include/sys/shm.h
@@ -0,0 +1,15 @@
+#ifndef _SYS_SHM_H
+#include <sysvipc/sys/shm.h>
+
+#ifndef _ISOMAC
+
+# if __TIMESIZE == 64
+#  define __shmctl64 __shmctl
+# else
+extern int __shmctl64 (int shmid, int cmd, struct __shmid64_ds *buf);
+libc_hidden_proto (__shmctl64);
+# endif
+
+#endif /* _ISOMAC  */
+
+#endif /* _SYS_SHM_H  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/internal-signals.h glibc-workdir/sysdeps/unix/sysv/ironclad/internal-signals.h
new file mode 100644
index 0000000..3f9a15c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/internal-signals.h
@@ -0,0 +1,97 @@
+#ifndef __INTERNAL_SIGNALS_H
+# define __INTERNAL_SIGNALS_H
+
+#include <internal-sigset.h>
+#include <limits.h>
+#include <signal.h>
+#include <sigsetops.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+/* The signal used for asynchronous cancelation.  */
+#define SIGCANCEL       __SIGRTMIN
+
+
+/* Signal needed for the kernel-supported POSIX timer implementation.
+   We can reuse the cancellation signal since we can distinguish
+   cancellation from timer expirations.  */
+#define SIGTIMER        SIGCANCEL
+
+
+/* Signal used to implement the setuid et.al. functions.  */
+#define SIGSETXID       (__SIGRTMIN + 1)
+
+
+/* How many signal numbers need to be reserved for libpthread's private uses
+   (SIGCANCEL and SIGSETXID).  */
+#define RESERVED_SIGRT  2
+
+
+/* Return is sig is used internally.  */
+static inline bool
+is_internal_signal (int sig)
+{
+  return (sig == SIGCANCEL) || (sig == SIGSETXID);
+}
+
+/* Remove internal glibc signal from the mask.  */
+static inline void
+clear_internal_signals (sigset_t *set)
+{
+  __sigdelset (set, SIGCANCEL);
+  __sigdelset (set, SIGSETXID);
+}
+
+static const internal_sigset_t sigall_set = {
+   .__val = {[0 ...  __NSIG_WORDS-1 ] =  -1 }
+};
+
+/* Obtain and change blocked signals, including internal glibc ones.  */
+static inline int
+internal_sigprocmask (int how, const internal_sigset_t *set,
+		      internal_sigset_t *oldset)
+{
+  /* Ironclad sigprocmask takes 3 args (no sigsetsize).  */
+  return INTERNAL_SYSCALL_CALL (sigprocmask, how, set, oldset);
+}
+
+/* Block all signals, including internal glibc ones.  */
+static inline void
+internal_signal_block_all (internal_sigset_t *oset)
+{
+  INTERNAL_SYSCALL_CALL (sigprocmask, SIG_BLOCK, &sigall_set, oset);
+}
+
+/* Restore current process signal mask.  */
+static inline void
+internal_signal_restore_set (const internal_sigset_t *set)
+{
+  INTERNAL_SYSCALL_CALL (sigprocmask, SIG_SETMASK, set, NULL);
+}
+
+static inline void
+internal_signal_unblock_signal (int sig)
+{
+  internal_sigset_t set;
+  internal_sigemptyset (&set);
+  internal_sigaddset (&set, sig);
+  INTERNAL_SYSCALL_CALL (sigprocmask, SIG_UNBLOCK, &set, NULL);
+}
+
+/* It is used on timer_create code directly on sigwaitinfo call, so it can not
+   use the internal_sigset_t definitions.  */
+static const sigset_t sigtimer_set = {
+  .__val = { [0]                      = __sigmask (SIGTIMER),
+             [1 ... _SIGSET_NWORDS-1] = 0
+  }
+};
+
+/* Unblock only SIGTIMER.  */
+static inline void
+signal_unblock_sigtimer (void)
+{
+  INTERNAL_SYSCALL_CALL (sigprocmask, SIG_UNBLOCK, &sigtimer_set, NULL);
+}
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/internal-sigset.h glibc-workdir/sysdeps/unix/sysv/ironclad/internal-sigset.h
new file mode 100644
index 0000000..9e59366
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/internal-sigset.h
@@ -0,0 +1,87 @@
+#ifndef _INTERNAL_SIGSET_H
+#define _INTERNAL_SIGSET_H
+
+#include <sigsetops.h>
+
+typedef struct _internal_sigset_t
+{
+  unsigned long int __val[__NSIG_WORDS];
+} internal_sigset_t;
+
+static inline void
+internal_sigset_from_sigset (internal_sigset_t *iset, const sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+   iset->__val[cnt] = set->__val[cnt];
+}
+
+static inline void
+internal_sigemptyset (internal_sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+   set->__val[cnt] = 0;
+}
+
+static inline void
+internal_sigfillset (internal_sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+   set->__val[cnt] = ~0UL;
+}
+
+static inline int
+internal_sigisemptyset (const internal_sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  unsigned long int ret = set->__val[--cnt];
+  while (ret == 0 && --cnt >= 0)
+    ret = set->__val[cnt];
+  return ret == 0;
+}
+
+static inline void
+internal_sigandset (internal_sigset_t *dest, const internal_sigset_t *left,
+		    const internal_sigset_t *right)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+    dest->__val[cnt] = left->__val[cnt] & right->__val[cnt];
+}
+
+static inline void
+internal_sigorset (internal_sigset_t *dest, const internal_sigset_t *left,
+		   const internal_sigset_t *right)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+    dest->__val[cnt] = left->__val[cnt] | right->__val[cnt];
+}
+
+static inline int
+internal_sigismember (const internal_sigset_t *set, int sig)
+{
+  unsigned long int mask = __sigmask (sig);
+  int word = __sigword (sig);
+  return set->__val[word] & mask ? 1 : 0;
+}
+
+static inline void
+internal_sigaddset (internal_sigset_t *set, int sig)
+{
+  unsigned long int mask = __sigmask (sig);
+  int word = __sigword (sig);
+  set->__val[word] |= mask;
+}
+
+static inline void
+internal_sigdelset (internal_sigset_t *set, int sig)
+{
+  unsigned long int mask = __sigmask (sig);
+  int word = __sigword (sig);
+  set->__val[word] &= ~mask;
+}
+
+#endif /* _INTERNAL_SIGSET_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ioctl.c glibc-workdir/sysdeps/unix/sysv/ironclad/ioctl.c
new file mode 100644
index 0000000..af789f9
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ioctl.c
@@ -0,0 +1,28 @@
+#include <stdarg.h>
+#include <sys/ioctl.h>
+#include <sysdep.h>
+
+int
+__ioctl (int fd, unsigned long int request, ...)
+{
+  va_list args;
+  va_start (args, request);
+  void *arg = va_arg (args, void *);
+  va_end (args);
+
+  /* Ironclad ioctl does not support NULL pointer arguments.
+     If the caller passes NULL, substitute a pointer to a dummy variable.  */
+  int dummy = 0;
+  if (arg == NULL)
+    arg = &dummy;
+
+  int r = INTERNAL_SYSCALL_CALL (ioctl, fd, request, arg);
+  if (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r)))
+    {
+      __set_errno (-r);
+      return -1;
+    }
+  return r;
+}
+libc_hidden_def (__ioctl)
+weak_alias (__ioctl, ioctl)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-features.h glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-features.h
new file mode 100644
index 0000000..b36b285
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-features.h
@@ -0,0 +1,82 @@
+#ifndef _IRONCLAD_KERNEL_FEATURES_H
+#define _IRONCLAD_KERNEL_FEATURES_H 1
+
+/* Ironclad supports pselect/ppoll.  */
+#define __ASSUME_PSELECT	1
+
+/* Ironclad does NOT support robust futex lists.
+   The set_robust_list syscall is not implemented.  */
+#undef __ASSUME_SET_ROBUST_LIST
+
+/* Ironclad has socket syscalls.  */
+#define __ASSUME_SENDMSG_SYSCALL	1
+#define __ASSUME_RECVMSG_SYSCALL	1
+#define __ASSUME_ACCEPT_SYSCALL		1
+#define __ASSUME_CONNECT_SYSCALL	1
+#define __ASSUME_RECVFROM_SYSCALL	1
+#define __ASSUME_SENDTO_SYSCALL		1
+#define __ASSUME_GETSOCKOPT_SYSCALL	1
+#define __ASSUME_SETSOCKOPT_SYSCALL	1
+#define __ASSUME_BIND_SYSCALL		1
+#define __ASSUME_SOCKET_SYSCALL		1
+#define __ASSUME_SOCKETPAIR_SYSCALL	1
+#define __ASSUME_LISTEN_SYSCALL		1
+#define __ASSUME_SHUTDOWN_SYSCALL	1
+#define __ASSUME_GETSOCKNAME_SYSCALL	1
+#define __ASSUME_GETPEERNAME_SYSCALL	1
+
+/* Ironclad supports SysV IPC.  */
+#define __ASSUME_DIRECT_SYSVIPC_SYSCALLS	1
+#define __ASSUME_SYSVIPC_DEFAULT_IPC_64		1
+
+/* Ironclad does not have accept4, so don't assume it.  */
+#undef __ASSUME_ACCEPT4_SYSCALL
+
+/* Ironclad does not have sendmmsg/recvmmsg.  */
+#undef __ASSUME_SENDMMSG_SYSCALL
+#undef __ASSUME_RECVMMSG_SYSCALL
+#undef __ASSUME_SENDMMSG
+#undef __ASSUME_RECVMMSG
+
+/* Ironclad does not support clone3, only fork.  */
+#undef __ASSUME_CLONE3
+
+/* Ironclad uses simple clone (fork with flags).  */
+#define __ASSUME_CLONE_DEFAULT 1
+
+/* Ironclad supports pread/pwrite.  */
+#define __ASSUME_PREADV	1
+#define __ASSUME_PWRITEV	1
+
+/* Ironclad supports madvise.  */
+#define __ASSUME_MADVISE_SYSCALL 1
+
+/* Ironclad has futex support.  */
+#define __ASSUME_FUTEX_SYSCALL 1
+
+/* PI futex extensions - Ironclad does not support these.  */
+#define __ASSUME_FUTEX_LOCK_PI2 0
+#define __ASSUME_FUTEX_LOCK_PI 0
+
+/* Time64 support - Ironclad uses 64-bit time_t.  */
+#define __ASSUME_TIME64_SYSCALLS 1
+
+/* Ironclad supports openat-style syscalls.  */
+#define __ASSUME_ATFCTS 1
+
+/* Ironclad does not have close_range syscall.  */
+#define __ASSUME_CLOSE_RANGE 0
+
+/* Statx support.  */
+#define __ASSUME_STATX 0
+
+/* Getrandom syscall.  */
+#define __ASSUME_GETRANDOM_SYSCALL 1
+
+/* mlock2 syscall.  */
+#define __ASSUME_MLOCK2 0
+
+/* copy_file_range syscall.  */
+#define __ASSUME_COPY_FILE_RANGE 0
+
+#endif /* _IRONCLAD_KERNEL_FEATURES_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-posix-cpu-timers.h glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-posix-cpu-timers.h
new file mode 100644
index 0000000..3a8f2d9
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-posix-cpu-timers.h
@@ -0,0 +1,36 @@
+/*
+  Parameters for the kernel ABI for CPU clocks, the bit fields within
+  a clockid:
+
+  - The most significant 29 bits hold either a pid or a file descriptor.
+  - Bit 2 indicates whether a cpu clock refers to a thread or a process.
+  - Bits 1 and 0 give the type: PROF=0, VIRT=1, SCHED=2, or FD=3.
+  - A clockid is invalid if bits 2, 1, and 0 are all set.
+ */
+
+#define CPUCLOCK_PID(clock)		((pid_t) ~((clock) >> 3))
+#define CPUCLOCK_PERTHREAD(clock) \
+	(((clock) & (clockid_t) CPUCLOCK_PERTHREAD_MASK) != 0)
+#define CPUCLOCK_PID_MASK	7
+#define CPUCLOCK_PERTHREAD_MASK	4
+#define CPUCLOCK_WHICH(clock)	((clock) & (clockid_t) CPUCLOCK_CLOCK_MASK)
+#define CPUCLOCK_CLOCK_MASK	3
+#define CPUCLOCK_PROF		0
+#define CPUCLOCK_VIRT		1
+#define CPUCLOCK_SCHED		2
+#define CPUCLOCK_MAX		3
+
+static inline clockid_t
+make_process_cpuclock (unsigned int pid, clockid_t clock)
+{
+  return ((~pid) << 3) | clock;
+}
+
+static inline clockid_t
+make_thread_cpuclock (unsigned int tid, clockid_t clock)
+{
+  return make_process_cpuclock (tid, clock | CPUCLOCK_PERTHREAD_MASK);
+}
+
+#define PROCESS_CLOCK  make_process_cpuclock (0, CPUCLOCK_SCHED)
+#define THREAD_CLOCK   make_thread_cpuclock (0, CPUCLOCK_SCHED)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-posix-timers.h glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-posix-timers.h
new file mode 100644
index 0000000..2a90965
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/kernel-posix-timers.h
@@ -0,0 +1,93 @@
+#include <pthread.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <sys/types.h>
+
+
+/* Nonzero if the system calls are not available.  */
+extern int __no_posix_timers attribute_hidden;
+
+/* Callback to start helper thread.  */
+extern void __timer_start_helper_thread (void) attribute_hidden;
+
+/* Control variable for helper thread creation.  */
+extern pthread_once_t __timer_helper_once attribute_hidden;
+
+/* Called from fork so that the new subprocess re-creates the
+   notification thread if necessary.  */
+void __timer_fork_subprocess (void) attribute_hidden;
+
+/* TID of the helper thread.  */
+extern pid_t __timer_helper_tid attribute_hidden;
+
+/* List of active SIGEV_THREAD timers.  */
+extern struct timer *__timer_active_sigev_thread attribute_hidden;
+
+/* Lock for __timer_active_sigev_thread.  */
+extern pthread_mutex_t __timer_active_sigev_thread_lock attribute_hidden;
+
+extern __typeof (timer_create) __timer_create;
+libc_hidden_proto (__timer_create)
+extern __typeof (timer_delete) __timer_delete;
+libc_hidden_proto (__timer_delete)
+extern __typeof (timer_getoverrun) __timer_getoverrun;
+libc_hidden_proto (__timer_getoverrun)
+
+/* Type of timers in the kernel.  */
+typedef int kernel_timer_t;
+
+/* Internal representation of SIGEV_THREAD timer.  */
+struct timer
+{
+  kernel_timer_t ktimerid;
+
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+  pthread_attr_t attr;
+
+  /* Next element in list of active SIGEV_THREAD timers.  */
+  struct timer *next;
+};
+
+
+/* For !SIGEV_THREAD, the resulting 'timer_t' is the returned kernel timer
+   identifier (kernel_timer_t), while for SIGEV_THREAD it uses the fact malloc
+   returns at least _Alignof (max_align_t) pointers plus that valid
+   kernel_timer_t are always positive to set the MSB bit of the returned
+   'timer_t' to indicate the timer handles a SIGEV_THREAD.  */
+
+static inline timer_t
+kernel_timer_to_timerid (kernel_timer_t ktimerid)
+{
+  return (timer_t) ((intptr_t) ktimerid);
+}
+
+static inline timer_t
+timer_to_timerid (struct timer *ptr)
+{
+  return (timer_t) (INTPTR_MIN | (uintptr_t) ptr >> 1);
+}
+
+static inline bool
+timer_is_sigev_thread (timer_t timerid)
+{
+  return (intptr_t) timerid < 0;
+}
+
+static inline struct timer *
+timerid_to_timer (timer_t timerid)
+{
+  return (struct timer *)((uintptr_t) timerid << 1);
+}
+
+static inline kernel_timer_t
+timerid_to_kernel_timer (timer_t timerid)
+{
+  if (timer_is_sigev_thread (timerid))
+    return timerid_to_timer (timerid)->ktimerid;
+  else
+    return (kernel_timer_t) ((uintptr_t) timerid);
+}
+
+/* Ironclad does not have old timer_t compat.  */
+#define TIMER_T_WAS_INT_COMPAT 0
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/kernel_sigaction.h glibc-workdir/sysdeps/unix/sysv/ironclad/kernel_sigaction.h
new file mode 100644
index 0000000..2d88779
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/kernel_sigaction.h
@@ -0,0 +1,24 @@
+#ifndef _KERNEL_SIGACTION_H
+#define _KERNEL_SIGACTION_H
+
+/* Ironclad sigaction structure - note the field order is different from Linux!
+   Ironclad has: handler, restorer, mask, flags
+   Linux has:    handler, flags, restorer, mask
+
+   IMPORTANT: Ironclad uses an 8-byte sigset (just a long), not glibc's
+   128-byte sigset_t struct.  We define a kernel-specific type here.  */
+
+typedef unsigned long int __kernel_sigset_t;
+
+struct kernel_sigaction
+{
+  __sighandler_t k_sa_handler;
+  void (*sa_restorer) (void);
+  __kernel_sigset_t sa_mask;    /* 8 bytes, not glibc's 128-byte sigset_t! */
+  int sa_flags;
+};
+
+/* Ironclad always uses the restorer field.  */
+#define HAS_SA_RESTORER 1
+
+#endif /* _KERNEL_SIGACTION_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/kernel_stat.h glibc-workdir/sysdeps/unix/sysv/ironclad/kernel_stat.h
new file mode 100644
index 0000000..65f3403
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/kernel_stat.h
@@ -0,0 +1,4 @@
+/* Ironclad is 64-bit only.  These macros enable 64-bit types as the default.  */
+#define XSTAT_IS_XSTAT64     1
+#define STATFS_IS_STATFS64   1
+#define STAT_IS_KERNEL_STAT  1
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/kill.c glibc-workdir/sysdeps/unix/sysv/ironclad/kill.c
new file mode 100644
index 0000000..6e4af41
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/kill.c
@@ -0,0 +1,10 @@
+#include <signal.h>
+#include <sysdep.h>
+
+int
+__kill (pid_t pid, int sig)
+{
+  return INLINE_SYSCALL_CALL (send_signal, pid, sig);
+}
+libc_hidden_def (__kill)
+weak_alias (__kill, kill)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/lchown.c glibc-workdir/sysdeps/unix/sysv/ironclad/lchown.c
new file mode 100644
index 0000000..6da7053
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/lchown.c
@@ -0,0 +1,16 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sysdep.h>
+
+/* Change the owner and group of FILE, without following symlinks.
+   Ironclad fchown syscall: (fd, pathname, len, uid, gid, flags).  */
+int
+__lchown (const char *file, uid_t owner, gid_t group)
+{
+  size_t len = strlen (file);
+  /* Ironclad syscall is named 'fchown' not 'fchownat'.  */
+  return INLINE_SYSCALL_CALL (fchown, AT_FDCWD, file, len, owner, group,
+			      AT_SYMLINK_NOFOLLOW);
+}
+weak_alias (__lchown, lchown)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ldsodefs.h glibc-workdir/sysdeps/unix/sysv/ironclad/ldsodefs.h
new file mode 100644
index 0000000..211f455
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ldsodefs.h
@@ -0,0 +1,9 @@
+#ifndef	_LDSODEFS_H
+
+/* Ironclad has the auxiliary vector.  */
+#define HAVE_AUX_VECTOR
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+#endif /* ldsodefs.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/libc_sigaction.c glibc-workdir/sysdeps/unix/sysv/ironclad/libc_sigaction.c
new file mode 100644
index 0000000..ebde1a3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/libc_sigaction.c
@@ -0,0 +1,70 @@
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <kernel_sigaction.h>
+
+/* Signal return trampoline - called by kernel when signal handler returns.
+   This function invokes rt_sigreturn to restore the original context.  */
+extern void restore_rt (void) asm ("__restore_rt") attribute_hidden;
+
+/* Ironclad always uses the restorer field.  */
+#define SET_SA_RESTORER(kact, act)  \
+  (kact)->sa_restorer = &restore_rt
+
+#define RESET_SA_RESTORER(act, kact)  \
+  (act)->sa_restorer = (kact)->sa_restorer
+
+/* If ACT is not NULL, change the action for SIG to *ACT.
+   If OACT is not NULL, put the old action for SIG in *OACT.  */
+int
+__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+  int result;
+  struct kernel_sigaction kact, koact;
+
+  if (act)
+    {
+      kact.k_sa_handler = act->sa_handler;
+      kact.sa_restorer = &restore_rt;  /* Ironclad always needs restorer */
+      /* Convert glibc's 128-byte sigset_t to kernel's 8-byte sigset.
+         Ironclad only supports ~38 signals, so first word is enough.  */
+      kact.sa_mask = act->sa_mask.__val[0];
+      kact.sa_flags = act->sa_flags;
+    }
+
+  /* Call sigaction.  Ironclad uses 3 args: signum, newact, oldact.  */
+  result = INLINE_SYSCALL_CALL (sigaction, sig,
+                                act ? &kact : NULL,
+                                oact ? &koact : NULL);
+
+  if (oact && result >= 0)
+    {
+      oact->sa_handler = koact.k_sa_handler;
+      oact->sa_restorer = koact.sa_restorer;
+      /* Convert kernel's 8-byte sigset to glibc's 128-byte sigset_t.  */
+      memset (&oact->sa_mask, 0, sizeof (oact->sa_mask));
+      oact->sa_mask.__val[0] = koact.sa_mask;
+      oact->sa_flags = koact.sa_flags;
+    }
+
+  return result;
+}
+libc_hidden_def (__libc_sigaction)
+
+/* The signal return trampoline.  When a signal handler returns,
+   the kernel jumps to sa_restorer which must invoke rt_sigreturn
+   to restore the original context.
+
+   For x86_64, rt_sigreturn is syscall 101.  */
+asm (
+   "	.text\n"
+   "	.align 16\n"
+   "	.type __restore_rt,@function\n"
+   "__restore_rt:\n"
+   "	movq $101, %rax\n"  /* SYS_signal_return (Ironclad SIGNAL_RETURN) */
+   "	syscall\n"
+   "	.size __restore_rt, .-__restore_rt\n"
+);
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/link.c glibc-workdir/sysdeps/unix/sysv/ironclad/link.c
new file mode 100644
index 0000000..a43472c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/link.c
@@ -0,0 +1,19 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Declare __linkat - defined in linkat.c.  */
+extern int __linkat (int olddirfd, const char *oldpath,
+                     int newdirfd, const char *newpath, int flags);
+
+/* Ironclad has no standalone link syscall - it uses linkat with
+   path length arguments.  Route through __linkat with AT_FDCWD
+   to get proper path length handling.  */
+
+int
+__link (const char *from, const char *to)
+{
+  return __linkat (AT_FDCWD, from, AT_FDCWD, to, 0);
+}
+
+weak_alias (__link, link)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/linkat.c glibc-workdir/sysdeps/unix/sysv/ironclad/linkat.c
new file mode 100644
index 0000000..e7f9575
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/linkat.c
@@ -0,0 +1,35 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Create a hard link at NEWPATH relative to NEWDIRFD pointing to
+   OLDPATH relative to OLDDIRFD.
+   Ironclad link syscall: (olddirfd, srcpath, src_len, newdirfd, destpath, dst_len).
+   Note: flags parameter is ignored - Ironclad doesn't support AT_SYMLINK_FOLLOW.  */
+
+int
+__linkat (int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
+	  int flags)
+{
+  if (oldpath == NULL || newpath == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Ironclad doesn't support AT_SYMLINK_FOLLOW or AT_EMPTY_PATH.  */
+  if (flags != 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path lengths first to avoid clobbering later arguments.  */
+  size_t old_len = __builtin_strlen (oldpath);
+  size_t new_len = __builtin_strlen (newpath);
+  /* Ironclad syscall is named 'link' not 'linkat'.  */
+  return INLINE_SYSCALL_CALL (link, olddirfd, oldpath, old_len,
+			      newdirfd, newpath, new_len);
+}
+weak_alias (__linkat, linkat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/linux/fb.h glibc-workdir/sysdeps/unix/sysv/ironclad/linux/fb.h
new file mode 100644
index 0000000..adf1127
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/linux/fb.h
@@ -0,0 +1,398 @@
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAX			32	/* sufficient for now */
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+#define FBIO_CURSOR            _IOWR('F', 0x08, struct fb_cursor)
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611		/* arg: 0 or vesa level + 1 */
+#define FBIOGET_VBLANK		_IOR('F', 0x12, struct fb_vblank)
+#define FBIO_ALLOC              0x4613
+#define FBIO_FREE               0x4614
+#define FBIOGET_GLYPH           0x4615
+#define FBIOGET_HWCINFO         0x4616
+#define FBIOPUT_MODEINFO        0x4617
+#define FBIOGET_DISPINFO        0x4618
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+#define FB_TYPE_VGA_PLANES		4	/* EGA/VGA planes	*/
+#define FB_TYPE_FOURCC			5	/* Type identified by a V4L2 FOURCC */
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_GROUP	8	/* 8-15: SVGA tileblit compatible modes */
+#define FB_AUX_TEXT_SVGA_MASK	7	/* lower three bits says step */
+#define FB_AUX_TEXT_SVGA_STEP2	8	/* SVGA text mode:  text, attr */
+#define FB_AUX_TEXT_SVGA_STEP4	9	/* SVGA text mode:  text, attr,  2 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP8	10	/* SVGA text mode:  text, attr,  6 reserved bytes */
+#define FB_AUX_TEXT_SVGA_STEP16	11	/* SVGA text mode:  text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_SVGA_LAST	15	/* reserved up to 15 */
+
+#define FB_AUX_VGA_PLANES_VGA4		0	/* 16 color planes (EGA/VGA) */
+#define FB_AUX_VGA_PLANES_CFB4		1	/* CFB4 in planes (VGA) */
+#define FB_AUX_VGA_PLANES_CFB8		2	/* CFB8 in planes (VGA) */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+#define FB_VISUAL_FOURCC		6	/* Visual identified by a V4L2 FOURCC */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			*/
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			*/
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			*/
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+#define FB_ACCEL_IGS_CYBER2000	33	/* CyberPro 2000		*/
+#define FB_ACCEL_IGS_CYBER2010	34	/* CyberPro 2010		*/
+#define FB_ACCEL_IGS_CYBER5000	35	/* CyberPro 5000		*/
+#define FB_ACCEL_SIS_GLAMOUR    36	/* SiS 300/630/540              */
+#define FB_ACCEL_3DLABS_PERMEDIA3 37	/* 3Dlabs Permedia 3		*/
+#define FB_ACCEL_ATI_RADEON	38	/* ATI Radeon family		*/
+#define FB_ACCEL_I810           39      /* Intel 810/815                */
+#define FB_ACCEL_SIS_GLAMOUR_2  40	/* SiS 315, 650, 740		*/
+#define FB_ACCEL_SIS_XABRE      41	/* SiS 330 ("Xabre")		*/
+#define FB_ACCEL_I830           42      /* Intel 830M/845G/85x/865G     */
+#define FB_ACCEL_NV_10          43      /* nVidia Arch 10               */
+#define FB_ACCEL_NV_20          44      /* nVidia Arch 20               */
+#define FB_ACCEL_NV_30          45      /* nVidia Arch 30               */
+#define FB_ACCEL_NV_40          46      /* nVidia Arch 40               */
+#define FB_ACCEL_XGI_VOLARI_V	47	/* XGI Volari V3XT, V5, V8      */
+#define FB_ACCEL_XGI_VOLARI_Z	48	/* XGI Volari Z7                */
+#define FB_ACCEL_OMAP1610	49	/* TI OMAP16xx                  */
+#define FB_ACCEL_TRIDENT_TGUI	50	/* Trident TGUI			*/
+#define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
+#define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
+#define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_CIRRUS_ALPINE   53	/* Cirrus Logic 543x/544x/5480	*/
+#define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
+#define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
+#define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
+#define FB_ACCEL_NEOMAGIC_NM2097 93	/* NeoMagic NM2097              */
+#define FB_ACCEL_NEOMAGIC_NM2160 94	/* NeoMagic NM2160              */
+#define FB_ACCEL_NEOMAGIC_NM2200 95	/* NeoMagic NM2200              */
+#define FB_ACCEL_NEOMAGIC_NM2230 96	/* NeoMagic NM2230              */
+#define FB_ACCEL_NEOMAGIC_NM2360 97	/* NeoMagic NM2360              */
+#define FB_ACCEL_NEOMAGIC_NM2380 98	/* NeoMagic NM2380              */
+#define FB_ACCEL_PXA3XX		 99	/* PXA3xx			*/
+
+#define FB_ACCEL_SAVAGE4        0x80	/* S3 Savage4                   */
+#define FB_ACCEL_SAVAGE3D       0x81	/* S3 Savage3D                  */
+#define FB_ACCEL_SAVAGE3D_MV    0x82	/* S3 Savage3D-MV               */
+#define FB_ACCEL_SAVAGE2000     0x83	/* S3 Savage2000                */
+#define FB_ACCEL_SAVAGE_MX_MV   0x84	/* S3 Savage/MX-MV              */
+#define FB_ACCEL_SAVAGE_MX      0x85	/* S3 Savage/MX                 */
+#define FB_ACCEL_SAVAGE_IX_MV   0x86	/* S3 Savage/IX-MV              */
+#define FB_ACCEL_SAVAGE_IX      0x87	/* S3 Savage/IX                 */
+#define FB_ACCEL_PROSAVAGE_PM   0x88	/* S3 ProSavage PM133           */
+#define FB_ACCEL_PROSAVAGE_KM   0x89	/* S3 ProSavage KM133           */
+#define FB_ACCEL_S3TWISTER_P    0x8a	/* S3 Twister                   */
+#define FB_ACCEL_S3TWISTER_K    0x8b	/* S3 TwisterK                  */
+#define FB_ACCEL_SUPERSAVAGE    0x8c    /* S3 Supersavage               */
+#define FB_ACCEL_PROSAVAGE_DDR  0x8d	/* S3 ProSavage DDR             */
+#define FB_ACCEL_PROSAVAGE_DDRK 0x8e	/* S3 ProSavage DDR-K           */
+
+#define FB_ACCEL_PUV3_UNIGFX	0xa0	/* PKUnity-v3 Unigfx		*/
+
+#define FB_CAP_FOURCC		1	/* Device supports FOURCC-based formats */
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	unsigned long smem_start;	/* Start of frame buffer mem */
+					/* (physical address) */
+	uint32_t smem_len;			/* Length of frame buffer mem */
+	uint32_t type;			/* see FB_TYPE_*		*/
+	uint32_t type_aux;			/* Interleave for interleaved Planes */
+	uint32_t visual;			/* see FB_VISUAL_*		*/
+	uint16_t xpanstep;			/* zero if no hardware panning  */
+	uint16_t ypanstep;			/* zero if no hardware panning  */
+	uint16_t ywrapstep;		/* zero if no hardware ywrap    */
+	uint32_t line_length;		/* length of a line in bytes    */
+	unsigned long mmio_start;	/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	uint32_t mmio_len;			/* Length of Memory Mapped I/O  */
+	uint32_t accel;			/* Indicate to driver which	*/
+					/*  specific chip/card we have	*/
+	uint16_t capabilities;		/* see FB_CAP_*			*/
+	uint16_t reserved[2];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified.
+ *
+ * For pseudocolor: offset and length should be the same for all color
+ * components. Offset specifies the position of the least significant bit
+ * of the palette index in a pixel value. Length indicates the number
+ * of available palette entries (i.e. # of entries = 1 << length).
+ */
+struct fb_bitfield {
+	uint32_t offset;			/* beginning of bitfield	*/
+	uint32_t length;			/* length of bitfield		*/
+	uint32_t msb_right;		/* != 0 : Most significant bit is */
+					/* right */
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+#define FB_NONSTD_REV_PIX_IN_B	2	/* order of pixels in each byte is reversed */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+#define FB_ACTIVATE_FORCE     128	/* force apply even when no change*/
+#define FB_ACTIVATE_INV_MODE  256       /* invalidate videomode */
+#define FB_ACTIVATE_KD_TEXT   512       /* for KDSET vt ioctl */
+
+#define FB_ACCELF_TEXT		1	/* (OBSOLETE) see fb_info.flags and vc_mode */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_ODD_FLD_FIRST	4	/* interlaced: top line first */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+/*
+ * Display rotation support
+ */
+#define FB_ROTATE_UR      0
+#define FB_ROTATE_CW      1
+#define FB_ROTATE_UD      2
+#define FB_ROTATE_CCW     3
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+struct fb_var_screeninfo {
+	uint32_t xres;			/* visible resolution		*/
+	uint32_t yres;
+	uint32_t xres_virtual;		/* virtual resolution		*/
+	uint32_t yres_virtual;
+	uint32_t xoffset;			/* offset from virtual to visible */
+	uint32_t yoffset;			/* resolution			*/
+
+	uint32_t bits_per_pixel;		/* guess what			*/
+	uint32_t grayscale;		/* 0 = color, 1 = grayscale,	*/
+					/* >1 = FOURCC			*/
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/
+
+	uint32_t nonstd;			/* != 0 Non standard pixel format */
+
+	uint32_t activate;			/* see FB_ACTIVATE_*		*/
+
+	uint32_t height;			/* height of picture in mm    */
+	uint32_t width;			/* width of picture in mm     */
+
+	uint32_t accel_flags;		/* (OBSOLETE) see fb_info.flags */
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	uint32_t pixclock;			/* pixel clock in ps (pico seconds) */
+	uint32_t left_margin;		/* time from sync to picture	*/
+	uint32_t right_margin;		/* time from picture to sync	*/
+	uint32_t upper_margin;		/* time from sync to picture	*/
+	uint32_t lower_margin;
+	uint32_t hsync_len;		/* length of horizontal sync	*/
+	uint32_t vsync_len;		/* length of vertical sync	*/
+	uint32_t sync;			/* see FB_SYNC_*		*/
+	uint32_t vmode;			/* see FB_VMODE_*		*/
+	uint32_t rotate;			/* angle we rotate counter clockwise */
+	uint32_t colorspace;		/* colorspace for FOURCC-based modes */
+	uint32_t reserved[4];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	uint32_t start;			/* First entry	*/
+	uint32_t len;			/* Number of entries */
+	uint16_t *red;			/* Red values	*/
+	uint16_t *green;
+	uint16_t *blue;
+	uint16_t *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	uint32_t console;
+	uint32_t framebuffer;
+};
+
+/* VESA Blanking Levels */
+#define VESA_NO_BLANKING        0
+#define VESA_VSYNC_SUSPEND      1
+#define VESA_HSYNC_SUSPEND      2
+#define VESA_POWERDOWN          3
+
+
+enum {
+	/* screen: unblanked, hsync: on,  vsync: on */
+	FB_BLANK_UNBLANK       = VESA_NO_BLANKING,
+
+	/* screen: blanked,   hsync: on,  vsync: on */
+	FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1,
+
+	/* screen: blanked,   hsync: on,  vsync: off */
+	FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: on */
+	FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1,
+
+	/* screen: blanked,   hsync: off, vsync: off */
+	FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1
+};
+
+#define FB_VBLANK_VBLANKING	0x001	/* currently in a vertical blank */
+#define FB_VBLANK_HBLANKING	0x002	/* currently in a horizontal blank */
+#define FB_VBLANK_HAVE_VBLANK	0x004	/* vertical blanks can be detected */
+#define FB_VBLANK_HAVE_HBLANK	0x008	/* horizontal blanks can be detected */
+#define FB_VBLANK_HAVE_COUNT	0x010	/* global retrace counter is available */
+#define FB_VBLANK_HAVE_VCOUNT	0x020	/* the vcount field is valid */
+#define FB_VBLANK_HAVE_HCOUNT	0x040	/* the hcount field is valid */
+#define FB_VBLANK_VSYNCING	0x080	/* currently in a vsync */
+#define FB_VBLANK_HAVE_VSYNC	0x100	/* verical syncs can be detected */
+
+struct fb_vblank {
+	uint32_t flags;			/* FB_VBLANK flags */
+	uint32_t count;			/* counter of retraces since boot */
+	uint32_t vcount;			/* current scanline position */
+	uint32_t hcount;			/* current scandot position */
+	uint32_t reserved[4];		/* reserved for future compatibility */
+};
+
+/* Internal HW accel */
+#define ROP_COPY 0
+#define ROP_XOR  1
+
+struct fb_copyarea {
+	uint32_t dx;
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t sx;
+	uint32_t sy;
+};
+
+struct fb_fillrect {
+	uint32_t dx;	/* screen-relative */
+	uint32_t dy;
+	uint32_t width;
+	uint32_t height;
+	uint32_t color;
+	uint32_t rop;
+};
+
+struct fb_image {
+	uint32_t dx;		/* Where to place image */
+	uint32_t dy;
+	uint32_t width;		/* Size of image */
+	uint32_t height;
+	uint32_t fg_color;		/* Only used when a mono bitmap */
+	uint32_t bg_color;
+	uint8_t  depth;		/* Depth of the image */
+	const char *data;	/* Pointer to image data */
+	struct fb_cmap cmap;	/* color map info */
+};
+
+/*
+ * hardware cursor control
+ */
+
+#define FB_CUR_SETIMAGE 0x01
+#define FB_CUR_SETPOS   0x02
+#define FB_CUR_SETHOT   0x04
+#define FB_CUR_SETCMAP  0x08
+#define FB_CUR_SETSHAPE 0x10
+#define FB_CUR_SETSIZE	0x20
+#define FB_CUR_SETALL   0xFF
+
+struct fbcurpos {
+	uint16_t x, y;
+};
+
+struct fb_cursor {
+	uint16_t set;		/* what to set */
+	uint16_t enable;		/* cursor on/off */
+	uint16_t rop;		/* bitop operation */
+	const char *mask;	/* cursor mask bits */
+	struct fbcurpos hot;	/* cursor hot spot */
+	struct fb_image	image;	/* Cursor image */
+};
+
+/* Settings for the generic backlight code */
+#define FB_BACKLIGHT_LEVELS	128
+#define FB_BACKLIGHT_MAX	0xFF
+
+
+#endif /* _LINUX_FB_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/listen.c glibc-workdir/sysdeps/unix/sysv/ironclad/listen.c
new file mode 100644
index 0000000..6f38c83
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/listen.c
@@ -0,0 +1,9 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+int
+__listen (int fd, int backlog)
+{
+  return INLINE_SYSCALL_CALL (listen, fd, backlog);
+}
+weak_alias (__listen, listen)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/login_tty.c glibc-workdir/sysdeps/unix/sysv/ironclad/login_tty.c
new file mode 100644
index 0000000..756ca16
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/login_tty.c
@@ -0,0 +1,51 @@
+/* Ironclad login_tty implementation.  */
+
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <utmp.h>
+#include <shlib-compat.h>
+
+int
+__login_tty (int fd)
+{
+  __setsid();
+
+#ifdef TIOCSCTTY
+  if (__ioctl(fd, TIOCSCTTY, NULL) == -1)
+    return (-1);
+#else
+  {
+    /* This might work.  */
+    char *fdname = ttyname (fd);
+    int newfd;
+    if (fdname)
+      {
+        if (fd != 0)
+          __close (0);
+        if (fd != 1)
+          __close (1);
+        if (fd != 2)
+          __close (2);
+        newfd = __open64 (fdname, O_RDWR);
+        __close (newfd);
+      }
+  }
+#endif
+  while (__dup2(fd, 0) == -1 && errno == EBUSY)
+    ;
+  while (__dup2(fd, 1) == -1 && errno == EBUSY)
+    ;
+  while (__dup2(fd, 2) == -1 && errno == EBUSY)
+    ;
+  if (fd > 2)
+    __close(fd);
+  return (0);
+}
+versioned_symbol (libc, __login_tty, login_tty, GLIBC_2_34);
+libc_hidden_ver (__login_tty, login_tty)
+
+#if OTHER_SHLIB_COMPAT (libutil, GLIBC_2_0, GLIBC_2_34)
+compat_symbol (libutil, __login_tty, login_tty, GLIBC_2_0);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/lowlevellock-futex.h glibc-workdir/sysdeps/unix/sysv/ironclad/lowlevellock-futex.h
new file mode 100644
index 0000000..bae25d6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/lowlevellock-futex.h
@@ -0,0 +1,179 @@
+#ifndef _LOWLEVELLOCK_FUTEX_H
+#define _LOWLEVELLOCK_FUTEX_H   1
+
+#ifndef __ASSEMBLER__
+# include <sysdep.h>
+# include <stdint.h>
+# include <errno.h>
+#endif
+
+/* Ironclad futex operations - different from Linux!  */
+#define IRONCLAD_FUTEX_WAIT  0b01
+#define IRONCLAD_FUTEX_WAKE  0b10
+
+/* Ironclad futex syscall number.  */
+#define __IRONCLAD_NR_futex  69
+
+/* Linux-compatible futex operation codes (for compatibility macros).  */
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_WAIT_REQUEUE_PI   11
+#define FUTEX_CMP_REQUEUE_PI    12
+#define FUTEX_LOCK_PI2		13
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+#ifndef __ASSEMBLER__
+
+/* Ironclad futex_item structure - must match kernel expectations.
+   From mlibc sysdeps/ironclad/generic/generic.cpp.  */
+struct __ironclad_futex_item {
+    uint64_t addr;
+    uint32_t expected;
+    uint32_t flags;
+};
+
+# define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+
+/* Ironclad futex wait - translates Linux-style to Ironclad ABI.
+   Linux: futex(uaddr, FUTEX_WAIT, val, timeout, ...)
+   Ironclad: futex(0b01, &item, 1, &timeout) where item = {addr, expected, flags}
+
+   Syscall 69: futex(op, &item, count, &timespec)
+   - op 0b01 = wait (block until *addr != expected or timeout)
+   - op 0b10 = wake (wake up waiters)
+
+   Note: We use inline assembly directly here instead of INTERNAL_SYSCALL_NCS_ERR
+   because this header is included very early (from tls.h) before the syscall
+   macros are available. This matches the include order issue where sysdep.h
+   includes tls.h before defining the syscall macros.  */
+static inline int
+__lll_futex_wait (int *futexp, int val, const struct __timespec64 *timeout)
+{
+  struct __ironclad_futex_item item;
+  item.addr = (uint64_t)(uintptr_t)futexp;
+  item.expected = (uint32_t)val;
+  item.flags = 0;
+
+  struct __timespec64 ts;
+  if (timeout == NULL)
+    {
+      /* No timeout - use -1,-1 to indicate infinite wait.  */
+      ts.tv_sec = (int64_t)-1;
+      ts.tv_nsec = (int64_t)-1;
+    }
+  else
+    {
+      ts = *timeout;
+    }
+
+  /* Direct inline syscall - Ironclad uses r12 for arg4, not r10.  */
+  unsigned long int resultvar;
+  unsigned long int err;
+  register long int _a4 asm ("r12") = (long int) &ts;
+  asm volatile (
+    "syscall\n\t"
+    : "=a" (resultvar), "=d" (err)
+    : "a" ((long int) __IRONCLAD_NR_futex),
+      "D" ((long int) IRONCLAD_FUTEX_WAIT),
+      "S" ((long int) &item),
+      "d" ((long int) 1),
+      "r" (_a4)
+    : "memory", "cc", "rcx", "r11");
+
+  if (err != 0)
+    return -(int)err;
+  (void)resultvar;
+  return 0;
+}
+
+/* Ironclad futex wake.  */
+static inline int
+__lll_futex_wake (int *futexp, int nr)
+{
+  struct __ironclad_futex_item item;
+  item.addr = (uint64_t)(uintptr_t)futexp;
+  item.expected = 0;  /* Not used for wake.  */
+  item.flags = 0;
+
+  struct __timespec64 ts;
+  ts.tv_sec = (int64_t)-1;
+  ts.tv_nsec = (int64_t)-1;
+
+  /* Note: Ironclad futex wake doesn't have a "nr" parameter in the item.
+     It wakes all waiters on that address. The nr parameter is ignored.  */
+  (void)nr;
+
+  /* Direct inline syscall - Ironclad uses r12 for arg4, not r10.  */
+  unsigned long int resultvar;
+  unsigned long int err;
+  register long int _a4 asm ("r12") = (long int) &ts;
+  asm volatile (
+    "syscall\n\t"
+    : "=a" (resultvar), "=d" (err)
+    : "a" ((long int) __IRONCLAD_NR_futex),
+      "D" ((long int) IRONCLAD_FUTEX_WAKE),
+      "S" ((long int) &item),
+      "d" ((long int) 1),
+      "r" (_a4)
+    : "memory", "cc", "rcx", "r11");
+
+  if (err != 0)
+    return -(int)err;
+  (void)resultvar;
+  return 0;
+}
+
+/* Wait while *FUTEXP == VAL for an lll_futex_wake call on FUTEXP.  */
+# define lll_futex_wait(futexp, val, private) \
+  __lll_futex_wait ((int *)(futexp), (val), NULL)
+
+# define lll_futex_timed_wait(futexp, val, timeout, private)     \
+  __lll_futex_wait ((int *)(futexp), (val), (timeout))
+
+/* Verify whether the supplied clockid is supported by
+   lll_futex_clock_wait_bitset.  */
+# define lll_futex_supported_clockid(clockid)			\
+  ((clockid) == CLOCK_REALTIME || (clockid) == CLOCK_MONOTONIC)
+
+/* Wake up up to NR waiters on FUTEXP.  */
+# define lll_futex_wake(futexp, nr, private)                             \
+  __lll_futex_wake ((int *)(futexp), (nr))
+
+/* Ironclad doesn't support complex futex operations like requeue or PI.
+   These return -ENOSYS.  */
+# define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  (-ENOSYS)
+
+# define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  (-ENOSYS)
+
+# define lll_futex_timed_unlock_pi(futexp, private) \
+  (-ENOSYS)
+
+/* For timed waits with specific clock.  */
+# define lll_futex_timed_wait_bitset(futexp, val, timeout, clockbit, private) \
+  __lll_futex_wait ((int *)(futexp), (val), (timeout))
+
+/* Clock-based wait.  */
+# define lll_futex_clock_wait_bitset(futexp, val, clockid, timeout, private) \
+  __lll_futex_wait ((int *)(futexp), (val), (timeout))
+
+#endif  /* !__ASSEMBLER__ */
+#endif  /* lowlevellock-futex.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/lseek.c glibc-workdir/sysdeps/unix/sysv/ironclad/lseek.c
new file mode 100644
index 0000000..ecf097d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/lseek.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - lseek is provided by lseek64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/lseek64.c glibc-workdir/sysdeps/unix/sysv/ironclad/lseek64.c
new file mode 100644
index 0000000..677e647
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/lseek64.c
@@ -0,0 +1,29 @@
+#include <unistd.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+/* Ironclad lseek syscall.  SEEK_* values are defined in bits/seek_whence.h
+   with Ironclad-native values (SEEK_SET=1, SEEK_CUR=2, SEEK_END=4).  */
+off64_t
+__lseek64 (int fd, off64_t offset, int whence)
+{
+  /* Ironclad syscall is named 'seek' not 'lseek'.  */
+  return INLINE_SYSCALL_CALL (seek, fd, offset, whence);
+}
+
+strong_alias (__lseek64, __libc_lseek64)
+weak_alias (__lseek64, lseek64)
+
+/* Ironclad is 64-bit only, so lseek/lseek64 are identical.  */
+weak_alias (__lseek64, lseek)
+weak_alias (__lseek64, __lseek)
+strong_alias (__lseek64, __libc_lseek)
+libc_hidden_def (__lseek)
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_28)
+compat_symbol (libc, __lseek64, llseek, GLIBC_2_0);
+#endif
+
+#if !IS_IN(rtld) && OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_1, GLIBC_2_2)
+compat_symbol (libc, __lseek64, lseek64, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/lstat.c glibc-workdir/sysdeps/unix/sysv/ironclad/lstat.c
new file mode 100644
index 0000000..16e9fe3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/lstat.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - lstat is provided by lstat64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/lstat64.c glibc-workdir/sysdeps/unix/sysv/ironclad/lstat64.c
new file mode 100644
index 0000000..1380301
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/lstat64.c
@@ -0,0 +1,14 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+
+int
+__lstat64 (const char *file, struct stat64 *buf)
+{
+  return __fstatat64 (AT_FDCWD, file, buf, AT_SYMLINK_NOFOLLOW);
+}
+hidden_def (__lstat64)
+weak_alias (__lstat64, lstat64)
+
+/* Ironclad is 64-bit only, so lstat/lstat64 are identical.  */
+strong_alias (__lstat64, __lstat)
+weak_alias (__lstat64, lstat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mac.c glibc-workdir/sysdeps/unix/sysv/ironclad/mac.c
new file mode 100644
index 0000000..e6f5b71
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mac.c
@@ -0,0 +1,33 @@
+#include <errno.h>
+#include <string.h>
+#include <sys/mac.h>
+#include <sysdep.h>
+
+/* Get the MAC capabilities of the current process.  */
+unsigned long
+get_mac_capabilities (void)
+{
+  return INLINE_SYSCALL_CALL (get_mac_capabilities);
+}
+
+/* Set the MAC capabilities of the current process.  */
+int
+set_mac_capabilities (unsigned long caps)
+{
+  return INLINE_SYSCALL_CALL (set_mac_capabilities, caps);
+}
+
+/* Add MAC permissions for a specific path.  */
+int
+add_mac_permissions (const char *path, int flags)
+{
+  size_t len = strlen (path);
+  return INLINE_SYSCALL_CALL (add_mac_permissions, path, len, flags);
+}
+
+/* Set the MAC enforcement mode.  */
+int
+set_mac_enforcement (unsigned long enforcement)
+{
+  return INLINE_SYSCALL_CALL (set_mac_enforcement, enforcement);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/machine-sp.h glibc-workdir/sysdeps/unix/sysv/ironclad/machine-sp.h
new file mode 100644
index 0000000..2c73850
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/machine-sp.h
@@ -0,0 +1,11 @@
+#ifndef _MACHINE_SP_H
+#define _MACHINE_SP_H
+
+/* Return the current stack pointer.  */
+static inline uintptr_t
+__thread_stack_pointer (void)
+{
+  return (uintptr_t) CURRENT_STACK_FRAME;
+}
+
+#endif	/* machine-sp.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/madvise.c glibc-workdir/sysdeps/unix/sysv/ironclad/madvise.c
new file mode 100644
index 0000000..61ec9f4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/madvise.c
@@ -0,0 +1,13 @@
+#include <sys/mman.h>
+#include <sysdep.h>
+
+/* On Ironclad, MADV_* and POSIX_MADV_* have the same values,
+   so no translation is needed.  */
+
+int
+__madvise (void *addr, size_t len, int advice)
+{
+  return INLINE_SYSCALL_CALL (madvise, addr, len, advice);
+}
+libc_hidden_def (__madvise)
+weak_alias (__madvise, madvise)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mkdir.c glibc-workdir/sysdeps/unix/sysv/ironclad/mkdir.c
new file mode 100644
index 0000000..3d82299
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mkdir.c
@@ -0,0 +1,15 @@
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+/* Ironclad has no mkdir syscall - use mkdirat with AT_FDCWD.
+   Following mlibc: sys_mkdir -> sys_mkdirat(AT_FDCWD, path, mode)  */
+
+int
+__mkdir (const char *path, mode_t mode)
+{
+  return __mkdirat (AT_FDCWD, path, mode);
+}
+
+libc_hidden_def (__mkdir)
+weak_alias (__mkdir, mkdir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mkdirat.c glibc-workdir/sysdeps/unix/sysv/ironclad/mkdirat.c
new file mode 100644
index 0000000..00fad16
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mkdirat.c
@@ -0,0 +1,13 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+/* Ironclad has no mkdirat syscall - use mknodat with S_IFDIR.
+   Following mlibc: sys_mkdirat -> sys_mknodat(dirfd, path, S_IFDIR | mode, 0)  */
+
+int
+__mkdirat (int fd, const char *path, mode_t mode)
+{
+  return __mknodat (fd, path, S_IFDIR | mode, 0);
+}
+weak_alias (__mkdirat, mkdirat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mknodat.c glibc-workdir/sysdeps/unix/sysv/ironclad/mknodat.c
new file mode 100644
index 0000000..912b751
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mknodat.c
@@ -0,0 +1,16 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <sysdep.h>
+
+int
+__mknodat (int fd, const char *path, mode_t mode, dev_t dev)
+{
+  /* Ironclad makenode syscall: (dirfd, path, path_len, mode, dev).
+     Compute path_len first to avoid clobbering later arguments.  */
+  size_t path_len = __builtin_strlen (path);
+  /* Ironclad syscall is named 'makenode' not 'mknodat'.  */
+  return INLINE_SYSCALL_CALL (makenode, fd, path, path_len, mode, dev);
+}
+libc_hidden_def (__mknodat)
+weak_alias (__mknodat, mknodat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mmap.c glibc-workdir/sysdeps/unix/sysv/ironclad/mmap.c
new file mode 100644
index 0000000..6debc59
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mmap.c
@@ -0,0 +1,14 @@
+/* Ironclad is 64-bit only.  This file provides the mmap wrapper that
+   calls __mmap64.  Shadows the generic misc/mmap.c stub.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+void *
+__mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset)
+{
+  return __mmap64 (addr, len, prot, flags, fd, (off64_t) offset);
+}
+weak_alias (__mmap, mmap)
+libc_hidden_def (__mmap)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mmap64.c glibc-workdir/sysdeps/unix/sysv/ironclad/mmap64.c
new file mode 100644
index 0000000..27a6186
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mmap64.c
@@ -0,0 +1,154 @@
+/* Ironclad does not support file-backed mmap for regular files.  When mmap
+   is called with a file descriptor (non-anonymous mapping), we:
+   1. First try kernel mmap directly - this works for device files
+   2. If that fails, fall back to emulation (alloc anon + read file contents)
+
+   This implementation uses raw syscalls so it works in the dynamic linker
+   (rtld) context before libc is fully initialized.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sysdep.h>
+
+/* Ironclad read syscall has 5 args: (fd, buf, count, offset, flag)
+   flag=0 for normal read, flag=1 for pread behavior.  */
+static ssize_t
+mmap_pread (int fd, void *buf, size_t count, off64_t offset)
+{
+  unsigned long int sc_err;
+  ssize_t ret;
+
+  /* Use Ironclad's read syscall with flag=1 for pread behavior.  */
+  ret = INTERNAL_SYSCALL_NCS_ERR (SYS_read, sc_err, 5,
+				  fd, buf, count, offset, 1);
+  if (sc_err != 0)
+    return -(long)sc_err;  /* Return negative errno on error.  */
+  return ret;
+}
+
+void *
+__mmap64 (void *addr, size_t len, int prot, int flags, int fd, off64_t offset)
+{
+  unsigned long int sc_err;
+  void *result;
+
+  /* Check if this is a file-backed mapping request (not anonymous).
+     Ironclad doesn't support file-backed mmap for regular files, but it
+     DOES support mmap for device files (framebuffer, etc.).
+
+     Strategy: Try the kernel mmap first. If it succeeds (device file),
+     great. If it fails, fall back to emulation (regular file).
+
+     IMPORTANT: For MAP_SHARED with write permissions on regular files,
+     we MUST fail because our emulation is read-only - writes would be
+     lost on munmap. This forces programs like BFD/binutils to use their
+     fallback write()-based I/O path.  */
+  if (fd >= 0 && !(flags & MAP_ANONYMOUS))
+    {
+      /* First, try passing directly to the kernel - this works for devices. */
+      int clean_flags = flags & (MAP_PRIVATE | MAP_SHARED | MAP_FIXED |
+				 MAP_ANONYMOUS | MAP_NORESERVE);
+      result = (void *) INTERNAL_SYSCALL_NCS_ERR (SYS_mmap, sc_err, 6,
+						  addr, len, prot, clean_flags,
+						  fd, offset);
+      if (sc_err == 0)
+	return result;
+
+      /* Kernel mmap failed - this is a regular file mapping.
+         Ironclad doesn't support this natively.
+
+         For MAP_SHARED with write permissions, we cannot safely emulate
+         because writes would not be persisted to the file. Return an error
+         to force the caller to use write()-based I/O instead.  */
+      if ((flags & MAP_SHARED) && (prot & PROT_WRITE))
+	{
+	  __set_errno (ENOTSUP);
+	  return MAP_FAILED;
+	}
+
+      /* For read-only or MAP_PRIVATE mappings, we can emulate by:
+         1. Allocating anonymous memory with READ|WRITE to copy data in
+         2. Reading the file contents
+         3. Trying to mprotect to the requested permissions  */
+      int anon_flags = MAP_ANONYMOUS | MAP_PRIVATE;
+      if (flags & MAP_FIXED)
+	anon_flags |= MAP_FIXED;
+
+      /* Allocate with READ|WRITE to allow copying data in.  */
+      result = (void *) INTERNAL_SYSCALL_NCS_ERR (SYS_mmap, sc_err, 6,
+						  addr, len,
+						  PROT_READ | PROT_WRITE,
+						  anon_flags, 0, 0);
+
+      if (sc_err != 0)
+	{
+	  __set_errno (sc_err);
+	  return MAP_FAILED;
+	}
+
+      /* Read the file contents into the allocated memory.  */
+      if (len > 0)
+	{
+	  size_t total_read = 0;
+	  char *buf = (char *) result;
+
+	  while (total_read < len)
+	    {
+	      ssize_t nread = mmap_pread (fd, buf + total_read,
+					  len - total_read,
+					  offset + total_read);
+	      if (nread < 0)
+		{
+		  /* Read failed, unmap the memory and return error.  */
+		  INTERNAL_SYSCALL_NCS_ERR (SYS_munmap, sc_err, 2, result, len);
+		  __set_errno (-nread);
+		  return MAP_FAILED;
+		}
+	      if (nread == 0)
+		{
+		  /* End of file - zero the rest.  */
+		  memset (buf + total_read, 0, len - total_read);
+		  break;
+		}
+	      total_read += nread;
+	    }
+	}
+
+      /* Try to set the requested protection.  This may fail on Ironclad
+         if W^X enforcement prevents transitioning from WRITE to EXEC.
+         If mprotect fails, we continue anyway - caller may handle it.  */
+      if (prot != (PROT_READ | PROT_WRITE))
+	{
+	  __mprotect (result, len, prot);
+	  /* Ignore mprotect errors - W^X may prevent this.  */
+	}
+
+      return result;
+    }
+
+  /* Anonymous mapping or other case - pass through to kernel.
+     Strip flags that Ironclad might not understand.  */
+  int clean_flags = flags & (MAP_PRIVATE | MAP_SHARED | MAP_FIXED |
+			     MAP_ANONYMOUS | MAP_NORESERVE);
+
+  result = (void *) INTERNAL_SYSCALL_NCS_ERR (SYS_mmap, sc_err, 6,
+					      addr, len, prot, clean_flags,
+					      (flags & MAP_ANONYMOUS) ? 0 : fd,
+					      offset);
+
+  if (sc_err != 0)
+    {
+      __set_errno (sc_err);
+      return MAP_FAILED;
+    }
+
+  return result;
+}
+
+weak_alias (__mmap64, mmap64)
+libc_hidden_def (__mmap64)
+
+/* Note: __mmap and mmap are defined in mmap.c to avoid conflicts
+   with the generic misc/mmap.c stub.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mount.c glibc-workdir/sysdeps/unix/sysv/ironclad/mount.c
new file mode 100644
index 0000000..e3afac2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mount.c
@@ -0,0 +1,15 @@
+#include <errno.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sysdep.h>
+
+/* Ironclad native mount interface.
+   Kernel syscall takes: source, source_len, target, target_len, type, flags.  */
+int
+mount (const char *source, const char *target, int type, int flags)
+{
+  size_t source_len = source ? strlen (source) : 0;
+  size_t target_len = strlen (target);
+  return INLINE_SYSCALL_CALL (mount, source, source_len, target, target_len,
+                              type, flags);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mprotect.c glibc-workdir/sysdeps/unix/sysv/ironclad/mprotect.c
new file mode 100644
index 0000000..92dfe97
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mprotect.c
@@ -0,0 +1,19 @@
+#include <sys/mman.h>
+#include <sysdep.h>
+#include <unistd.h>
+
+/* Ironclad requires length to be page-aligned, so we round up.  */
+
+int
+__mprotect (void *addr, size_t len, int prot)
+{
+  /* Round len up to page boundary.  */
+  size_t page_size = __getpagesize ();
+  size_t aligned_len = len;
+  if (len % page_size != 0)
+    aligned_len = len + page_size - (len % page_size);
+
+  return INLINE_SYSCALL_CALL (mprotect, addr, aligned_len, prot);
+}
+libc_hidden_def (__mprotect)
+weak_alias (__mprotect, mprotect)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mq_notify.c glibc-workdir/sysdeps/unix/sysv/ironclad/mq_notify.c
new file mode 100644
index 0000000..4b5d920
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mq_notify.c
@@ -0,0 +1,10 @@
+#include <mqueue.h>
+#include <errno.h>
+
+/* Called from fork so that the new subprocess re-creates the
+   notification thread if necessary.  */
+void
+__mq_notify_fork_subprocess (void)
+{
+  /* Nothing to do on Ironclad - we don't track notification threads.  */
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mq_timedreceive.c glibc-workdir/sysdeps/unix/sysv/ironclad/mq_timedreceive.c
new file mode 100644
index 0000000..1747ae2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mq_timedreceive.c
@@ -0,0 +1,24 @@
+/* Ironclad does not support POSIX message queues.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <shlib-compat.h>
+
+ssize_t
+___mq_timedreceive_time64 (mqd_t mqdes, char *__restrict msg_ptr, size_t msg_len,
+                           unsigned int *__restrict msg_prio,
+                           const struct __timespec64 *__restrict abs_timeout)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+versioned_symbol (libc, ___mq_timedreceive_time64, mq_timedreceive, GLIBC_2_34);
+libc_hidden_ver (___mq_timedreceive_time64, __mq_timedreceive)
+#ifndef SHARED
+strong_alias (___mq_timedreceive_time64, __mq_timedreceive)
+#endif
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_3_4, GLIBC_2_34)
+compat_symbol (librt, ___mq_timedreceive_time64, mq_timedreceive, GLIBC_2_3_4);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/mq_timedsend.c glibc-workdir/sysdeps/unix/sysv/ironclad/mq_timedsend.c
new file mode 100644
index 0000000..ca3d3e5
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/mq_timedsend.c
@@ -0,0 +1,24 @@
+/* Ironclad does not support POSIX message queues.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <mqueue.h>
+#include <shlib-compat.h>
+
+int
+___mq_timedsend_time64 (mqd_t mqdes, const char *msg_ptr, size_t msg_len,
+                        unsigned int msg_prio,
+                        const struct __timespec64 *abs_timeout)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+versioned_symbol (libc, ___mq_timedsend_time64, mq_timedsend, GLIBC_2_34);
+libc_hidden_ver (___mq_timedsend_time64, __mq_timedsend)
+#ifndef SHARED
+strong_alias (___mq_timedsend_time64, __mq_timedsend)
+#endif
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_3_4, GLIBC_2_34)
+compat_symbol (librt, ___mq_timedsend_time64, mq_timedsend, GLIBC_2_3_4);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/munmap.c glibc-workdir/sysdeps/unix/sysv/ironclad/munmap.c
new file mode 100644
index 0000000..552ffaf
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/munmap.c
@@ -0,0 +1,12 @@
+#include <sys/mman.h>
+#include <sysdep.h>
+
+/* Unmap memory region.
+   Ironclad munmap syscall takes: addr, len.  */
+int
+__munmap (void *addr, size_t len)
+{
+  return INLINE_SYSCALL_CALL (munmap, addr, len);
+}
+libc_hidden_def (__munmap)
+weak_alias (__munmap, munmap)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/not-cancel.h glibc-workdir/sysdeps/unix/sysv/ironclad/not-cancel.h
new file mode 100644
index 0000000..b907376
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/not-cancel.h
@@ -0,0 +1,93 @@
+#ifndef NOT_CANCEL_H
+# define NOT_CANCEL_H
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/poll.h>
+#include <sys/wait.h>
+#include <time.h>
+#include <sys/random.h>
+#include <sysdep.h>
+#include <arch-syscall.h>
+
+/* Non cancellable open syscall.  */
+extern int __open_nocancel (const char *, int, ...);
+
+/* Non cancellable open syscall (LFS version).  */
+extern int __open64_nocancel (const char *, int, ...);
+
+/* Non cancellable openat syscall.  */
+extern int __openat_nocancel (int fd, const char *, int, ...);
+
+/* Non cacellable openat syscall (LFS version).  */
+extern int __openat64_nocancel (int fd, const char *, int, ...);
+
+/* Non cancellable read syscall.  */
+__typeof (__read) __read_nocancel;
+
+/* Non cancellable pread syscall (LFS version).  */
+__typeof (__pread64) __pread64_nocancel;
+
+/* Uncancelable write.  */
+__typeof (__write) __write_nocancel;
+
+/* Uncancelable close.  */
+__typeof (__close) __close_nocancel;
+
+/* Uncancellable close that does not also set errno in case of failure.  */
+void __close_nocancel_nostatus (int);
+
+/* Uncancelable fcntl.  */
+int __fcntl64_nocancel (int, int, ...);
+
+#if IS_IN (libc) || IS_IN (rtld)
+hidden_proto (__open_nocancel)
+hidden_proto (__open64_nocancel)
+hidden_proto (__openat_nocancel)
+hidden_proto (__openat64_nocancel)
+hidden_proto (__read_nocancel)
+hidden_proto (__pread64_nocancel)
+hidden_proto (__write_nocancel)
+hidden_proto (__close_nocancel)
+hidden_proto (__close_nocancel_nostatus)
+hidden_proto (__fcntl64_nocancel)
+#endif
+
+/* Non cancellable writev that does not also set errno in case of failure.
+   Ironclad has no native writev syscall, so we iterate through iovecs.  */
+static inline void
+__writev_nocancel_nostatus (int fd, const struct iovec *iov, int iovcnt)
+{
+  for (int i = 0; i < iovcnt; i++)
+    {
+      if (iov[i].iov_len > 0)
+	/* Ironclad write: (fd, buf, count, offset, flag).  */
+	INTERNAL_SYSCALL_CALL (write, fd, iov[i].iov_base, iov[i].iov_len, 0, 0);
+    }
+}
+
+static inline ssize_t
+__getrandom_nocancel_direct (void *buf, size_t buflen, unsigned int flags)
+{
+  /* Ironclad uses getentropy syscall, not getrandom.  */
+  return INLINE_SYSCALL_CALL (getentropy, buf, buflen);
+}
+
+__typeof (getrandom) __getrandom_nocancel attribute_hidden;
+
+/* Non cancellable getrandom syscall that does not also set errno in case of
+   failure.  */
+static inline ssize_t
+__getrandom_nocancel_nostatus_direct (void *buf, size_t buflen, unsigned int flags)
+{
+  /* Ironclad uses getentropy syscall, not getrandom.  */
+  return INTERNAL_SYSCALL_CALL (getentropy, buf, buflen);
+}
+
+static inline int
+__poll_infinity_nocancel (struct pollfd *fds, nfds_t nfds)
+{
+  return INLINE_SYSCALL_CALL (ppoll, fds, nfds, NULL, NULL, 0);
+}
+
+#endif /* NOT_CANCEL_H  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/not-errno.h glibc-workdir/sysdeps/unix/sysv/ironclad/not-errno.h
new file mode 100644
index 0000000..0c4f54e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/not-errno.h
@@ -0,0 +1,13 @@
+#include <sysdep.h>
+#include <fcntl.h>
+
+static inline int
+__kill_noerrno (pid_t pid, int sig)
+{
+  int res;
+  /* Ironclad uses send_signal instead of kill.  */
+  res = INTERNAL_SYSCALL_CALL (send_signal, pid, sig);
+  if (INTERNAL_SYSCALL_ERROR_P (res))
+    return INTERNAL_SYSCALL_ERRNO (res);
+  return 0;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/open.c glibc-workdir/sysdeps/unix/sysv/ironclad/open.c
new file mode 100644
index 0000000..b97091e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/open.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - open is provided by open64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/open64.c glibc-workdir/sysdeps/unix/sysv/ironclad/open64.c
new file mode 100644
index 0000000..8ae5b6d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/open64.c
@@ -0,0 +1,35 @@
+#include <fcntl.h>
+#include <stdarg.h>
+#include <shlib-compat.h>
+#include "openat-internal.h"
+
+/* Open FILE with access OFLAG.  Delegate to openat64 with AT_FDCWD.  */
+int
+__libc_open64 (const char *file, int oflag, ...)
+{
+  mode_t mode = 0;
+
+  if (oflag & O_CREAT)
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      mode = va_arg (ap, mode_t);
+      va_end (ap);
+    }
+
+  return __libc_openat64 (AT_FDCWD, file, oflag, mode);
+}
+
+strong_alias (__libc_open64, __open64)
+libc_hidden_weak (__open64)
+weak_alias (__libc_open64, open64)
+
+/* Ironclad is 64-bit only, so open/open64 are identical.  */
+strong_alias (__libc_open64, __libc_open)
+strong_alias (__libc_open64, __open)
+libc_hidden_weak (__open)
+weak_alias (__libc_open64, open)
+
+#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_1, GLIBC_2_2)
+compat_symbol (libc, __libc_open64, open64, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/open64_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/open64_nocancel.c
new file mode 100644
index 0000000..da99240
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/open64_nocancel.c
@@ -0,0 +1,25 @@
+#include <fcntl.h>
+#include <stdarg.h>
+#include <not-cancel.h>
+
+/* Open FILE with access OFLAG.  Delegate to openat64_nocancel with AT_FDCWD.  */
+int
+__open64_nocancel (const char *file, int oflag, ...)
+{
+  mode_t mode = 0;
+
+  if (oflag & O_CREAT)
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      mode = va_arg (ap, mode_t);
+      va_end (ap);
+    }
+
+  return __openat64_nocancel (AT_FDCWD, file, oflag, mode);
+}
+hidden_def (__open64_nocancel)
+
+/* Ironclad is 64-bit only.  */
+strong_alias (__open64_nocancel, __open_nocancel)
+hidden_def (__open_nocancel)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/open_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/open_nocancel.c
new file mode 100644
index 0000000..fcd3576
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/open_nocancel.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - __open_nocancel is provided by open64_nocancel.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/openat-internal.h glibc-workdir/sysdeps/unix/sysv/ironclad/openat-internal.h
new file mode 100644
index 0000000..f34b609
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/openat-internal.h
@@ -0,0 +1,8 @@
+#ifndef _OPENAT_INTERNAL_H
+#define _OPENAT_INTERNAL_H
+
+/* Declaration for the main openat64 function (cancellable).
+   Used by open64.c to delegate to openat64.  */
+extern int __libc_openat64 (int fd, const char *file, int oflag, ...);
+
+#endif /* _OPENAT_INTERNAL_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/openat.c glibc-workdir/sysdeps/unix/sysv/ironclad/openat.c
new file mode 100644
index 0000000..6dd4b45
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/openat.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - openat is provided by openat64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/openat64.c glibc-workdir/sysdeps/unix/sysv/ironclad/openat64.c
new file mode 100644
index 0000000..0df7c6c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/openat64.c
@@ -0,0 +1,80 @@
+#include <fcntl.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sysdep-cancel.h>
+#include <shlib-compat.h>
+
+/* Open FILE relative to FD.  Ironclad open syscall takes:
+   dirfd, path, path_len, flags.  O_CREAT is handled in userspace
+   via mknod syscall (like mlibc does).
+
+   This is the cancellable version - uses SYSCALL_CANCEL.  */
+int
+__libc_openat64 (int fd, const char *file, int oflag, ...)
+{
+  mode_t mode = 0;
+
+  if (oflag & O_CREAT)
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      mode = va_arg (ap, mode_t);
+      va_end (ap);
+    }
+
+  /* Check clashing flags: O_CREAT without write access.
+     (Following mlibc behavior.)  */
+  if ((oflag & O_CREAT) && ((oflag & O_WRONLY) == 0) && ((oflag & O_RDWR) == 0))
+    {
+      __set_errno (EISDIR);
+      return -1;
+    }
+
+  size_t path_len = __builtin_strlen (file);
+
+  /* Try to open - this is the cancellation point.
+     Ironclad syscall is named 'open' not 'openat'.  */
+  int ret = SYSCALL_CANCEL (open, fd, file, path_len, oflag);
+
+  /* Handle O_EXCL | O_CREAT: if file already exists, fail.  */
+  if (ret >= 0 && (oflag & O_EXCL) && (oflag & O_CREAT))
+    {
+      INTERNAL_SYSCALL_CALL (close, ret);
+      __set_errno (EEXIST);
+      return -1;
+    }
+
+  /* If file doesn't exist and O_CREAT is set, create it.  */
+  if (ret < 0 && errno == ENOENT && (oflag & O_CREAT) && !(oflag & O_DIRECTORY))
+    {
+      /* Create regular file with mknod.
+         Ironclad syscall is named 'makenode' not 'mknod'.  */
+      int mknod_ret = INLINE_SYSCALL_CALL (makenode, fd, file, path_len,
+                                           S_IFREG | (mode & 07777), 0);
+      if (mknod_ret < 0)
+        return -1;
+
+      /* Retry open - also a cancellation point.  */
+      ret = SYSCALL_CANCEL (open, fd, file, path_len, oflag);
+    }
+
+  /* Handle O_TRUNC: truncate file after opening.
+     Ironclad syscall is named 'truncate' not 'ftruncate64'.  */
+  if (ret >= 0 && (oflag & O_TRUNC))
+    {
+      INLINE_SYSCALL_CALL (truncate, ret, 0);
+    }
+
+  return ret;
+}
+
+strong_alias (__libc_openat64, __openat64)
+libc_hidden_weak (__openat64)
+weak_alias (__libc_openat64, openat64)
+
+/* Ironclad is 64-bit only, so openat/openat64 are identical.  */
+strong_alias (__libc_openat64, __libc_openat)
+strong_alias (__libc_openat64, __openat)
+libc_hidden_weak (__openat)
+weak_alias (__libc_openat64, openat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/openat64_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/openat64_nocancel.c
new file mode 100644
index 0000000..3cf6cf1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/openat64_nocancel.c
@@ -0,0 +1,70 @@
+#include <fcntl.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <not-cancel.h>
+
+/* Ironclad open syscall: dirfd, path, path_len, flags.
+   O_CREAT is handled in userspace via mknod syscall.
+
+   This is the non-cancellable version - uses INLINE_SYSCALL_CALL.  */
+int
+__openat64_nocancel (int fd, const char *file, int oflag, ...)
+{
+  mode_t mode = 0;
+
+  if (oflag & O_CREAT)
+    {
+      va_list ap;
+      va_start (ap, oflag);
+      mode = va_arg (ap, mode_t);
+      va_end (ap);
+    }
+
+  /* Check clashing flags: O_CREAT without write access.
+     (Following mlibc behavior.)  */
+  if ((oflag & O_CREAT) && ((oflag & O_WRONLY) == 0) && ((oflag & O_RDWR) == 0))
+    {
+      __set_errno (EISDIR);
+      return -1;
+    }
+
+  size_t path_len = __builtin_strlen (file);
+
+  /* Try to open.  */
+  int ret = INLINE_SYSCALL_CALL (open, fd, file, path_len, oflag);
+
+  /* Handle O_EXCL | O_CREAT: if file already exists, fail.  */
+  if (ret >= 0 && (oflag & O_EXCL) && (oflag & O_CREAT))
+    {
+      INTERNAL_SYSCALL_CALL (close, ret);
+      __set_errno (EEXIST);
+      return -1;
+    }
+
+  /* If file doesn't exist and O_CREAT is set, create it.  */
+  if (ret < 0 && errno == ENOENT && (oflag & O_CREAT) && !(oflag & O_DIRECTORY))
+    {
+      /* Create regular file with mknod.  */
+      int mknod_ret = INLINE_SYSCALL_CALL (makenode, fd, file, path_len,
+                                           S_IFREG | (mode & 07777), 0);
+      if (mknod_ret < 0)
+        return -1;
+
+      /* Retry open.  */
+      ret = INLINE_SYSCALL_CALL (open, fd, file, path_len, oflag);
+    }
+
+  /* Handle O_TRUNC: truncate file after opening.  */
+  if (ret >= 0 && (oflag & O_TRUNC))
+    {
+      INLINE_SYSCALL_CALL (truncate, ret, 0);
+    }
+
+  return ret;
+}
+hidden_def (__openat64_nocancel)
+
+/* Ironclad is 64-bit only.  */
+strong_alias (__openat64_nocancel, __openat_nocancel)
+hidden_def (__openat_nocancel)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/openat_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/openat_nocancel.c
new file mode 100644
index 0000000..4fd1628
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/openat_nocancel.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - __openat_nocancel is provided by openat64_nocancel.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/opendir.c glibc-workdir/sysdeps/unix/sysv/ironclad/opendir.c
new file mode 100644
index 0000000..3c04ee4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/opendir.c
@@ -0,0 +1,117 @@
+#include <dirent.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <stdio.h>	/* For BUFSIZ.  */
+#include <sys/param.h>	/* For MIN and MAX.  */
+
+#include <not-cancel.h>
+
+enum {
+  opendir_oflags = O_RDONLY|O_NDELAY|O_DIRECTORY|O_LARGEFILE|O_CLOEXEC
+};
+
+static bool
+invalid_name (const char *name)
+{
+  if (__glibc_unlikely (name[0] == '\0'))
+    {
+      /* POSIX.1-1990 says an empty name gets ENOENT;
+	 but `open' might like it fine.  */
+      __set_errno (ENOENT);
+      return true;
+    }
+  return false;
+}
+
+static DIR *
+opendir_tail (int fd)
+{
+  if (__glibc_unlikely (fd < 0))
+    return NULL;
+
+  /* Now make sure this really is a directory and nothing changed since the
+     `stat' call.  The S_ISDIR check is superfluous if O_DIRECTORY works,
+     but it's cheap and we need the stat call for st_blksize anyway.  */
+  struct __stat64_t64 statbuf;
+  if (__glibc_unlikely (__fstat64_time64 (fd, &statbuf) < 0))
+    goto lose;
+  if (__glibc_unlikely (! S_ISDIR (statbuf.st_mode)))
+    {
+      __set_errno (ENOTDIR);
+    lose:
+      __close_nocancel_nostatus (fd);
+      return NULL;
+    }
+
+  return __alloc_dir (fd, true, 0, &statbuf);
+}
+
+
+#if IS_IN (libc)
+DIR *
+__opendirat (int dfd, const char *name)
+{
+  if (__glibc_unlikely (invalid_name (name)))
+    return NULL;
+
+  return opendir_tail (__openat_nocancel (dfd, name, opendir_oflags));
+}
+#endif
+
+
+/* Open a directory stream on NAME.  */
+DIR *
+__opendir (const char *name)
+{
+  if (__glibc_unlikely (invalid_name (name)))
+    return NULL;
+
+  return opendir_tail (__open_nocancel (name, opendir_oflags));
+}
+weak_alias (__opendir, opendir)
+
+DIR *
+__alloc_dir (int fd, bool close_fd, int flags,
+	     const struct __stat64_t64 *statp)
+{
+  /* We have to set the close-on-exit flag if the user provided the
+     file descriptor.  */
+  if (!close_fd
+      && __glibc_unlikely (__fcntl64_nocancel (fd, F_SETFD, FD_CLOEXEC) < 0))
+    return NULL;
+
+  /* The st_blksize value of the directory is used as a hint for the
+     size of the buffer which receives struct dirent values from the
+     kernel.  st_blksize is limited to max_buffer_size, in case the
+     file system provides a bogus value.  */
+  enum { max_buffer_size = 1048576 };
+
+  enum { allocation_size = 32768 };
+  _Static_assert (allocation_size >= sizeof (struct dirent64),
+		  "allocation_size < sizeof (struct dirent64)");
+
+  /* Increase allocation if requested, but not if the value appears to
+     be bogus.  It will be between 32Kb and 1Mb.  */
+  size_t allocation = MIN (MAX ((size_t) statp->st_blksize, (size_t)
+                                allocation_size), (size_t) max_buffer_size);
+
+  DIR *dirp = (DIR *) malloc (sizeof (DIR) + allocation);
+  if (dirp == NULL)
+    {
+      if (close_fd)
+	__close_nocancel_nostatus (fd);
+      return NULL;
+    }
+
+  dirp->fd = fd;
+#if IS_IN (libc)
+  __libc_lock_init (dirp->lock);
+#endif
+  dirp->allocation = allocation;
+  dirp->size = 0;
+  dirp->offset = 0;
+  dirp->filepos = 0;
+  dirp->errcode = 0;
+
+  return dirp;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/openpty.c glibc-workdir/sysdeps/unix/sysv/ironclad/openpty.c
new file mode 100644
index 0000000..aa8bd1b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/openpty.c
@@ -0,0 +1,81 @@
+/* Ironclad has a single openpty syscall that returns both master and
+   slave file descriptors.  This is simpler than the POSIX approach
+   of posix_openpt + grantpt + unlockpt + ptsname + open.  */
+
+#include <errno.h>
+#include <pty.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+int
+__openpty (int *pptmx, int *pterminal, char *name,
+	   const struct termios *termp, const struct winsize *winp)
+{
+  int fds[2];
+
+  /* Ironclad openpty syscall: takes pointer to 2-element int array,
+     returns master fd in fds[0] and slave fd in fds[1].  */
+  int ret = INLINE_SYSCALL_CALL (openpty, fds);
+  if (ret < 0)
+    return -1;
+
+  *pptmx = fds[0];
+  *pterminal = fds[1];
+
+  /* Set up default termios if not provided.  */
+  if (termp == NULL)
+    {
+      struct termios default_termios = {0};
+      default_termios.c_iflag = BRKINT | IGNPAR | ICRNL | IXON;
+      default_termios.c_oflag = OPOST | ONLCR;
+      default_termios.c_cflag = CS8 | CREAD;
+      default_termios.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
+      default_termios.c_cc[VINTR] = 'C' - '@';   /* Ctrl-C */
+      default_termios.c_cc[VERASE] = 127;        /* Delete */
+      default_termios.c_cc[VEOF] = 'D' - '@';    /* Ctrl-D */
+      default_termios.c_cc[VSUSP] = 'Z' - '@';   /* Ctrl-Z */
+      __tcsetattr (*pptmx, TCSANOW, &default_termios);
+    }
+  else
+    {
+      __tcsetattr (*pptmx, TCSANOW, termp);
+    }
+
+  /* Set window size.  */
+  if (winp == NULL)
+    {
+      struct winsize default_winsize = {
+	.ws_row = 24,
+	.ws_col = 80,
+	.ws_xpixel = 24 * 16,
+	.ws_ypixel = 80 * 16
+      };
+      __ioctl (*pptmx, TIOCSWINSZ, &default_winsize);
+    }
+  else
+    {
+      __ioctl (*pptmx, TIOCSWINSZ, winp);
+    }
+
+  /* Get the name if requested.  */
+  if (name != NULL)
+    {
+      char *pts = ttyname (*pterminal);
+      if (pts != NULL)
+	strcpy (name, pts);
+      else
+	name[0] = '\0';
+    }
+
+  return 0;
+}
+versioned_symbol (libc, __openpty, openpty, GLIBC_2_34);
+libc_hidden_ver (__openpty, openpty)
+
+#if OTHER_SHLIB_COMPAT (libutil, GLIBC_2_0, GLIBC_2_34)
+compat_symbol (libutil, __openpty, openpty, GLIBC_2_0);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pipe.c glibc-workdir/sysdeps/unix/sysv/ironclad/pipe.c
new file mode 100644
index 0000000..4d51d06
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pipe.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Create a one-way communication channel (pipe).  If successful,
+   two file descriptors are stored in PIPEDES; bytes written on
+   PIPEDES[1] can be read from PIPEDES[0].
+   Returns 0 if successful, -1 if not.  */
+
+int
+__pipe (int pipedes[2])
+{
+  return __pipe2 (pipedes, 0);
+}
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pipe2.c glibc-workdir/sysdeps/unix/sysv/ironclad/pipe2.c
new file mode 100644
index 0000000..f938cf6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pipe2.c
@@ -0,0 +1,22 @@
+#include <unistd.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* Create a one-way communication channel (pipe).  If successful,
+   two file descriptors are stored in PIPEDES; bytes written on
+   PIPEDES[1] can be read from PIPEDES[0].  Apply FLAGS to the new
+   file descriptors.  Returns 0 if successful, -1 if not.  */
+
+int
+__pipe2 (int pipedes[2], int flags)
+{
+  if (pipedes == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Ironclad syscall is named 'pipe' not 'pipe2'.  */
+  return INLINE_SYSCALL_CALL (pipe, pipedes, flags);
+}
+weak_alias (__pipe2, pipe2)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/poll.c glibc-workdir/sysdeps/unix/sysv/ironclad/poll.c
new file mode 100644
index 0000000..9d10879
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/poll.c
@@ -0,0 +1,20 @@
+#include <errno.h>
+#include <sys/poll.h>
+#include <sysdep-cancel.h>
+
+int
+__poll (struct pollfd *fds, nfds_t nfds, int timeout)
+{
+  struct __timespec64 ts, *tsp = NULL;
+
+  if (timeout >= 0)
+    {
+      ts.tv_sec = timeout / 1000;
+      ts.tv_nsec = (timeout % 1000) * 1000000;
+      tsp = &ts;
+    }
+
+  return __ppoll64 (fds, nfds, tsp, NULL);
+}
+libc_hidden_def (__poll)
+weak_alias (__poll, poll)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/posix_fadvise.c glibc-workdir/sysdeps/unix/sysv/ironclad/posix_fadvise.c
new file mode 100644
index 0000000..4691d08
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/posix_fadvise.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - posix_fadvise is provided by posix_fadvise64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/posix_fadvise64.c glibc-workdir/sysdeps/unix/sysv/ironclad/posix_fadvise64.c
new file mode 100644
index 0000000..103044c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/posix_fadvise64.c
@@ -0,0 +1,21 @@
+#include <fcntl.h>
+#include <sysdep.h>
+
+int __posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise);
+libc_hidden_proto (__posix_fadvise64_l64)
+
+int
+__posix_fadvise64_l64 (int fd, off64_t offset, off64_t len, int advise)
+{
+  /* Ironclad syscall is named 'fadvise' not 'fadvise64'.  */
+  int ret = INTERNAL_SYSCALL_CALL (fadvise, fd, offset, len, advise);
+  if (!INTERNAL_SYSCALL_ERROR_P (ret))
+    return 0;
+  return INTERNAL_SYSCALL_ERRNO (ret);
+}
+libc_hidden_def (__posix_fadvise64_l64)
+
+weak_alias (__posix_fadvise64_l64, posix_fadvise64)
+
+/* Ironclad is 64-bit only, so posix_fadvise/posix_fadvise64 are identical.  */
+strong_alias (__posix_fadvise64_l64, posix_fadvise)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/posix_madvise.c glibc-workdir/sysdeps/unix/sysv/ironclad/posix_madvise.c
new file mode 100644
index 0000000..4728a02
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/posix_madvise.c
@@ -0,0 +1,10 @@
+#include <sysdep.h>
+#include <sys/mman.h>
+
+
+int
+posix_madvise (void *addr, size_t len, int advice)
+{
+  int result = INTERNAL_SYSCALL_CALL (madvise, addr, len, advice);
+  return INTERNAL_SYSCALL_ERRNO (result);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ppoll.c glibc-workdir/sysdeps/unix/sysv/ironclad/ppoll.c
new file mode 100644
index 0000000..cba8081
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ppoll.c
@@ -0,0 +1,23 @@
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/poll.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad is 64-bit only, so ppoll/ppoll64 are identical.
+   On 64-bit systems, __ppoll64 is already a macro for ppoll.  */
+int
+__ppoll64 (struct pollfd *fds, nfds_t nfds, const struct __timespec64 *timeout,
+           const sigset_t *sigmask)
+{
+  /* Ironclad ppoll takes: fds, count, timeout, sigmask */
+  struct __timespec64 tval;
+  if (timeout != NULL)
+    {
+      tval = *timeout;
+      timeout = &tval;
+    }
+
+  return SYSCALL_CANCEL (ppoll, fds, nfds, timeout, sigmask);
+}
+libc_hidden_def (ppoll)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/prctl.c glibc-workdir/sysdeps/unix/sysv/ironclad/prctl.c
new file mode 100644
index 0000000..d03c85f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/prctl.c
@@ -0,0 +1,16 @@
+#include <stdarg.h>
+#include <errno.h>
+#include <sys/prctl.h>
+#include <sysdep.h>
+
+/* Ironclad does not support general prctl syscall.
+   arch_prctl is handled separately for TLS setup.  */
+int
+__prctl (int option, ...)
+{
+  (void) option;
+  __set_errno (ENOSYS);
+  return -1;
+}
+libc_hidden_def (__prctl)
+weak_alias (__prctl, prctl)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pread.c glibc-workdir/sysdeps/unix/sysv/ironclad/pread.c
new file mode 100644
index 0000000..333e684
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pread.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - pread is provided by pread64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pread64.c glibc-workdir/sysdeps/unix/sysv/ironclad/pread64.c
new file mode 100644
index 0000000..190f3df
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pread64.c
@@ -0,0 +1,25 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <shlib-compat.h>
+
+/* Ironclad read syscall with flag=1 for pread: (fd, buf, count, offset, 1).  */
+ssize_t
+__libc_pread64 (int fd, void *buf, size_t count, off64_t offset)
+{
+  return SYSCALL_CANCEL (read, fd, buf, count, offset, 1);
+}
+
+weak_alias (__libc_pread64, __pread64)
+libc_hidden_weak (__pread64)
+weak_alias (__libc_pread64, pread64)
+
+/* Ironclad is 64-bit only, so pread/pread64 are identical.  */
+strong_alias (__libc_pread64, __libc_pread)
+weak_alias (__libc_pread64, __pread)
+weak_alias (__libc_pread64, pread)
+
+#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_1, GLIBC_2_2)
+compat_symbol (libc, __libc_pread64, pread, GLIBC_2_2);
+compat_symbol (libc, __libc_pread64, pread64, GLIBC_2_2);
+compat_symbol (libc, __libc_pread64, __pread64, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pread64_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/pread64_nocancel.c
new file mode 100644
index 0000000..7ad1d36
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pread64_nocancel.c
@@ -0,0 +1,12 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+ssize_t
+__pread64_nocancel (int fd, void *buf, size_t count, off64_t offset)
+{
+  /* Ironclad uses the read syscall with flag=1 for pread.
+     Arguments: fd, buf, count, offset, flag.  */
+  return INLINE_SYSCALL_CALL (read, fd, buf, count, offset, 1);
+}
+hidden_def (__pread64_nocancel)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pselect.c glibc-workdir/sysdeps/unix/sysv/ironclad/pselect.c
new file mode 100644
index 0000000..171ff4c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pselect.c
@@ -0,0 +1,100 @@
+/* Ironclad doesn't have a native select/pselect syscall. We emulate it
+   using ppoll, converting fd_set to pollfd arrays exactly like mlibc does.  */
+
+#include <sys/select.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep-cancel.h>
+
+int
+__pselect64 (int nfds, fd_set *readfds, fd_set *writefds,
+             fd_set *exceptfds, const struct __timespec64 *timeout,
+             const sigset_t *sigmask)
+{
+  if (nfds < 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if (nfds == 0)
+    {
+      /* No fds to watch, just sleep for timeout.  */
+      return SYSCALL_CANCEL (ppoll, NULL, 0, timeout, sigmask);
+    }
+
+  /* Allocate pollfd array - match mlibc by allocating nfds entries.  */
+  struct pollfd *fds = (struct pollfd *) calloc (nfds, sizeof (struct pollfd));
+  if (fds == NULL)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  /* Convert fd_sets to pollfd array - exactly like mlibc.  */
+  for (int i = 0; i < nfds; i++)
+    {
+      struct pollfd *fd = &fds[i];
+
+      if (readfds && FD_ISSET (i, readfds))
+        fd->events |= POLLIN;
+      if (writefds && FD_ISSET (i, writefds))
+        fd->events |= POLLOUT;
+      if (exceptfds && FD_ISSET (i, exceptfds))
+        fd->events |= POLLPRI;
+
+      if (!fd->events)
+        {
+          fd->fd = -1;
+          continue;
+        }
+      fd->fd = i;
+    }
+
+  /* Call ppoll with full nfds count like mlibc does.  */
+  int ret = SYSCALL_CANCEL (ppoll, fds, nfds, timeout, sigmask);
+
+  if (ret < 0)
+    {
+      free (fds);
+      return ret;
+    }
+
+  /* Convert results back to fd_sets - exactly like mlibc.  */
+  fd_set res_read_set, res_write_set, res_except_set;
+  FD_ZERO (&res_read_set);
+  FD_ZERO (&res_write_set);
+  FD_ZERO (&res_except_set);
+
+  for (int i = 0; i < nfds; i++)
+    {
+      struct pollfd *fd = &fds[i];
+
+      if (readfds && FD_ISSET (i, readfds)
+          && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0)
+        FD_SET (i, &res_read_set);
+      if (writefds && FD_ISSET (i, writefds)
+          && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0)
+        FD_SET (i, &res_write_set);
+      if (exceptfds && FD_ISSET (i, exceptfds)
+          && (fd->revents & POLLPRI) != 0)
+        FD_SET (i, &res_except_set);
+    }
+
+  free (fds);
+
+  if (readfds)
+    *readfds = res_read_set;
+  if (writefds)
+    *writefds = res_write_set;
+  if (exceptfds)
+    *exceptfds = res_except_set;
+
+  return ret;
+}
+
+/* Ironclad is 64-bit only, so pselect/pselect64 are identical.
+   On 64-bit systems, __pselect64 is already a macro for __pselect.  */
+weak_alias (__pselect, pselect)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_getaffinity.c glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_getaffinity.c
new file mode 100644
index 0000000..ebf0eb1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_getaffinity.c
@@ -0,0 +1,31 @@
+/* Ironclad does not support CPU affinity.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <pthreadP.h>
+#include <shlib-compat.h>
+
+int
+__pthread_getaffinity_np (pthread_t th, size_t cpusetsize, cpu_set_t *cpuset)
+{
+  return ENOSYS;
+}
+libc_hidden_def (__pthread_getaffinity_np)
+versioned_symbol (libc, __pthread_getaffinity_np, pthread_getaffinity_np,
+		  GLIBC_2_32);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_4, GLIBC_2_32)
+strong_alias (__pthread_getaffinity_np, __pthread_getaffinity_alias)
+compat_symbol (libc, __pthread_getaffinity_alias, pthread_getaffinity_np,
+	       GLIBC_2_3_4);
+#endif
+
+#if SHLIB_COMPAT (libc, GLIBC_2_3_3, GLIBC_2_3_4)
+int
+__pthread_getaffinity_old (pthread_t th, cpu_set_t *cpuset)
+{
+  return ENOSYS;
+}
+compat_symbol (libc, __pthread_getaffinity_old, pthread_getaffinity_np,
+	       GLIBC_2_3_3);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_rwlock_init.c glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_rwlock_init.c
new file mode 100644
index 0000000..3bc7c8c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_rwlock_init.c
@@ -0,0 +1,10 @@
+/* Include the standard implementation.  */
+#include <nptl/pthread_rwlock_init.c>
+
+/* For SHARED builds, the standard implementation only provides
+   ___pthread_rwlock_init (3 underscores) but some code (like abort.c
+   via __libc_rwlock_init macro) expects __pthread_rwlock_init (2 underscores).
+   Provide the symbol unconditionally here.  */
+#ifdef SHARED
+strong_alias (___pthread_rwlock_init, __pthread_rwlock_init)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_setaffinity.c glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_setaffinity.c
new file mode 100644
index 0000000..8851fdf
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pthread_setaffinity.c
@@ -0,0 +1,30 @@
+/* Ironclad does not support CPU affinity.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <pthreadP.h>
+#include <shlib-compat.h>
+
+int
+__pthread_setaffinity_new (pthread_t th, size_t cpusetsize,
+			   const cpu_set_t *cpuset)
+{
+  return ENOSYS;
+}
+versioned_symbol (libc, __pthread_setaffinity_new,
+		  pthread_setaffinity_np, GLIBC_2_34);
+
+#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_3_4, GLIBC_2_34)
+compat_symbol (libpthread, __pthread_setaffinity_new,
+	       pthread_setaffinity_np, GLIBC_2_3_4);
+#endif
+
+#if OTHER_SHLIB_COMPAT (libpthread, GLIBC_2_3_3, GLIBC_2_3_4)
+int
+__pthread_setaffinity_old (pthread_t th, cpu_set_t *cpuset)
+{
+  return ENOSYS;
+}
+compat_symbol (libpthread, __pthread_setaffinity_old, pthread_setaffinity_np,
+	       GLIBC_2_3_3);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ptrace.c glibc-workdir/sysdeps/unix/sysv/ironclad/ptrace.c
new file mode 100644
index 0000000..ecae782
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ptrace.c
@@ -0,0 +1,24 @@
+#include <errno.h>
+#include <sys/ptrace.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <sysdep.h>
+
+/* Ironclad ptrace implementation.
+   Request values: PTRACE_ATTACH=1, DETACH=2, CONT=3, SYSCALL=4, GETREGS=5.  */
+int
+ptrace (enum __ptrace_request request, ...)
+{
+  va_list ap;
+  pid_t pid;
+  void *addr;
+  void *data;
+
+  va_start (ap, request);
+  pid = va_arg (ap, pid_t);
+  addr = va_arg (ap, void *);
+  data = va_arg (ap, void *);
+  va_end (ap);
+
+  return INLINE_SYSCALL_CALL (ptrace, request, pid, addr, data);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ptsname.c glibc-workdir/sysdeps/unix/sysv/ironclad/ptsname.c
new file mode 100644
index 0000000..e60b261
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ptsname.c
@@ -0,0 +1,41 @@
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+/* Return the pathname of the pseudo terminal slave associated with
+   the master FD is open on, or NULL on errors.
+   The returned storage is good until the next call to this function.  */
+char *
+ptsname (int fd)
+{
+  static char buffer[1024];
+  return __ptsname_r (fd, buffer, sizeof buffer) != 0 ? NULL : buffer;
+}
+
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+int
+__ptsname_r (int fd, char *buf, size_t buflen)
+{
+  /* On Ironclad, ttyname syscall works for pseudo-terminals too.  */
+  return __ttyname_r (fd, buf, buflen);
+}
+libc_hidden_def (__ptsname_r)
+weak_alias (__ptsname_r, ptsname_r)
+
+/* Internal function used by login_tty.  */
+int
+__ptsname_internal (int fd, char *buf, size_t buflen, struct stat64 *stp)
+{
+  int ret = __ptsname_r (fd, buf, buflen);
+  if (ret != 0)
+    return ret;
+
+  if (stp != NULL)
+    {
+      if (__stat64 (buf, stp) < 0)
+	return errno;
+    }
+  return 0;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pwrite.c glibc-workdir/sysdeps/unix/sysv/ironclad/pwrite.c
new file mode 100644
index 0000000..36e4ebb
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pwrite.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - pwrite is provided by pwrite64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/pwrite64.c glibc-workdir/sysdeps/unix/sysv/ironclad/pwrite64.c
new file mode 100644
index 0000000..3736185
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/pwrite64.c
@@ -0,0 +1,25 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <shlib-compat.h>
+
+/* Ironclad write syscall with flag=1 for pwrite: (fd, buf, count, offset, 1).  */
+ssize_t
+__libc_pwrite64 (int fd, const void *buf, size_t count, off64_t offset)
+{
+  return SYSCALL_CANCEL (write, fd, buf, count, offset, 1);
+}
+
+weak_alias (__libc_pwrite64, __pwrite64)
+libc_hidden_weak (__pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
+
+/* Ironclad is 64-bit only, so pwrite/pwrite64 are identical.  */
+strong_alias (__libc_pwrite64, __libc_pwrite)
+weak_alias (__libc_pwrite64, __pwrite)
+weak_alias (__libc_pwrite64, pwrite)
+
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_2)
+compat_symbol (libc, __libc_pwrite64, pwrite, GLIBC_2_2);
+compat_symbol (libc, __libc_pwrite64, pwrite64, GLIBC_2_2);
+compat_symbol (libc, __libc_pwrite64, __pwrite64, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/read.c glibc-workdir/sysdeps/unix/sysv/ironclad/read.c
new file mode 100644
index 0000000..021a7ed
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/read.c
@@ -0,0 +1,18 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+/* Read NBYTES into BUF from FD.  Return the number read, -1 for errors
+   or 0 for EOF.  */
+ssize_t
+__libc_read (int fd, void *buf, size_t nbytes)
+{
+  /* Ironclad read syscall takes 5 arguments:
+     fd, buf, count, offset, flag (0=normal read, 1=pread).  */
+  return SYSCALL_CANCEL (read, fd, buf, nbytes, 0, 0);
+}
+libc_hidden_def (__libc_read)
+
+weak_alias (__libc_read, __read)
+libc_hidden_weak (__read)
+weak_alias (__libc_read, read)
+libc_hidden_weak (read)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/read_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/read_nocancel.c
new file mode 100644
index 0000000..c81e358
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/read_nocancel.c
@@ -0,0 +1,12 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+ssize_t
+__read_nocancel (int fd, void *buf, size_t nbytes)
+{
+  /* Ironclad read syscall takes 5 arguments:
+     fd, buf, count, offset, flag (0=normal read, 1=pread).  */
+  return INLINE_SYSCALL_CALL (read, fd, buf, nbytes, 0, 0);
+}
+hidden_def (__read_nocancel)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readdir.c glibc-workdir/sysdeps/unix/sysv/ironclad/readdir.c
new file mode 100644
index 0000000..b6cc942
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readdir.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - readdir is provided by readdir64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readdir64.c glibc-workdir/sysdeps/unix/sysv/ironclad/readdir64.c
new file mode 100644
index 0000000..13fbd6c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readdir64.c
@@ -0,0 +1,60 @@
+/* Ironclad is 64-bit only - readdir/readdir64 are identical.  However the
+   function signatures are not equal due to different return types, so we
+   need to suppress {__}readdir so weak and strong alias do not throw
+   conflicting types errors.  */
+#define readdir   __no_readdir_decl
+#define __readdir __no___readdir_decl
+#include <dirent.h>
+#undef __readdir
+#undef readdir
+
+/* Read a directory entry from DIRP.  No locking.  */
+static struct dirent64 *
+__readdir64_unlocked (DIR *dirp)
+{
+  struct dirent64 *dp;
+  int saved_errno = errno;
+
+  if (dirp->offset >= dirp->size)
+    {
+      /* We've emptied out our buffer.  Refill it.  */
+
+      size_t maxread = dirp->allocation;
+      ssize_t bytes;
+
+      bytes = __getdents64 (dirp->fd, dirp->data, maxread);
+      if (bytes <= 0)
+	{
+	  /* Treat end-of-directory or certain errors as normal EOF.  */
+	  if (bytes == 0 || errno == ENOENT)
+	    __set_errno (saved_errno);
+	  return NULL;
+	}
+      dirp->size = (size_t) bytes;
+
+      /* Reset the offset into the buffer.  */
+      dirp->offset = 0;
+    }
+
+  dp = (struct dirent64 *) &dirp->data[dirp->offset];
+  dirp->offset += dp->d_reclen;
+  dirp->filepos = dp->d_off;
+
+  return dp;
+}
+
+/* Read a directory entry from DIRP.  */
+struct dirent64 *
+__readdir64 (DIR *dirp)
+{
+  __libc_lock_lock (dirp->lock);
+  struct dirent64 *dp = __readdir64_unlocked (dirp);
+  __libc_lock_unlock (dirp->lock);
+  return dp;
+}
+libc_hidden_def (__readdir64)
+
+/* Ironclad is 64-bit only, so readdir/readdir64 are identical.  */
+strong_alias (__readdir64, __readdir)
+weak_alias (__readdir64, readdir64)
+weak_alias (__readdir64, readdir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readdir64_r.c glibc-workdir/sysdeps/unix/sysv/ironclad/readdir64_r.c
new file mode 100644
index 0000000..6918c15
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readdir64_r.c
@@ -0,0 +1,99 @@
+/* Ironclad is 64-bit only - readdir_r/readdir64_r are identical.  However the
+   function signatures are not equal due to different return types, so we
+   need to suppress {__}readdir_r so weak and strong alias do not throw
+   conflicting types errors.  */
+#define readdir_r   __no_readdir_r_decl
+#define __readdir_r __no___readdir_r_decl
+#include <dirent.h>
+#undef __readdir_r
+#undef readdir_r
+
+/* Read a directory entry from DIRP.  */
+int
+__readdir64_r (DIR *dirp, struct dirent64 *entry, struct dirent64 **result)
+{
+  struct dirent64 *dp;
+  size_t reclen;
+  const int saved_errno = errno;
+  int ret;
+
+  __libc_lock_lock (dirp->lock);
+
+  while (1)
+    {
+      if (dirp->offset >= dirp->size)
+	{
+	  /* We've emptied out our buffer.  Refill it.  */
+
+	  size_t maxread = dirp->allocation;
+	  ssize_t bytes;
+
+	  maxread = dirp->allocation;
+
+	  bytes = __getdents64 (dirp->fd, dirp->data, maxread);
+	  if (bytes <= 0)
+	    {
+	      /* Treat ENOENT as end-of-directory (directory was removed).  */
+	      if (bytes < 0 && errno == ENOENT)
+		{
+		  bytes = 0;
+		  __set_errno (saved_errno);
+		}
+	      if (bytes < 0)
+		dirp->errcode = errno;
+
+	      dp = NULL;
+	      break;
+	    }
+	  dirp->size = (size_t) bytes;
+
+	  /* Reset the offset into the buffer.  */
+	  dirp->offset = 0;
+	}
+
+      dp = (struct dirent64 *) &dirp->data[dirp->offset];
+
+      reclen = dp->d_reclen;
+
+      dirp->offset += reclen;
+
+      dirp->filepos = dp->d_off;
+
+      if (reclen <= offsetof (struct dirent64, d_name) + NAME_MAX + 1)
+	break;
+
+      /* The record is very long.  It could still fit into the
+	 caller-supplied buffer if we can skip padding at the end.  */
+      size_t namelen = _D_EXACT_NAMLEN (dp);
+      if (namelen <= NAME_MAX)
+	{
+	  reclen = offsetof (struct dirent64, d_name) + namelen + 1;
+	  break;
+	}
+
+      /* The name is too long.  Ignore this file.  */
+      dirp->errcode = ENAMETOOLONG;
+    }
+
+  if (dp != NULL)
+    {
+      *result = memcpy (entry, dp, reclen);
+      entry->d_reclen = reclen;
+      ret = 0;
+    }
+  else
+    {
+      *result = NULL;
+      ret = dirp->errcode;
+    }
+
+  __libc_lock_unlock (dirp->lock);
+
+  return ret;
+}
+
+
+/* Ironclad is 64-bit only, so readdir_r/readdir64_r are identical.  */
+strong_alias (__readdir64_r, __readdir_r)
+weak_alias (__readdir64_r, readdir_r)
+weak_alias (__readdir64_r, readdir64_r)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readdir_r.c glibc-workdir/sysdeps/unix/sysv/ironclad/readdir_r.c
new file mode 100644
index 0000000..b86b78f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readdir_r.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - readdir_r is provided by readdir64_r.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readlink.c glibc-workdir/sysdeps/unix/sysv/ironclad/readlink.c
new file mode 100644
index 0000000..95e0b84
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readlink.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+#include <fcntl.h>
+
+/* Read the contents of the symbolic link PATH into no more than
+   LEN bytes of BUF.  The contents are not null-terminated.
+   Returns the number of characters read, or -1 for errors.
+
+   Ironclad has only readlinkat (syscall 41) which takes dirfd.
+   Use AT_FDCWD for readlink semantics.  */
+ssize_t
+__readlink (const char *path, char *buf, size_t len)
+{
+  return __readlinkat (AT_FDCWD, path, buf, len);
+}
+weak_alias (__readlink, readlink)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readlinkat.c glibc-workdir/sysdeps/unix/sysv/ironclad/readlinkat.c
new file mode 100644
index 0000000..3aad264
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readlinkat.c
@@ -0,0 +1,35 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Read the contents of the symbolic link PATH relative to FD.
+   Ironclad readlink syscall: (dirfd, path, path_len, buffer, max_size).
+
+   Note: Ironclad kernel limits buffer size to 1024 bytes (Path_Max_Len).
+   We clamp the buffer size here to avoid ENAMETOOLONG errors.  */
+
+/* Ironclad kernel's maximum path/buffer length.  */
+#define IRONCLAD_PATH_MAX_LEN 1024
+
+ssize_t
+__readlinkat (int fd, const char *path, char *buf, size_t len)
+{
+  if (path == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path_len first to avoid clobbering later arguments.  */
+  size_t path_len = __builtin_strlen (path);
+
+  /* Ironclad kernel rejects buffer sizes > 1024.  Clamp to avoid ENAMETOOLONG.
+     This means symlink targets > 1024 bytes will be truncated.  */
+  size_t kernel_len = len > IRONCLAD_PATH_MAX_LEN ? IRONCLAD_PATH_MAX_LEN : len;
+
+  /* Ironclad syscall is named 'readlink' not 'readlinkat'.  */
+  return INLINE_SYSCALL_CALL (readlink, fd, path, path_len, buf, kernel_len);
+}
+weak_alias (__readlinkat, readlinkat)
+libc_hidden_def (readlinkat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readonly-area-fallback.c glibc-workdir/sysdeps/unix/sysv/ironclad/readonly-area-fallback.c
new file mode 100644
index 0000000..9c0e9a3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readonly-area-fallback.c
@@ -0,0 +1,13 @@
+/* Ironclad readonly-area-fallback - stub implementation.
+   Ironclad doesn't have /proc/self/maps, so we return the
+   inaccessible status which causes the caller to skip the check.  */
+
+#include <stdlib.h>
+
+enum readonly_error_type
+__readonly_area_fallback (const void *ptr, size_t size)
+{
+  /* Return that procfs is inaccessible, which tells the caller
+     to skip the read-only check rather than fail.  */
+  return readonly_procfs_inaccessible;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/readv.c glibc-workdir/sysdeps/unix/sysv/ironclad/readv.c
new file mode 100644
index 0000000..3210649
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/readv.c
@@ -0,0 +1,47 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad has no native readv syscall.  Emulate by calling read
+   for each iovec entry.  This is not atomic but matches mlibc's behavior.  */
+
+ssize_t
+__readv (int fd, const struct iovec *iov, int iovcnt)
+{
+  if (iovcnt < 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  ssize_t total = 0;
+  for (int i = 0; i < iovcnt; i++)
+    {
+      if (iov[i].iov_len == 0)
+	continue;
+
+      /* Ironclad read syscall: (fd, buf, count, offset, flag).
+	 Use offset=0 and flag=0 for normal sequential read.  */
+      ssize_t ret = SYSCALL_CANCEL (read, fd, iov[i].iov_base,
+				    iov[i].iov_len, 0, 0);
+      if (ret < 0)
+	{
+	  if (total > 0)
+	    return total;
+	  return ret;
+	}
+      if (ret == 0)
+	return total;  /* EOF */
+
+      total += ret;
+
+      /* Short read - return what we have.  */
+      if ((size_t) ret < iov[i].iov_len)
+	return total;
+    }
+
+  return total;
+}
+libc_hidden_def (__readv)
+weak_alias (__readv, readv)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/reboot.c glibc-workdir/sysdeps/unix/sysv/ironclad/reboot.c
new file mode 100644
index 0000000..6c9f4ea
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/reboot.c
@@ -0,0 +1,10 @@
+#include <errno.h>
+#include <sys/reboot.h>
+#include <sysdep.h>
+
+int
+reboot (int howto)
+{
+  /* Ironclad's reboot syscall takes 2 arguments: command and unused (0).  */
+  return INLINE_SYSCALL_CALL (reboot, howto, 0);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/recv.c glibc-workdir/sysdeps/unix/sysv/ironclad/recv.c
new file mode 100644
index 0000000..3a68138
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/recv.c
@@ -0,0 +1,11 @@
+#include <stddef.h>
+#include <sys/socket.h>
+
+ssize_t
+__libc_recv (int fd, void *buf, size_t len, int flags)
+{
+  return __libc_recvfrom (fd, buf, len, flags, NULL, NULL);
+}
+weak_alias (__libc_recv, recv)
+weak_alias (__libc_recv, __recv)
+libc_hidden_weak (__recv)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/recvfrom.c glibc-workdir/sysdeps/unix/sysv/ironclad/recvfrom.c
new file mode 100644
index 0000000..1bcbf19
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/recvfrom.c
@@ -0,0 +1,12 @@
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+ssize_t
+__libc_recvfrom (int fd, void *buf, size_t len, int flags,
+                 __SOCKADDR_ARG addr, socklen_t *addrlen)
+{
+  return SYSCALL_CANCEL (recvfrom, fd, buf, len, flags, addr.__sockaddr__,
+                         addrlen);
+}
+weak_alias (__libc_recvfrom, recvfrom)
+weak_alias (__libc_recvfrom, __recvfrom)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/recvmsg.c glibc-workdir/sysdeps/unix/sysv/ironclad/recvmsg.c
new file mode 100644
index 0000000..07a0ee3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/recvmsg.c
@@ -0,0 +1,43 @@
+#include <errno.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad doesn't have a native recvmsg syscall.
+   Emulate using recvsockctl (for control data) and recvfrom (for data).  */
+
+ssize_t
+__libc_recvmsg (int fd, struct msghdr *msg, int flags)
+{
+  ssize_t total = 0;
+
+  /* Receive control message if buffer is provided.  */
+  if (msg->msg_control != NULL && msg->msg_controllen > 0)
+    {
+      int ret = INLINE_SYSCALL_CALL (recvsockctl, fd, msg->msg_control,
+                                     msg->msg_controllen);
+      if (ret < 0)
+        return -1;
+    }
+
+  /* Receive into each iovec buffer using recvfrom.  */
+  for (size_t i = 0; i < (size_t) msg->msg_iovlen; i++)
+    {
+      ssize_t ret = SYSCALL_CANCEL (recvfrom, fd,
+                                    msg->msg_iov[i].iov_base,
+                                    msg->msg_iov[i].iov_len,
+                                    flags,
+                                    msg->msg_name,
+                                    msg->msg_namelen);
+      if (ret < 0)
+        return -1;
+      total += ret;
+
+      /* If we got less than requested, don't try to fill more buffers.  */
+      if ((size_t) ret < msg->msg_iov[i].iov_len)
+        break;
+    }
+
+  return total;
+}
+weak_alias (__libc_recvmsg, recvmsg)
+weak_alias (__libc_recvmsg, __recvmsg)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/rename.c glibc-workdir/sysdeps/unix/sysv/ironclad/rename.c
new file mode 100644
index 0000000..cddbc88
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/rename.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <fcntl.h>
+
+/* Declare __renameat - defined in renameat.c.  */
+extern int __renameat (int olddirfd, const char *old,
+                       int newdirfd, const char *new);
+
+/* Ironclad has no standalone rename syscall - it uses renameat with
+   path length arguments.  Route through __renameat with AT_FDCWD
+   to get proper path length handling.  */
+
+int
+rename (const char *old, const char *new)
+{
+  return __renameat (AT_FDCWD, old, AT_FDCWD, new);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/renameat.c glibc-workdir/sysdeps/unix/sysv/ironclad/renameat.c
new file mode 100644
index 0000000..c4ff50b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/renameat.c
@@ -0,0 +1,28 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sysdep.h>
+
+/* Rename OLD relative to OLDDIRFD to NEW relative to NEWDIRFD.
+   Ironclad rename syscall takes 7 args:
+   (olddirfd, old_path, old_len, newdirfd, new_path, new_len, flags).  */
+
+int
+__renameat (int olddirfd, const char *old, int newdirfd, const char *new)
+{
+  if (old == NULL || new == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path lengths first to avoid clobbering later arguments.  */
+  size_t old_len = __builtin_strlen (old);
+  size_t new_len = __builtin_strlen (new);
+  /* Ironclad syscall is named 'rename' not 'renameat'.
+     Pass flags=0 as the 7th argument.  */
+  return INLINE_SYSCALL_CALL (rename, olddirfd, old, old_len,
+			      newdirfd, new, new_len, 0);
+}
+libc_hidden_def (__renameat)
+weak_alias (__renameat, renameat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/res_enable_icmp.c glibc-workdir/sysdeps/unix/sysv/ironclad/res_enable_icmp.c
new file mode 100644
index 0000000..425d8c3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/res_enable_icmp.c
@@ -0,0 +1,9 @@
+/* Ironclad does not support the IP_RECVERR extension.  */
+
+#include <resolv.h>
+
+int
+__res_enable_icmp (int family, int fd)
+{
+  return 0;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/rewinddir.c glibc-workdir/sysdeps/unix/sysv/ironclad/rewinddir.c
new file mode 100644
index 0000000..fda396d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/rewinddir.c
@@ -0,0 +1,24 @@
+#include <stddef.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <dirstream.h>
+
+/* Rewind DIRP to the beginning of the directory.  */
+void
+__rewinddir (DIR *dirp)
+{
+#if IS_IN (libc)
+  __libc_lock_lock (dirp->lock);
+#endif
+  (void) __lseek (dirp->fd, (off_t) 0, SEEK_SET);
+  dirp->filepos = 0;
+  dirp->offset = 0;
+  dirp->size = 0;
+  dirp->errcode = 0;
+#if IS_IN (libc)
+  __libc_lock_unlock (dirp->lock);
+#endif
+}
+libc_hidden_def (__rewinddir)
+weak_alias (__rewinddir, rewinddir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/rmdir.c glibc-workdir/sysdeps/unix/sysv/ironclad/rmdir.c
new file mode 100644
index 0000000..3861297
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/rmdir.c
@@ -0,0 +1,22 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Remove the directory PATH.
+   Ironclad unlink syscall: (dirfd, path, path_len, flags).
+   For rmdir(), use AT_FDCWD and flags=AT_REMOVEDIR.  */
+
+int
+__rmdir (const char *path)
+{
+  if (path == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  size_t path_len = __builtin_strlen (path);
+  return INLINE_SYSCALL_CALL (unlink, AT_FDCWD, path, path_len, AT_REMOVEDIR);
+}
+weak_alias (__rmdir, rmdir)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/rseq-internal.h glibc-workdir/sysdeps/unix/sysv/ironclad/rseq-internal.h
new file mode 100644
index 0000000..47780de
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/rseq-internal.h
@@ -0,0 +1,63 @@
+#ifndef RSEQ_INTERNAL_H
+#define RSEQ_INTERNAL_H
+
+/* Ironclad does not support restartable sequences (rseq).
+   This is a stub implementation that disables RSEQ functionality.  */
+
+#include <sysdep.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <ldsodefs.h>
+#include <thread_pointer.h>
+
+/* RSEQ CPU ID value indicating registration failure.  */
+#define RSEQ_CPU_ID_REGISTRATION_FAILED -1
+
+/* Stub rseq area structure.  */
+struct rseq_area
+{
+  uint32_t cpu_id_start;
+  uint32_t cpu_id;
+  uint64_t rseq_cs;
+  uint32_t flags;
+};
+
+/* Size and alignment definitions (for compatibility).  */
+#define RSEQ_AREA_SIZE_INITIAL 32
+#define RSEQ_AREA_SIZE_INITIAL_USED 20
+#define RSEQ_MIN_ALIGN 32
+
+/* Stub external variables - defined elsewhere.  */
+extern size_t _rseq_align attribute_hidden;
+extern unsigned int _rseq_size attribute_hidden;
+extern ptrdiff_t _rseq_offset attribute_hidden;
+
+/* For Ironclad, RSEQ is not supported so these are just stubs.
+   We don't use rtld_hidden_proto since we don't export these symbols.  */
+
+/* Returns a pointer to the current thread rseq area.
+   For Ironclad, returns NULL since RSEQ is not supported.  */
+static inline struct rseq_area *
+RSEQ_SELF (void)
+{
+  return NULL;
+}
+
+/* Stub RSEQ_GETMEM_ONCE - always returns registration failure.  */
+#define RSEQ_GETMEM_ONCE(member) \
+  ({ RSEQ_CPU_ID_REGISTRATION_FAILED; })
+
+/* Stub RSEQ_SETMEM - no-op.  */
+#define RSEQ_SETMEM(member, value) \
+  ((void) 0)
+
+/* Ironclad does not support RSEQ, always return false indicating
+   registration failure.  */
+static inline bool
+rseq_register_current_thread (struct pthread *self, bool do_rseq)
+{
+  return false;
+}
+
+#endif /* rseq-internal.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sbrk.c glibc-workdir/sysdeps/unix/sysv/ironclad/sbrk.c
new file mode 100644
index 0000000..6972e1d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sbrk.c
@@ -0,0 +1,34 @@
+/* Mark symbols hidden in static PIE for early self relocation to work.  */
+#if BUILD_PIE_DEFAULT
+# pragma GCC visibility push(hidden)
+#endif
+#include <errno.h>
+#include <libc-internal.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <unistd.h>
+
+/* Defined in brk.c.  */
+extern void *__curbrk;
+extern int __brk (void *addr);
+
+/* Extend the process's data space by INCREMENT.
+   If INCREMENT is negative, shrink data space by - INCREMENT.
+   Return start of new space allocated, or -1 for errors.
+
+   Ironclad note: We always return failure to force malloc to use mmap
+   exclusively.  The brk emulation via mmap doesn't work correctly because
+   ld.so and libc.so have separate copies of the brk state variables.
+   By making sbrk always fail, malloc falls back to mmap for all allocations,
+   which is the same approach mlibc uses on Ironclad.  */
+void *
+__sbrk (intptr_t increment)
+{
+  (void) increment;  /* Unused.  */
+
+  /* Always fail - force malloc to use mmap instead.  */
+  __set_errno (ENOMEM);
+  return (void *) -1;
+}
+libc_hidden_def (__sbrk)
+weak_alias (__sbrk, sbrk)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_getp.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_getp.c
new file mode 100644
index 0000000..0bc0e78
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_getp.c
@@ -0,0 +1,14 @@
+/* Ironclad does not support sched_getparam.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <sched.h>
+
+int
+__sched_getparam (pid_t pid, struct sched_param *param)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+libc_hidden_def (__sched_getparam)
+weak_alias (__sched_getparam, sched_getparam)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_gets.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_gets.c
new file mode 100644
index 0000000..f22a429
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_gets.c
@@ -0,0 +1,10 @@
+#include <sched.h>
+#include <sysdep.h>
+
+int
+__sched_getscheduler (pid_t pid)
+{
+  return INLINE_SYSCALL_CALL (get_scheduler, pid);
+}
+libc_hidden_def (__sched_getscheduler)
+weak_alias (__sched_getscheduler, sched_getscheduler)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_primax.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_primax.c
new file mode 100644
index 0000000..767c4d1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_primax.c
@@ -0,0 +1,10 @@
+#include <sched.h>
+#include <sysdep.h>
+
+int
+__sched_get_priority_max (int algorithm)
+{
+  return INLINE_SYSCALL_CALL (get_max_prio, algorithm);
+}
+libc_hidden_def (__sched_get_priority_max)
+weak_alias (__sched_get_priority_max, sched_get_priority_max)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_primin.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_primin.c
new file mode 100644
index 0000000..c727ce1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_primin.c
@@ -0,0 +1,10 @@
+#include <sched.h>
+#include <sysdep.h>
+
+int
+__sched_get_priority_min (int algorithm)
+{
+  return INLINE_SYSCALL_CALL (get_min_prio, algorithm);
+}
+libc_hidden_def (__sched_get_priority_min)
+weak_alias (__sched_get_priority_min, sched_get_priority_min)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_setp.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_setp.c
new file mode 100644
index 0000000..91088d0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_setp.c
@@ -0,0 +1,14 @@
+/* Ironclad does not support sched_setparam.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <sched.h>
+
+int
+__sched_setparam (pid_t pid, const struct sched_param *param)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+libc_hidden_def (__sched_setparam)
+weak_alias (__sched_setparam, sched_setparam)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_sets.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_sets.c
new file mode 100644
index 0000000..bcbcf44
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_sets.c
@@ -0,0 +1,10 @@
+#include <sched.h>
+#include <sysdep.h>
+
+int
+__sched_setscheduler (pid_t pid, int policy, const struct sched_param *param)
+{
+  return INLINE_SYSCALL_CALL (set_scheduler, pid, policy, param);
+}
+libc_hidden_def (__sched_setscheduler)
+weak_alias (__sched_setscheduler, sched_setscheduler)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sched_yield.c glibc-workdir/sysdeps/unix/sysv/ironclad/sched_yield.c
new file mode 100644
index 0000000..d74a969
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sched_yield.c
@@ -0,0 +1,10 @@
+#include <sched.h>
+#include <sysdep.h>
+
+int
+__sched_yield (void)
+{
+  return INLINE_SYSCALL_CALL (sched_yield);
+}
+libc_hidden_def (__sched_yield)
+weak_alias (__sched_yield, sched_yield)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/seekdir.c glibc-workdir/sysdeps/unix/sysv/ironclad/seekdir.c
new file mode 100644
index 0000000..cc79d07
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/seekdir.c
@@ -0,0 +1,15 @@
+#include <dirent.h>
+#include <unistd.h>
+#include <dirstream.h>
+
+/* Seek to position POS in DIRP.  */
+void
+seekdir (DIR *dirp, long int pos)
+{
+  __libc_lock_lock (dirp->lock);
+  (void) __lseek (dirp->fd, pos, SEEK_SET);
+  dirp->size = 0;
+  dirp->offset = 0;
+  dirp->filepos = pos;
+  __libc_lock_unlock (dirp->lock);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/select.c glibc-workdir/sysdeps/unix/sysv/ironclad/select.c
new file mode 100644
index 0000000..54c7d3c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/select.c
@@ -0,0 +1,29 @@
+/* Ironclad doesn't have a native select syscall. We emulate it using ppoll,
+   converting fd_set to pollfd arrays like mlibc does.  */
+
+#include <sys/select.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad is 64-bit only, so select/select64 are identical.
+   On 64-bit systems, __select64 is already a macro for __select.  */
+int
+__select64 (int nfds, fd_set *readfds, fd_set *writefds,
+            fd_set *exceptfds, struct __timeval64 *timeout)
+{
+  struct __timespec64 ts, *tsp = NULL;
+
+  if (timeout != NULL)
+    {
+      ts.tv_sec = timeout->tv_sec;
+      ts.tv_nsec = timeout->tv_usec * 1000;
+      tsp = &ts;
+    }
+
+  return __pselect64 (nfds, readfds, writefds, exceptfds, tsp, NULL);
+}
+libc_hidden_def (__select)
+weak_alias (__select, select)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/send.c glibc-workdir/sysdeps/unix/sysv/ironclad/send.c
new file mode 100644
index 0000000..e65db6e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/send.c
@@ -0,0 +1,11 @@
+#include <stddef.h>
+#include <sys/socket.h>
+
+ssize_t
+__libc_send (int fd, const void *buf, size_t len, int flags)
+{
+  return __libc_sendto (fd, buf, len, flags, NULL, 0);
+}
+weak_alias (__libc_send, send)
+weak_alias (__libc_send, __send)
+libc_hidden_def (__send)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sendmsg.c glibc-workdir/sysdeps/unix/sysv/ironclad/sendmsg.c
new file mode 100644
index 0000000..a016d3b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sendmsg.c
@@ -0,0 +1,39 @@
+#include <errno.h>
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad doesn't have a native sendmsg syscall.
+   Emulate using sendsockctl (for control data) and sendto (for data).  */
+
+ssize_t
+__libc_sendmsg (int fd, const struct msghdr *msg, int flags)
+{
+  ssize_t total = 0;
+
+  /* Send control message if present.  */
+  if (msg->msg_control != NULL && msg->msg_controllen > 0)
+    {
+      int ret = INLINE_SYSCALL_CALL (sendsockctl, fd, msg->msg_control,
+                                     msg->msg_controllen);
+      if (ret < 0)
+        return -1;
+    }
+
+  /* Send each iovec buffer using sendto.  */
+  for (size_t i = 0; i < (size_t) msg->msg_iovlen; i++)
+    {
+      ssize_t ret = SYSCALL_CANCEL (sendto, fd,
+                                    msg->msg_iov[i].iov_base,
+                                    msg->msg_iov[i].iov_len,
+                                    flags,
+                                    msg->msg_name,
+                                    msg->msg_namelen);
+      if (ret < 0)
+        return -1;
+      total += ret;
+    }
+
+  return total;
+}
+weak_alias (__libc_sendmsg, sendmsg)
+weak_alias (__libc_sendmsg, __sendmsg)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sendto.c glibc-workdir/sysdeps/unix/sysv/ironclad/sendto.c
new file mode 100644
index 0000000..a5e5bbd
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sendto.c
@@ -0,0 +1,12 @@
+#include <sys/socket.h>
+#include <sysdep-cancel.h>
+
+ssize_t
+__libc_sendto (int fd, const void *buf, size_t len, int flags,
+               __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  return SYSCALL_CANCEL (sendto, fd, buf, len, flags, addr.__sockaddr__,
+                         addrlen);
+}
+weak_alias (__libc_sendto, sendto)
+weak_alias (__libc_sendto, __sendto)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setegid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setegid.c
new file mode 100644
index 0000000..c71f347
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setegid.c
@@ -0,0 +1,18 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's setgid syscall (SYSCALL_SETGIDS) takes 2 args: real and effective.
+   For setegid(), we pass -1 for real (meaning "don't change") and egid for effective.  */
+
+int
+setegid (gid_t gid)
+{
+  if (gid == (gid_t) ~0)
+    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
+
+  return INLINE_SYSCALL_CALL (setgids, -1, gid);
+}
+#ifndef setegid
+libc_hidden_def (setegid)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/seteuid.c glibc-workdir/sysdeps/unix/sysv/ironclad/seteuid.c
new file mode 100644
index 0000000..3986154
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/seteuid.c
@@ -0,0 +1,18 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's setuid syscall (SYSCALL_SETUIDS) takes 2 args: real and effective.
+   For seteuid(), we pass -1 for real (meaning "don't change") and euid for effective.  */
+
+int
+seteuid (uid_t uid)
+{
+  if (uid == (uid_t) ~0)
+    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);
+
+  return INLINE_SYSCALL_CALL (setuids, -1, uid);
+}
+#ifndef seteuid
+libc_hidden_def (seteuid)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setgid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setgid.c
new file mode 100644
index 0000000..39d4408
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setgid.c
@@ -0,0 +1,16 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's setgid syscall (SYSCALL_SETGIDS) takes 2 args: real and effective.
+   For setgid(), we pass the same gid for both real and effective gid.  */
+
+int
+__setgid (gid_t gid)
+{
+  /* Ironclad syscall is named 'setgids' not 'setgid'.  */
+  return INLINE_SYSCALL_CALL (setgids, gid, gid);
+}
+#ifndef __setgid
+weak_alias (__setgid, setgid)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setgroups.c glibc-workdir/sysdeps/unix/sysv/ironclad/setgroups.c
new file mode 100644
index 0000000..2c16e4e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setgroups.c
@@ -0,0 +1,9 @@
+#include <grp.h>
+#include <sysdep.h>
+
+int
+setgroups (size_t n, const gid_t *groups)
+{
+  return INLINE_SYSCALL_CALL (setgroups, n, groups);
+}
+libc_hidden_def (setgroups)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sethostname.c glibc-workdir/sysdeps/unix/sysv/ironclad/sethostname.c
new file mode 100644
index 0000000..d41cbc1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sethostname.c
@@ -0,0 +1,8 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+int
+sethostname (const char *name, size_t len)
+{
+  return INLINE_SYSCALL_CALL (sethostname, name, len);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setpgid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setpgid.c
new file mode 100644
index 0000000..5541352
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setpgid.c
@@ -0,0 +1,10 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+int
+__setpgid (pid_t pid, pid_t pgid)
+{
+  return INLINE_SYSCALL_CALL (setpgid, pid, pgid);
+}
+libc_hidden_def (__setpgid)
+weak_alias (__setpgid, setpgid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setpriority.c glibc-workdir/sysdeps/unix/sysv/ironclad/setpriority.c
new file mode 100644
index 0000000..ca7576d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setpriority.c
@@ -0,0 +1,10 @@
+#include <sys/resource.h>
+#include <sysdep.h>
+
+int
+__setpriority (enum __priority_which which, id_t who, int prio)
+{
+  return INLINE_SYSCALL_CALL (setprio, which, who, prio);
+}
+libc_hidden_def (__setpriority)
+weak_alias (__setpriority, setpriority)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setregid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setregid.c
new file mode 100644
index 0000000..b8082ee
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setregid.c
@@ -0,0 +1,15 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's setgid syscall (SYSCALL_SETGIDS) takes 2 args: real and effective.
+   This is the same syscall number as setgid, but setregid passes both args.  */
+
+int
+__setregid (gid_t rgid, gid_t egid)
+{
+  return INLINE_SYSCALL_CALL (setgids, rgid, egid);
+}
+#ifndef __setregid
+weak_alias (__setregid, setregid)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setreuid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setreuid.c
new file mode 100644
index 0000000..f195798
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setreuid.c
@@ -0,0 +1,15 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's setuid syscall (SYSCALL_SETUIDS) takes 2 args: real and effective.
+   This is the same syscall number as setuid, but setreuid passes both args.  */
+
+int
+__setreuid (uid_t ruid, uid_t euid)
+{
+  return INLINE_SYSCALL_CALL (setuids, ruid, euid);
+}
+#ifndef __setreuid
+weak_alias (__setreuid, setreuid)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setrlimit.c glibc-workdir/sysdeps/unix/sysv/ironclad/setrlimit.c
new file mode 100644
index 0000000..c12f282
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setrlimit.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - setrlimit is provided by setrlimit64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setrlimit64.c glibc-workdir/sysdeps/unix/sysv/ironclad/setrlimit64.c
new file mode 100644
index 0000000..a19245a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setrlimit64.c
@@ -0,0 +1,29 @@
+#include <errno.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+
+#undef setrlimit
+#undef __setrlimit
+#define setrlimit setrlimit_redirect
+#define __setrlimit __setrlimit_redirect
+#include <sys/resource.h>
+#undef setrlimit
+#undef __setrlimit
+
+/* Set the soft and hard limits for RESOURCE to *RLIMITS.
+   Returns 0 if successful, -1 if not (and sets errno).  */
+int
+__setrlimit64 (enum __rlimit_resource resource, const struct rlimit64 *rlimits)
+{
+  /* Ironclad rlimit: resource, new_limit, old_limit (NULL for set).  */
+  return INLINE_SYSCALL_CALL (rlimit, resource, rlimits, NULL);
+}
+weak_alias (__setrlimit64, setrlimit64)
+
+/* Ironclad is 64-bit only, so setrlimit/setrlimit64 are identical.  */
+strong_alias (__setrlimit64, __setrlimit)
+weak_alias (__setrlimit64, setrlimit)
+#ifdef SHARED
+__hidden_ver1 (__setrlimit64, __GI___setrlimit, __setrlimit64);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setsid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setsid.c
new file mode 100644
index 0000000..4ad52f6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setsid.c
@@ -0,0 +1,9 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+pid_t
+__setsid (void)
+{
+  return INLINE_SYSCALL_CALL (setsid);
+}
+weak_alias (__setsid, setsid)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setsockopt.c glibc-workdir/sysdeps/unix/sysv/ironclad/setsockopt.c
new file mode 100644
index 0000000..a436d67
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setsockopt.c
@@ -0,0 +1,13 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* Set socket options.
+   Ironclad setsockopt syscall takes: fd, level, optname, optval, optlen.  */
+int
+__setsockopt (int fd, int level, int optname,
+              const void *optval, socklen_t optlen)
+{
+  return INLINE_SYSCALL_CALL (setsockopt, fd, level, optname, optval, optlen);
+}
+libc_hidden_def (__setsockopt)
+weak_alias (__setsockopt, setsockopt)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setuid.c glibc-workdir/sysdeps/unix/sysv/ironclad/setuid.c
new file mode 100644
index 0000000..44d5520
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setuid.c
@@ -0,0 +1,16 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad's setuid syscall (SYSCALL_SETUIDS) takes 2 args: real and effective.
+   For setuid(), we pass the same uid for both real and effective uid.  */
+
+int
+__setuid (uid_t uid)
+{
+  /* Ironclad syscall is named 'setuids' not 'setuid'.  */
+  return INLINE_SYSCALL_CALL (setuids, uid, uid);
+}
+#ifndef __setuid
+weak_alias (__setuid, setuid)
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/setvmaname.h glibc-workdir/sysdeps/unix/sysv/ironclad/setvmaname.h
new file mode 100644
index 0000000..ef80e81
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/setvmaname.h
@@ -0,0 +1,25 @@
+#ifndef __SETVMANAME_H
+#define __SETVMANAME_H
+
+/* Maximum supported name - use same as Linux for compatibility.  */
+#define ANON_VMA_NAME_MAX_LEN 80
+
+/* Set the NAME to the anonymous memory map START with size of LEN.
+   For Ironclad, this is a no-op stub.  */
+#if IS_IN(libc) || IS_IN(rtld)
+#include <stdbool.h>
+
+static inline bool __is_decorate_maps_enabled (void) { return false; }
+
+static inline void __set_vma_name (void *start, size_t len, const char *name)
+{
+  /* VMA naming not supported on Ironclad.  */
+}
+#else
+static inline void __set_vma_name (void *start, size_t len, const char *name)
+{
+  /* VMA naming not supported on Ironclad.  */
+}
+#endif
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/shlib-versions glibc-workdir/sysdeps/unix/sysv/ironclad/shlib-versions
new file mode 100644
index 0000000..a6f3aac
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/shlib-versions
@@ -0,0 +1,3 @@
+# Library versions for Ironclad.
+libm=6
+libc=6
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/shmat.c glibc-workdir/sysdeps/unix/sysv/ironclad/shmat.c
new file mode 100644
index 0000000..9276562
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/shmat.c
@@ -0,0 +1,13 @@
+#include <sys/shm.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* Attach the shared memory segment associated with SHMID to the data
+   segment of the calling process.  SHMADDR and SHMFLG determine how
+   and where the segment is attached.  */
+
+void *
+shmat (int shmid, const void *shmaddr, int shmflg)
+{
+  return (void*) INLINE_SYSCALL_CALL (shmat, shmid, shmaddr, shmflg);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/shmctl.c glibc-workdir/sysdeps/unix/sysv/ironclad/shmctl.c
new file mode 100644
index 0000000..356b9e5
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/shmctl.c
@@ -0,0 +1,15 @@
+#include <sys/shm.h>
+#include <sysdep.h>
+#include <shlib-compat.h>
+#include <errno.h>
+
+/* Ironclad is 64-bit only, so shmctl/shmctl64 are identical.
+   On 64-bit systems, __shmctl64 is already a macro for __shmctl.  */
+
+/* Provide operations to control over shared memory segments.  */
+int
+__shmctl64 (int shmid, int cmd, struct __shmid64_ds *buf)
+{
+  return INLINE_SYSCALL_CALL (shmctl, shmid, cmd, buf);
+}
+versioned_symbol (libc, __shmctl, shmctl, GLIBC_2_2);
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/shmdt.c glibc-workdir/sysdeps/unix/sysv/ironclad/shmdt.c
new file mode 100644
index 0000000..d77cfde
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/shmdt.c
@@ -0,0 +1,12 @@
+#include <sys/shm.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* Detach shared memory segment starting at address specified by SHMADDR
+   from the caller's data segment.  */
+
+int
+shmdt (const void *shmaddr)
+{
+  return INLINE_SYSCALL_CALL (shmdt, shmaddr);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/shmget.c glibc-workdir/sysdeps/unix/sysv/ironclad/shmget.c
new file mode 100644
index 0000000..e44887b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/shmget.c
@@ -0,0 +1,12 @@
+#include <sys/shm.h>
+#include <stddef.h>
+#include <sysdep.h>
+
+/* Return an identifier for an shared memory segment of at least size SIZE
+   which is associated with KEY.  */
+
+int
+shmget (key_t key, size_t size, int shmflg)
+{
+  return INLINE_SYSCALL_CALL (shmget, key, size, shmflg);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/shutdown.c glibc-workdir/sysdeps/unix/sysv/ironclad/shutdown.c
new file mode 100644
index 0000000..6bc4282
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/shutdown.c
@@ -0,0 +1,8 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+int
+shutdown (int fd, int how)
+{
+  return INLINE_SYSCALL_CALL (shutdown, fd, how);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sigaltstack.c glibc-workdir/sysdeps/unix/sysv/ironclad/sigaltstack.c
new file mode 100644
index 0000000..b96eb94
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sigaltstack.c
@@ -0,0 +1,10 @@
+#include <signal.h>
+#include <sysdep.h>
+
+/* Run signals handlers on the stack specified by SS (if not NULL).
+   If OSS is not NULL, it is filled in with the old signal stack status.  */
+int
+sigaltstack (const stack_t *ss, stack_t *oss)
+{
+  return INLINE_SYSCALL_CALL (sigaltstack, ss, oss);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/siglist-compat.h glibc-workdir/sysdeps/unix/sysv/ironclad/siglist-compat.h
new file mode 100644
index 0000000..26664c2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/siglist-compat.h
@@ -0,0 +1 @@
+/* Ironclad is a new OS, no compatibility with older glibc versions needed.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sigpending.c glibc-workdir/sysdeps/unix/sysv/ironclad/sigpending.c
new file mode 100644
index 0000000..170b8d7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sigpending.c
@@ -0,0 +1,17 @@
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+/* Ironclad doesn't have a sigpending syscall.
+   Return an empty set (no pending signals).  */
+int
+sigpending (sigset_t *set)
+{
+  if (set == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  memset (set, 0, sizeof (*set));
+  return 0;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sigset-cvt-mask.h glibc-workdir/sysdeps/unix/sysv/ironclad/sigset-cvt-mask.h
new file mode 100644
index 0000000..81b6849
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sigset-cvt-mask.h
@@ -0,0 +1,23 @@
+static inline int __attribute__ ((unused))
+sigset_set_old_mask (sigset_t *set, int mask)
+{
+  unsigned long int *ptr;
+  int cnt;
+
+  ptr = &set->__val[0];
+
+  *ptr++ = (unsigned int) mask;
+
+  cnt = _SIGSET_NWORDS - 2;
+  do
+    *ptr++ = 0ul;
+  while (--cnt >= 0);
+
+  return 0;
+}
+
+static inline int __attribute__ ((unused))
+sigset_get_old_mask (const sigset_t *set)
+{
+  return (unsigned int) set->__val[0];
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sigsetops.h glibc-workdir/sysdeps/unix/sysv/ironclad/sigsetops.h
new file mode 100644
index 0000000..8eef434
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sigsetops.h
@@ -0,0 +1,97 @@
+#ifndef _SIGSETOPS_H
+#define _SIGSETOPS_H 1
+
+#include <signal.h>
+#include <limits.h>
+#include <libc-pointer-arith.h>
+
+/* Return a mask that includes the bit for SIG only.  */
+#define __sigmask(sig) \
+  (1UL << (((sig) - 1) % ULONG_WIDTH))
+
+/* Return the word index for SIG.  */
+static inline int
+__sigword (int sig)
+{
+  return (sig - 1) / ULONG_WIDTH;
+}
+
+/* Ironclad sig* functions only handle up to __NSIG_WORDS words instead of
+   full _SIGSET_NWORDS sigset size.  The signal numbers are 1-based, and
+   bit 0 of a signal mask is for signal 1.  */
+#define __NSIG_WORDS (ALIGN_UP ((_NSIG - 1), ULONG_WIDTH) / ULONG_WIDTH)
+_Static_assert (__NSIG_WORDS <= _SIGSET_NWORDS,
+		"__NSIG_WORDS > _SIGSET_WORDS");
+
+/* This macro is used on syscall that takes a sigset_t to specify the expected
+   size in bytes.  As for glibc, kernel sigset is implemented as an array of
+   unsigned long.  */
+#define __NSIG_BYTES (__NSIG_WORDS * (ULONG_WIDTH / UCHAR_WIDTH))
+
+static inline void
+__sigemptyset (sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+   set->__val[cnt] = 0;
+}
+
+static inline void
+__sigfillset (sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+   set->__val[cnt] = ~0UL;
+}
+
+static inline int
+__sigisemptyset (const sigset_t *set)
+{
+  int cnt = __NSIG_WORDS;
+  unsigned long int ret = set->__val[--cnt];
+  while (ret == 0 && --cnt >= 0)
+    ret = set->__val[cnt];
+  return ret == 0;
+}
+
+static inline void
+__sigandset (sigset_t *dest, const sigset_t *left, const sigset_t *right)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+    dest->__val[cnt] = left->__val[cnt] & right->__val[cnt];
+}
+
+static inline void
+__sigorset (sigset_t *dest, const sigset_t *left, const sigset_t *right)
+{
+  int cnt = __NSIG_WORDS;
+  while (--cnt >= 0)
+    dest->__val[cnt] = left->__val[cnt] | right->__val[cnt];
+}
+
+static inline int
+__sigismember (const sigset_t *set, int sig)
+{
+  unsigned long int mask = __sigmask (sig);
+  int word = __sigword (sig);
+  return set->__val[word] & mask ? 1 : 0;
+}
+
+static inline void
+__sigaddset (sigset_t *set, int sig)
+{
+  unsigned long int mask = __sigmask (sig);
+  int word = __sigword (sig);
+  set->__val[word] |= mask;
+}
+
+static inline void
+__sigdelset (sigset_t *set, int sig)
+{
+  unsigned long int mask = __sigmask (sig);
+  int word = __sigword (sig);
+  set->__val[word] &= ~mask;
+}
+
+#endif /* sigsetops.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sigsuspend.c glibc-workdir/sysdeps/unix/sysv/ironclad/sigsuspend.c
new file mode 100644
index 0000000..0138b9a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sigsuspend.c
@@ -0,0 +1,30 @@
+#include <errno.h>
+#include <signal.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad doesn't have a sigsuspend syscall.
+   Emulate it using ppoll with the signal mask, like mlibc does.
+   ppoll(NULL, 0, NULL, sigmask) will wait indefinitely until a signal
+   arrives that is not blocked by sigmask.  */
+
+int
+__sigsuspend (const sigset_t *set)
+{
+  /* ppoll with no fds, no timeout, and the given signal mask will block
+     until a signal arrives.  When a signal handler returns, ppoll returns
+     with EINTR.  */
+  int ret = SYSCALL_CANCEL (ppoll, NULL, 0, NULL, set);
+
+  /* sigsuspend always returns -1 with errno set to EINTR when a signal
+     is caught.  If ppoll returned 0 (which shouldn't happen with no fds
+     and no timeout), we still want to return EINTR.  */
+  if (ret == 0)
+    {
+      __set_errno (EINTR);
+      return -1;
+    }
+
+  return ret;
+}
+libc_hidden_def (__sigsuspend)
+weak_alias (__sigsuspend, sigsuspend)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sigwait.c glibc-workdir/sysdeps/unix/sysv/ironclad/sigwait.c
new file mode 100644
index 0000000..0ba3483
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sigwait.c
@@ -0,0 +1,81 @@
+#include <errno.h>
+#include <signal.h>
+#include <stddef.h>
+#include <sysdep-cancel.h>
+
+/* This is our dummy signal handler we use here.  */
+static void ignore_signal (int sig);
+
+/* Place where to remember which signal we got.  Please note that this
+   implementation cannot be used for the threaded libc.  The
+   libpthread must provide an own version.  */
+static int was_sig;
+
+
+static int
+do_sigwait (const sigset_t *set, int *sig)
+{
+  sigset_t tmp_mask;
+  struct sigaction saved[NSIG];
+  struct sigaction action;
+  int save_errno;
+  int this;
+
+  /* Prepare set.  */
+  __sigfillset (&tmp_mask);
+
+  /* Unblock all signals in the SET and register our nice handler.  */
+  action.sa_handler = ignore_signal;
+  action.sa_flags = 0;
+  __sigfillset (&action.sa_mask);	/* Block all signals for handler.  */
+
+  /* Make sure we recognize error conditions by setting WAS_SIG to a
+     value which does not describe a legal signal number.  */
+  was_sig = -1;
+
+  for (this = 1; this < NSIG; ++this)
+    if (__sigismember (set, this))
+      {
+	/* Unblock this signal.  */
+	__sigdelset (&tmp_mask, this);
+
+	/* Register temporary action handler.  */
+	if (__sigaction (this, &action, &saved[this]) != 0)
+	  goto restore_handler;
+      }
+
+  /* Now we can wait for signals.  */
+  __sigsuspend (&tmp_mask);
+
+ restore_handler:
+  save_errno = errno;
+
+  while (--this >= 1)
+    if (__sigismember (set, this))
+      /* We ignore errors here since we must restore all handlers.  */
+      __sigaction (this, &saved[this], NULL);
+
+  __set_errno (save_errno);
+
+  /* Store the result and return.  */
+  *sig = was_sig;
+  return was_sig == -1 ? -1 : 0;
+}
+
+
+int
+__sigwait (const sigset_t *set, int *sig)
+{
+  /* __sigsuspend should be a cancellation point.  */
+  return do_sigwait (set, sig);
+}
+libc_hidden_def (__sigwait)
+weak_alias (__sigwait, sigwait)
+
+
+static void
+ignore_signal (int sig)
+{
+  /* Remember the signal.  */
+  was_sig = sig;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/socket-constants-time64.h glibc-workdir/sysdeps/unix/sysv/ironclad/socket-constants-time64.h
new file mode 100644
index 0000000..ee738a3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/socket-constants-time64.h
@@ -0,0 +1,17 @@
+#ifndef _SOCKET_CONSTANTS_TIME64_H
+#define _SOCKET_CONSTANTS_TIME64_H
+
+/* Socket option constants for time64 compatibility.
+   Ironclad uses 64-bit time_t natively, so old/new values are the same.  */
+
+#define COMPAT_SO_RCVTIMEO_OLD 20
+#define COMPAT_SO_SNDTIMEO_OLD 21
+#define COMPAT_SO_RCVTIMEO_NEW 66
+#define COMPAT_SO_SNDTIMEO_NEW 67
+
+#define COMPAT_SO_TIMESTAMP_OLD 29
+#define COMPAT_SO_TIMESTAMPNS_OLD 35
+#define COMPAT_SO_TIMESTAMP_NEW 63
+#define COMPAT_SO_TIMESTAMPNS_NEW 64
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/socket.c glibc-workdir/sysdeps/unix/sysv/ironclad/socket.c
new file mode 100644
index 0000000..cd41978
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/socket.c
@@ -0,0 +1,15 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* Ironclad's socket syscall only takes 2 arguments: domain and type.
+   The protocol argument is ignored (always treated as 0).
+   This matches mlibc's implementation for Ironclad.  */
+
+int
+__socket (int domain, int type, int protocol)
+{
+  (void) protocol;  /* Ironclad ignores protocol.  */
+  return INLINE_SYSCALL_CALL (socket, domain, type);
+}
+libc_hidden_def (__socket)
+weak_alias (__socket, socket)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/socketpair.c glibc-workdir/sysdeps/unix/sysv/ironclad/socketpair.c
new file mode 100644
index 0000000..3093135
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/socketpair.c
@@ -0,0 +1,14 @@
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* Ironclad's socketpair syscall takes only 3 arguments:
+   domain, type, and pointer to fd array.  The protocol argument
+   is ignored (always 0).  */
+
+int
+__socketpair (int domain, int type, int protocol, int sv[2])
+{
+  (void) protocol;  /* Ironclad ignores protocol.  */
+  return INLINE_SYSCALL_CALL (socketpair, domain, type, &sv[0]);
+}
+weak_alias (__socketpair, socketpair)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/spawn_int_def.h glibc-workdir/sysdeps/unix/sysv/ironclad/spawn_int_def.h
new file mode 100644
index 0000000..8f44305
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/spawn_int_def.h
@@ -0,0 +1,7 @@
+#ifndef _SPAWN_INT_DEF_H
+#define _SPAWN_INT_DEF_H
+
+/* spawni.c implements closefrom via __closefrom_fallback.  */
+#define __SPAWN_SUPPORT_CLOSEFROM 1
+
+#endif /* _SPAWN_INT_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/spawni.c glibc-workdir/sysdeps/unix/sysv/ironclad/spawni.c
new file mode 100644
index 0000000..457088d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/spawni.c
@@ -0,0 +1,379 @@
+/* Ironclad doesn't have Linux's clone() syscall with CLONE_VM|CLONE_VFORK.
+   Instead, it has a simple fork syscall that takes a single argument:
+   0 = fork (copy-on-write)
+   1 = vfork (share address space until exec)
+
+   This implementation uses vfork+exec.  We use a pipe with O_CLOEXEC to
+   communicate exec failure from child to parent: if exec succeeds, the
+   pipe is closed (by cloexec) and parent reads EOF; if exec fails, child
+   writes the error code to the pipe before _exit.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <spawn.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/resource.h>
+#include <not-cancel.h>
+#include <internal-signals.h>
+#include <local-setxid.h>
+#include <sysdep.h>
+#include "spawn_int.h"
+
+/* The Unix standard contains a long explanation of the way to signal
+   an error after the fork() was successful.  Since no new wait status
+   was wanted there is no way to signal an error using one of the
+   available methods.  The committee chose to signal an error by a
+   normal program exit with the exit code 127.  */
+#define SPAWN_ERROR	127
+
+/* Older version requires that shell script without shebang definition
+   to be called explicitly using /bin/sh (_PATH_BSHELL).  */
+static void
+maybe_script_execute (const char *file, char *const argv[], char *const envp[],
+		      int xflags)
+{
+  if ((xflags & SPAWN_XFLAGS_TRY_SHELL) && errno == ENOEXEC)
+    {
+      /* Count the arguments.  */
+      int argc = 0;
+      while (argv[argc++] != NULL)
+	;
+
+      /* Construct an argument list for the shell.  */
+      char *new_argv[argc + 1];
+      new_argv[0] = (char *) _PATH_BSHELL;
+      new_argv[1] = (char *) file;
+      if (argc > 1)
+	memcpy (new_argv + 2, argv + 1, (argc - 1) * sizeof (char *));
+      else
+	new_argv[2] = NULL;
+
+      /* Execute the shell.  */
+      __execve (new_argv[0], new_argv, envp);
+    }
+}
+
+/* Execute the file actions and then call exec.  This function never
+   returns on success.  On failure it writes the error to errpipe and exits.  */
+static void __attribute__ ((noreturn))
+__spawni_child (const char *file,
+		const posix_spawn_file_actions_t *file_actions,
+		const posix_spawnattr_t *attrp,
+		char *const argv[],
+		char *const envp[],
+		int xflags,
+		int (*exec) (const char *, char *const *, char *const *),
+		int errpipe)
+{
+  int err = 0;
+
+  /* Default attributes if none provided.  */
+  const posix_spawnattr_t default_attr = { 0 };
+  if (attrp == NULL)
+    attrp = &default_attr;
+
+  short int flags = attrp->__flags;
+
+  /* Set signal mask.  We need to do this before setting signal default
+     handlers because POSIX_SPAWN_SETSIGDEF may restore handlers for
+     signals in the mask.  */
+  sigset_t hset;
+  __sigprocmask (SIG_BLOCK, NULL, &hset);
+
+  /* Reset signal handlers to SIG_DFL if requested, or if we inherited
+     a non-default handler.  */
+  struct sigaction sa;
+  memset (&sa, '\0', sizeof (sa));
+
+  for (int sig = 1; sig < _NSIG; ++sig)
+    {
+      if ((flags & POSIX_SPAWN_SETSIGDEF)
+	  && __sigismember (&attrp->__sd, sig))
+	{
+	  sa.sa_handler = SIG_DFL;
+	}
+      else if (__sigismember (&hset, sig))
+	{
+	  if (is_internal_signal (sig))
+	    sa.sa_handler = SIG_IGN;
+	  else
+	    {
+	      __libc_sigaction (sig, NULL, &sa);
+	      if (sa.sa_handler == SIG_IGN || sa.sa_handler == SIG_DFL)
+		continue;
+	      sa.sa_handler = SIG_DFL;
+	    }
+	}
+      else
+	continue;
+
+      __libc_sigaction (sig, &sa, NULL);
+    }
+
+#ifdef _POSIX_PRIORITY_SCHEDULING
+  /* Set the scheduling algorithm and parameters.  */
+  if ((flags & (POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER))
+      == POSIX_SPAWN_SETSCHEDPARAM)
+    {
+      if (__sched_setparam (0, &attrp->__sp) == -1)
+	goto fail;
+    }
+  else if ((flags & POSIX_SPAWN_SETSCHEDULER) != 0)
+    {
+      if (__sched_setscheduler (0, attrp->__policy, &attrp->__sp) == -1)
+	goto fail;
+    }
+#endif
+
+  if ((flags & POSIX_SPAWN_SETSID) != 0
+      && __setsid () < 0)
+    goto fail;
+
+  /* Set the process group ID.  */
+  if ((flags & POSIX_SPAWN_SETPGROUP) != 0
+      && __setpgid (0, attrp->__pgrp) != 0)
+    goto fail;
+
+  /* Set the effective user and group IDs.  */
+  if ((flags & POSIX_SPAWN_RESETIDS) != 0
+      && (local_seteuid (__getuid ()) != 0
+	  || local_setegid (__getgid ()) != 0))
+    goto fail;
+
+  /* Execute the file actions.  */
+  if (file_actions != NULL)
+    {
+      int cnt;
+      struct rlimit64 fdlimit;
+      bool have_fdlimit = false;
+
+      for (cnt = 0; cnt < file_actions->__used; ++cnt)
+	{
+	  struct __spawn_action *action = &file_actions->__actions[cnt];
+
+	  switch (action->tag)
+	    {
+	    case spawn_do_close:
+	      if (__close_nocancel (action->action.close_action.fd) != 0)
+		{
+		  if (!have_fdlimit)
+		    {
+		      __getrlimit64 (RLIMIT_NOFILE, &fdlimit);
+		      have_fdlimit = true;
+		    }
+
+		  /* Signal errors only for file descriptors out of range.  */
+		  if (action->action.close_action.fd < 0
+		      || action->action.close_action.fd >= fdlimit.rlim_cur)
+		    goto fail;
+		}
+	      break;
+
+	    case spawn_do_open:
+	      {
+		/* POSIX states that if fildes was already an open file descriptor,
+		   it shall be closed before the new file is opened.  */
+		__close_nocancel (action->action.open_action.fd);
+
+		int ret = __open_nocancel (action->action.open_action.path,
+					   action->action.open_action.oflag | O_LARGEFILE,
+					   action->action.open_action.mode);
+
+		if (ret == -1)
+		  goto fail;
+
+		int new_fd = ret;
+
+		/* Make sure the desired file descriptor is used.  */
+		if (ret != action->action.open_action.fd)
+		  {
+		    if (__dup2 (new_fd, action->action.open_action.fd)
+			!= action->action.open_action.fd)
+		      goto fail;
+
+		    if (__close_nocancel (new_fd) != 0)
+		      goto fail;
+		  }
+	      }
+	      break;
+
+	    case spawn_do_dup2:
+	      /* Austin Group issue #411 requires adddup2 action with source
+		 and destination being equal to remove close-on-exec flag.  */
+	      if (action->action.dup2_action.fd
+		  == action->action.dup2_action.newfd)
+		{
+		  int fd = action->action.dup2_action.newfd;
+		  int fl = __fcntl (fd, F_GETFD, 0);
+		  if (fl == -1)
+		    goto fail;
+		  if (__fcntl (fd, F_SETFD, fl & ~FD_CLOEXEC) == -1)
+		    goto fail;
+		}
+	      else if (__dup2 (action->action.dup2_action.fd,
+			       action->action.dup2_action.newfd)
+		       != action->action.dup2_action.newfd)
+		goto fail;
+	      break;
+
+	    case spawn_do_chdir:
+	      if (__chdir (action->action.chdir_action.path) != 0)
+		goto fail;
+	      break;
+
+	    case spawn_do_fchdir:
+	      if (__fchdir (action->action.fchdir_action.fd) != 0)
+		goto fail;
+	      break;
+
+	    case spawn_do_closefrom:
+	      {
+		int lowfd = action->action.closefrom_action.from;
+		/* Ironclad doesn't have close_range, use fallback.  */
+		if (!__closefrom_fallback (lowfd, false))
+		  goto fail;
+	      }
+	      break;
+
+	    case spawn_do_tcsetpgrp:
+	      {
+		/* Check if it is possible to avoid an extra syscall.  */
+		pid_t pgrp = (flags & POSIX_SPAWN_SETPGROUP) != 0
+			       && attrp->__pgrp != 0
+			     ? attrp->__pgrp : __getpgid (0);
+		if (__tcsetpgrp (action->action.setpgrp_action.fd, pgrp) != 0)
+		  goto fail;
+	      }
+	    }
+	}
+    }
+
+  /* Set the initial signal mask of the child if POSIX_SPAWN_SETSIGMASK
+     is set, otherwise unblock all signals.  */
+  if (flags & POSIX_SPAWN_SETSIGMASK)
+    __sigprocmask (SIG_SETMASK, &attrp->__ss, NULL);
+  else
+    {
+      sigset_t empty;
+      __sigemptyset (&empty);
+      __sigprocmask (SIG_SETMASK, &empty, NULL);
+    }
+
+  /* Execute the program.  */
+  exec (file, argv, envp);
+
+  /* Try running script through shell if exec failed with ENOEXEC.  */
+  maybe_script_execute (file, argv, envp, xflags);
+
+fail:
+  /* exec failed - write error to pipe and exit.  */
+  err = errno ? errno : ECHILD;
+  /* Write the error code to the pipe.  The parent reads this.  */
+  while (__write_nocancel (errpipe, &err, sizeof (err)) < 0
+	 && errno == EINTR)
+    ;
+  _exit (SPAWN_ERROR);
+}
+
+/* Spawn a new process executing PATH with the attributes describes in *ATTRP.
+   Before running the process perform the actions described in FILE-ACTIONS.
+
+   This implementation uses vfork+exec because Ironclad doesn't have
+   Linux's clone() syscall.  vfork is the Ironclad fork syscall with
+   argument 1, which shares address space until exec (like CLONE_VFORK).  */
+static int
+__spawnix (int *pid, const char *file,
+	   const posix_spawn_file_actions_t *file_actions,
+	   const posix_spawnattr_t *attrp, char *const argv[],
+	   char *const envp[], int xflags,
+	   int (*exec) (const char *, char *const *, char *const *))
+{
+  pid_t new_pid;
+  int errpipe[2];
+  int err;
+
+  /* Create a pipe for the child to report exec errors.
+     The write end has O_CLOEXEC so it's automatically closed on successful exec.  */
+  if (__pipe2 (errpipe, O_CLOEXEC) != 0)
+    return errno;
+
+  /* Use vfork (fork syscall with arg 1) for vfork semantics.
+     The child shares address space with parent until exec.  */
+  new_pid = INLINE_SYSCALL_CALL (fork, 1);  /* 1 = vfork on Ironclad */
+
+  if (new_pid < 0)
+    {
+      err = errno;
+      __close_nocancel (errpipe[0]);
+      __close_nocancel (errpipe[1]);
+      return err;
+    }
+
+  if (new_pid == 0)
+    {
+      /* Child process.  Close read end of pipe.  */
+      __close_nocancel (errpipe[0]);
+
+      /* Execute file actions and exec.  This function never returns.  */
+      __spawni_child (file, file_actions, attrp, argv, envp, xflags, exec,
+		      errpipe[1]);
+    }
+
+  /* Parent process.  Close write end of pipe.  */
+  __close_nocancel (errpipe[1]);
+
+  /* vfork semantics: parent was blocked until child called exec or _exit.
+     Now try to read from the pipe.  If exec succeeded, the pipe was closed
+     by O_CLOEXEC and we'll read EOF (0 bytes).  If exec failed, child wrote
+     the error code.  */
+  int child_err = 0;
+  ssize_t n;
+  do
+    n = __read_nocancel (errpipe[0], &child_err, sizeof (child_err));
+  while (n < 0 && errno == EINTR);
+
+  __close_nocancel (errpipe[0]);
+
+  if (n == 0)
+    {
+      /* EOF - exec succeeded!  */
+      if (pid != NULL)
+	*pid = new_pid;
+      return 0;
+    }
+
+  if (n == sizeof (child_err))
+    {
+      /* Child reported an error before exec.  The child already exited.  */
+      /* Reap the zombie child.  */
+      int status;
+      while (__waitpid (new_pid, &status, 0) < 0 && errno == EINTR)
+	;
+      return child_err;
+    }
+
+  /* Unexpected case - partial read or read error.
+     Child may still be running or may have exited.  Try to clean up.  */
+  int status;
+  __waitpid (new_pid, &status, WNOHANG);
+  return errno ? errno : ECHILD;
+}
+
+/* Spawn a new process executing PATH with the attributes describes in *ATTRP.
+   Before running the process perform the actions described in FILE-ACTIONS. */
+int
+__spawni (pid_t *pid, const char *file,
+	  const posix_spawn_file_actions_t *acts,
+	  const posix_spawnattr_t *attrp, char *const argv[],
+	  char *const envp[], int xflags)
+{
+  /* It uses __execvpex to avoid run ENOEXEC in non compatibility mode (it
+     will be handled by maybe_script_execute).  */
+  return __spawnix (pid, file, acts, attrp, argv, envp, xflags,
+		    xflags & SPAWN_XFLAGS_USE_PATH ? __execvpex : __execve);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/speed.c glibc-workdir/sysdeps/unix/sysv/ironclad/speed.c
new file mode 100644
index 0000000..00feb34
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/speed.c
@@ -0,0 +1,55 @@
+/* Ironclad uses c_ibaud/c_obaud instead of __ispeed/__ospeed.  */
+
+#include <stddef.h>
+#include <errno.h>
+#include <termios.h>
+
+/* Return the output baud rate stored in *TERMIOS_P.  */
+speed_t
+__cfgetospeed (const struct termios *termios_p)
+{
+  return termios_p->c_obaud;
+}
+libc_hidden_def (__cfgetospeed)
+weak_alias (__cfgetospeed, cfgetospeed)
+
+/* Return the input baud rate stored in *TERMIOS_P.  */
+speed_t
+__cfgetispeed (const struct termios *termios_p)
+{
+  return termios_p->c_ibaud;
+}
+libc_hidden_def (__cfgetispeed)
+weak_alias (__cfgetispeed, cfgetispeed)
+
+/* Set the output baud rate stored in *TERMIOS_P to SPEED.  */
+int
+__cfsetospeed (struct termios *termios_p, speed_t speed)
+{
+  if (termios_p == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  termios_p->c_obaud = speed;
+  return 0;
+}
+libc_hidden_def (__cfsetospeed)
+weak_alias (__cfsetospeed, cfsetospeed)
+
+/* Set the input baud rate stored in *TERMIOS_P to SPEED.  */
+int
+__cfsetispeed (struct termios *termios_p, speed_t speed)
+{
+  if (termios_p == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  termios_p->c_ibaud = speed;
+  return 0;
+}
+libc_hidden_def (__cfsetispeed)
+weak_alias (__cfsetispeed, cfsetispeed)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/stat.c glibc-workdir/sysdeps/unix/sysv/ironclad/stat.c
new file mode 100644
index 0000000..6c6656b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/stat.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - stat is provided by stat64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/stat64.c glibc-workdir/sysdeps/unix/sysv/ironclad/stat64.c
new file mode 100644
index 0000000..7297e88
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/stat64.c
@@ -0,0 +1,16 @@
+#include <sys/stat.h>
+#include <fcntl.h>
+
+int
+__stat64 (const char *file, struct stat64 *buf)
+{
+  return __fstatat64 (AT_FDCWD, file, buf, 0);
+}
+hidden_def (__stat64)
+
+#undef stat64
+weak_alias (__stat64, stat64)
+
+/* Ironclad is 64-bit only, so stat/stat64 are identical.  */
+strong_alias (__stat64, __stat)
+weak_alias (__stat64, stat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/statfs.c glibc-workdir/sysdeps/unix/sysv/ironclad/statfs.c
new file mode 100644
index 0000000..a0b6b99
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/statfs.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - statfs is provided by statfs64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/statfs64.c glibc-workdir/sysdeps/unix/sysv/ironclad/statfs64.c
new file mode 100644
index 0000000..5489d38
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/statfs64.c
@@ -0,0 +1,39 @@
+#define __statfs __statfs_disable
+#define statfs statfs_disable
+#include <sys/statfs.h>
+#include <sys/statvfs.h>
+#include <string.h>
+#undef __statfs
+#undef statfs
+
+/* Ironclad statfs64 implementation using statvfs64.  */
+int
+__statfs64 (const char *file, struct statfs64 *buf)
+{
+  struct statvfs64 vfs;
+  int ret;
+
+  ret = __statvfs64 (file, &vfs);
+  if (ret < 0)
+    return ret;
+
+  /* Convert statvfs64 to statfs64.  */
+  memset (buf, 0, sizeof (*buf));
+  buf->f_type = 0;  /* Ironclad doesn't provide filesystem type magic */
+  buf->f_bsize = vfs.f_bsize;
+  buf->f_blocks = vfs.f_blocks;
+  buf->f_bfree = vfs.f_bfree;
+  buf->f_bavail = vfs.f_bavail;
+  buf->f_files = vfs.f_files;
+  buf->f_ffree = vfs.f_ffree;
+  buf->f_fsid = vfs.f_fsid;
+  buf->f_namelen = vfs.f_namemax;
+  /* Note: generic statfs64 doesn't have f_frsize or f_flags members.  */
+
+  return 0;
+}
+weak_alias (__statfs64, statfs64)
+
+/* Ironclad is 64-bit only, so statfs/statfs64 are identical.  */
+strong_alias (__statfs64, __statfs)
+weak_alias (__statfs64, statfs)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/statvfs.c glibc-workdir/sysdeps/unix/sysv/ironclad/statvfs.c
new file mode 100644
index 0000000..66bd1b1
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/statvfs.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - statvfs is provided by statvfs64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/statvfs64.c glibc-workdir/sysdeps/unix/sysv/ironclad/statvfs64.c
new file mode 100644
index 0000000..57d361e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/statvfs64.c
@@ -0,0 +1,114 @@
+/* Disable the declarations so we can define with struct statvfs64 *.  */
+#define __statvfs __statvfs_disable
+#define statvfs statvfs_disable
+#include <errno.h>
+#include <string.h>
+#include <sys/statvfs.h>
+#include <sysdep.h>
+#include <kernel_stat.h>
+
+/* Ironclad's mountinfo structure returned by listmounts syscall.
+   This must match the kernel's Mount_Data type.  */
+struct ironclad_mountinfo
+{
+  uint32_t type;
+  uint32_t flags;
+  char source[20];
+  uint32_t source_length;
+  char location[20];
+  uint32_t location_length;
+  uint64_t block_size;
+  uint64_t fragment_size;
+  uint64_t size_in_fragments;
+  uint64_t free_blocks;
+  uint64_t free_blocks_user;
+  uint64_t inode_count;
+  uint64_t free_inodes;
+  uint64_t free_inodes_user;
+  uint64_t max_filename;
+};
+
+/* Maximum number of mounts to query.  */
+#define MAX_MOUNTS 16
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statvfs64 (const char *file, struct statvfs64 *buf)
+{
+  struct ironclad_mountinfo mounts[MAX_MOUNTS];
+  long ret;
+  int best_len = 0;
+  int best_idx = -1;
+  size_t file_len;
+
+  if (file == NULL || buf == NULL)
+    {
+      __set_errno (EFAULT);
+      return -1;
+    }
+
+  file_len = strlen (file);
+
+  /* Call listmounts syscall to get mount information.  */
+  ret = INLINE_SYSCALL_CALL (listmounts, mounts, MAX_MOUNTS);
+  if (ret < 0)
+    return -1;
+
+  /* If more mounts than we can handle, just use what we have.  */
+  if (ret > MAX_MOUNTS)
+    ret = MAX_MOUNTS;
+
+  /* Find the mount with the longest matching prefix for the given path.  */
+  for (int i = 0; i < ret; i++)
+    {
+      size_t loc_len = mounts[i].location_length;
+
+      /* Check if this mount's location is a prefix of the file path.  */
+      if (loc_len <= file_len
+          && strncmp (file, mounts[i].location, loc_len) == 0)
+        {
+          /* Make sure the prefix ends at a path component boundary.  */
+          if (loc_len == file_len
+              || file[loc_len] == '/'
+              || (loc_len > 0 && mounts[i].location[loc_len - 1] == '/'))
+            {
+              if ((int) loc_len > best_len)
+                {
+                  best_len = loc_len;
+                  best_idx = i;
+                }
+            }
+        }
+    }
+
+  if (best_idx < 0)
+    {
+      /* No matching mount found.  This shouldn't happen for valid paths.  */
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Fill in the statvfs structure from the mountinfo.  */
+  memset (buf, 0, sizeof (*buf));
+  buf->f_bsize = mounts[best_idx].block_size;
+  buf->f_frsize = mounts[best_idx].fragment_size;
+  buf->f_blocks = mounts[best_idx].size_in_fragments;
+  buf->f_bfree = mounts[best_idx].free_blocks;
+  buf->f_bavail = mounts[best_idx].free_blocks_user;
+  buf->f_files = mounts[best_idx].inode_count;
+  buf->f_ffree = mounts[best_idx].free_inodes;
+  buf->f_favail = mounts[best_idx].free_inodes_user;
+  buf->f_fsid = 0;  /* Ironclad doesn't provide fsid */
+  buf->f_flag = mounts[best_idx].flags;
+  buf->f_namemax = mounts[best_idx].max_filename;
+
+  return 0;
+}
+weak_alias (__statvfs64, statvfs64)
+
+#undef __statvfs
+#undef statvfs
+
+/* Ironclad is 64-bit only, so statvfs/statvfs64 are identical.  */
+strong_alias (__statvfs64, __statvfs)
+weak_alias (__statvfs64, statvfs)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/symlink.c glibc-workdir/sysdeps/unix/sysv/ironclad/symlink.c
new file mode 100644
index 0000000..e2bca13
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/symlink.c
@@ -0,0 +1,14 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+/* Ironclad has no standalone symlink syscall - it uses symlinkat with
+   different argument conventions than Linux.  Route through symlinkat
+   with AT_FDCWD to get proper path length handling.  */
+
+int
+__symlink (const char *target, const char *linkpath)
+{
+  return __symlinkat (target, AT_FDCWD, linkpath);
+}
+weak_alias (__symlink, symlink)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/symlinkat.c glibc-workdir/sysdeps/unix/sysv/ironclad/symlinkat.c
new file mode 100644
index 0000000..9e2f956
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/symlinkat.c
@@ -0,0 +1,27 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Create a symbolic link at LINKPATH relative to FD pointing to TARGET.
+   Ironclad symlink syscall: (dirfd, linkpath, linkpath_len, target, target_len, mode).  */
+
+int
+__symlinkat (const char *target, int fd, const char *linkpath)
+{
+  if (target == NULL || linkpath == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path lengths first to avoid clobbering later arguments.  */
+  size_t linkpath_len = __builtin_strlen (linkpath);
+  size_t target_len = __builtin_strlen (target);
+  /* Ironclad syscall is named 'symlink' not 'symlinkat'.
+     Args: dirfd, linkpath (where to create), linkpath_len, target (what it points to),
+           target_len, mode (permissions, typically ignored for symlinks).  */
+  return INLINE_SYSCALL_CALL (symlink, fd, linkpath, linkpath_len,
+			      target, target_len, 0777);
+}
+weak_alias (__symlinkat, symlinkat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sync.c glibc-workdir/sysdeps/unix/sysv/ironclad/sync.c
new file mode 100644
index 0000000..22fe23c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sync.c
@@ -0,0 +1,8 @@
+#include <unistd.h>
+#include <sysdep.h>
+
+void
+sync (void)
+{
+  INTERNAL_SYSCALL_CALL (sync);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/syncfs.c glibc-workdir/sysdeps/unix/sysv/ironclad/syncfs.c
new file mode 100644
index 0000000..a0682ac
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/syncfs.c
@@ -0,0 +1,19 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+/* Ironclad doesn't have a per-filesystem syncfs syscall.
+   Fall back to sync() which syncs all filesystems.  */
+
+int
+syncfs (int fd)
+{
+  /* Verify fd is valid by checking with fcntl.
+     Use the public fcntl() since we don't need internal variant.  */
+  if (fcntl (fd, F_GETFD) < 0)
+    return -1;  /* errno already set */
+
+  /* Sync all filesystems.  */
+  sync ();
+  return 0;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/mac.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/mac.h
new file mode 100644
index 0000000..3b29dc0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/mac.h
@@ -0,0 +1,128 @@
+#ifndef _SYS_MAC_H
+#define _SYS_MAC_H 1
+
+#include <features.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/* MAC Capability flags.
+   These define what system-level operations a process is allowed to perform.  */
+
+/* Ability to change scheduling parameters.  */
+#define MAC_CAP_SCHED     (1UL << 0)
+
+/* Ability to spawn new processes (fork, exec).  */
+#define MAC_CAP_SPAWN     (1UL << 1)
+
+/* Ability to access entropy sources (getrandom, /dev/random).  */
+#define MAC_CAP_ENTROPY   (1UL << 2)
+
+/* Ability to perform system-level memory operations (e.g., large mappings).  */
+#define MAC_CAP_SYS_MEM   (1UL << 3)
+
+/* Ability to use network sockets.  */
+#define MAC_CAP_USE_NET   (1UL << 4)
+
+/* Ability to configure network interfaces.  */
+#define MAC_CAP_SYS_NET   (1UL << 5)
+
+/* Ability to mount/unmount filesystems.  */
+#define MAC_CAP_SYS_MNT   (1UL << 6)
+
+/* Ability to perform power management (reboot, shutdown).  */
+#define MAC_CAP_SYS_PWR   (1UL << 7)
+
+/* Ability to use ptrace.  */
+#define MAC_CAP_PTRACE    (1UL << 8)
+
+/* Ability to change user ID.  */
+#define MAC_CAP_SETUID    (1UL << 9)
+
+/* Ability to modify MAC settings (meta-capability).  */
+#define MAC_CAP_SYS_MAC   (1UL << 10)
+
+/* Ability to set system clock.  */
+#define MAC_CAP_CLOCK     (1UL << 11)
+
+/* Ability to signal all processes, not just owned ones.  */
+#define MAC_CAP_SIGNALALL (1UL << 12)
+
+/* Ability to change group ID.  */
+#define MAC_CAP_SETGID    (1UL << 13)
+
+/* Ability to use IPC (shared memory, message queues).  */
+#define MAC_CAP_IPC       (1UL << 14)
+
+/* Ability to write to system log.  */
+#define MAC_CAP_SYS_LOG   (1UL << 15)
+
+/* All capabilities (for privileged processes).  */
+#define MAC_CAP_ALL       ((1UL << 16) - 1)
+
+
+/* MAC Permission flags.
+   These define file/path-level access permissions.  */
+
+/* Permission to list directory contents.  */
+#define MAC_PERM_CONTENTS (1 << 0)
+
+/* Permission to read files.  */
+#define MAC_PERM_READ     (1 << 1)
+
+/* Permission to write/modify files.  */
+#define MAC_PERM_WRITE    (1 << 2)
+
+/* Permission to execute files.  */
+#define MAC_PERM_EXEC     (1 << 3)
+
+/* Permission to append to files (write-only at end).  */
+#define MAC_PERM_APPEND   (1 << 4)
+
+/* Permission to use file locking.  */
+#define MAC_PERM_FLOCK    (1 << 5)
+
+/* Permission to access device files.  */
+#define MAC_PERM_DEV      (1 << 6)
+
+/* All permissions.  */
+#define MAC_PERM_ALL      ((1 << 7) - 1)
+
+
+/* MAC Enforcement modes.
+   These define how MAC violations are handled.  */
+
+/* Deny the operation silently.  */
+#define MAC_DENY            (1 << 0)
+
+/* Deny the operation and log to system log.  */
+#define MAC_DENY_AND_SCREAM (1 << 1)
+
+/* Kill the process on MAC violation.  */
+#define MAC_KILL            (1 << 2)
+
+
+/* Get the MAC capabilities of the current process.
+   Returns the capability bitmask, or -1 on error with errno set.  */
+extern unsigned long get_mac_capabilities (void) __THROW;
+
+/* Set the MAC capabilities of the current process.
+   Capabilities can only be dropped, never gained (unless MAC_CAP_SYS_MAC
+   is held).
+   Returns 0 on success, or -1 on error with errno set.  */
+extern int set_mac_capabilities (unsigned long __caps) __THROW;
+
+/* Add MAC permissions for a specific path.
+   PATH is the filesystem path to grant access to.
+   FLAGS is a bitmask of MAC_PERM_* values.
+   Returns 0 on success, or -1 on error with errno set.  */
+extern int add_mac_permissions (const char *__path, int __flags) __THROW;
+
+/* Set the MAC enforcement mode for the current process.
+   ENFORCEMENT is a bitmask of MAC_DENY, MAC_DENY_AND_SCREAM, MAC_KILL.
+   Returns 0 on success, or -1 on error with errno set.  */
+extern int set_mac_enforcement (unsigned long __enforcement) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_MAC_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/mount.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/mount.h
new file mode 100644
index 0000000..829babc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/mount.h
@@ -0,0 +1,36 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Ironclad filesystem types (from kernel userland-syscall.ads).  */
+#define MNT_EXT  1  /* ext2/ext3/ext4 filesystem.  */
+#define MNT_FAT  2  /* FAT filesystem.  */
+#define MNT_DEV  3  /* Device filesystem.  */
+
+/* Ironclad mount flags (from kernel userland-syscall.ads).  */
+#define MS_RDONLY   (1 << 0)  /* Mount read-only.  */
+#define MS_REMOUNT  (1 << 1)  /* Alter flags of a mounted FS.  */
+#define MS_RELATIME (1 << 2)  /* Update atime relative to mtime/ctime.  */
+#define MS_NOATIME  (1 << 3)  /* Do not update access times.  */
+
+/* Unmount flags (from kernel userland-syscall.ads).  */
+#define MNT_FORCE   1  /* Force unmounting.  */
+
+/* Mount a filesystem.
+   SOURCE is the device path.
+   TARGET is the mount point.
+   TYPE is one of MNT_EXT, MNT_FAT, MNT_DEV.
+   FLAGS is a combination of MS_* flags.  */
+extern int mount (const char *__source, const char *__target,
+                  int __type, int __flags) __THROW;
+
+/* Unmount a filesystem.
+   FLAGS can be 0 or MNT_FORCE.  */
+extern int umount (const char *__target, int __flags) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_MOUNT_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/prctl.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/prctl.h
new file mode 100644
index 0000000..a6401e6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/prctl.h
@@ -0,0 +1,22 @@
+#ifndef _SYS_PRCTL_H
+#define _SYS_PRCTL_H	1
+
+#include <features.h>
+
+/* Ironclad does not support prctl - syscall returns ENOSYS.
+   These minimal constants are provided for source compatibility only.
+   Software should have fallback paths when prctl fails.  */
+
+/* Thread name operations - commonly used by pthread implementations.  */
+#define PR_SET_NAME		15
+#define PR_GET_NAME		16
+
+__BEGIN_DECLS
+
+/* Control process execution.
+   Note: Returns ENOSYS on Ironclad - not supported.  */
+extern int prctl (int __option, ...) __THROW;
+
+__END_DECLS
+
+#endif  /* sys/prctl.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/ptrace.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/ptrace.h
new file mode 100644
index 0000000..8e7b67b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/ptrace.h
@@ -0,0 +1,36 @@
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H 1
+
+#include <features.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+/* Ironclad ptrace request values.
+   These match mlibc's abis/ironclad/ptrace.h for ABI compatibility.
+   Note: Ironclad's kernel has limited ptrace support.  */
+enum __ptrace_request
+{
+  PTRACE_PEEKTEXT = 1,
+  PTRACE_PEEKDATA = 2,
+  PTRACE_PEEKUSER = 3,
+  PTRACE_POKETEXT = 4,
+  PTRACE_POKEDATA = 5,
+  PTRACE_CONT     = 7,
+  PTRACE_KILL     = 8,
+  PTRACE_SINGLESTEP = 9,
+  PTRACE_GETREGS  = 14,
+  PTRACE_SETREGS  = 15,
+  PTRACE_ATTACH   = 16,
+  PTRACE_DETACH   = 17,
+  PTRACE_SYSCALL  = 24
+};
+
+/* Perform process tracing functions.
+   REQUEST is one of the PTRACE_* values above.
+   The remaining arguments have request-specific meanings.  */
+extern int ptrace (enum __ptrace_request __request, ...) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/reboot.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/reboot.h
new file mode 100644
index 0000000..6be5cd0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/reboot.h
@@ -0,0 +1,23 @@
+#ifndef _SYS_REBOOT_H
+#define _SYS_REBOOT_H 1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Ironclad reboot command values (from mlibc abis/ironclad/reboot.h).  */
+#define RB_AUTOBOOT      0x01234567  /* Reboot system.  */
+#define RB_HALT_SYSTEM   0xcdef0123  /* Halt system.  */
+#define RB_POWER_OFF     0x4321fedc  /* Power off system.  */
+#define RB_ENABLE_CAD    0x89abcdef  /* Enable Ctrl-Alt-Del.  */
+#define RB_DISABLE_CAD   0           /* Disable Ctrl-Alt-Del.  */
+#define RB_SW_SUSPEND    0xd000fce2  /* Software suspend.  */
+#define RB_KEXEC         0x45584543  /* Kexec reboot.  */
+
+/* Reboot or halt the system.
+   HOWTO specifies one of the RB_* values above.  */
+extern int reboot (int __howto) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_REBOOT_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/reg.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/reg.h
new file mode 100644
index 0000000..973a290
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/reg.h
@@ -0,0 +1,36 @@
+#ifndef _SYS_REG_H
+#define _SYS_REG_H 1
+
+/* Index into an array of 8 byte longs returned from ptrace for
+   location of the users' stored general purpose registers.
+   Ironclad is x86_64 only.  */
+
+#define R15	0
+#define R14	1
+#define R13	2
+#define R12	3
+#define RBP	4
+#define RBX	5
+#define R11	6
+#define R10	7
+#define R9	8
+#define R8	9
+#define RAX	10
+#define RCX	11
+#define RDX	12
+#define RSI	13
+#define RDI	14
+#define ORIG_RAX 15
+#define RIP	16
+#define CS	17
+#define EFLAGS	18
+#define RSP	19
+#define SS	20
+#define FS_BASE 21
+#define GS_BASE 22
+#define DS	23
+#define ES	24
+#define FS	25
+#define GS	26
+
+#endif /* _SYS_REG_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sys/syscall.h glibc-workdir/sysdeps/unix/sysv/ironclad/sys/syscall.h
new file mode 100644
index 0000000..be55f15
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sys/syscall.h
@@ -0,0 +1,9 @@
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/* This file lists the system call numbers for Ironclad.
+   Ironclad uses SYS_* naming convention for syscall numbers.
+   See <arch-syscall.h> for the complete list of syscall definitions.  */
+#include <bits/syscall.h>
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/syscalls.list glibc-workdir/sysdeps/unix/sysv/ironclad/syscalls.list
new file mode 100644
index 0000000..079dc38
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/syscalls.list
@@ -0,0 +1,6 @@
+# File name	Caller	Syscall name	Args	Strong name	Weak names
+
+# Ironclad syscalls.list is intentionally empty.
+# All syscalls are implemented via explicit .c files in sysdeps/unix/sysv/ironclad/
+# The syscalls.list mechanism (make-syscalls.sh) is disabled via inhibit-unix-syscalls
+# in the Makefile.
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sysdep-cancel.h glibc-workdir/sysdeps/unix/sysv/ironclad/sysdep-cancel.h
new file mode 100644
index 0000000..d2b44e4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sysdep-cancel.h
@@ -0,0 +1,85 @@
+#ifndef _SYSDEP_CANCEL_H
+#define _SYSDEP_CANCEL_H
+
+#include <sysdep.h>
+
+/* SINGLE_THREAD_P and RTLD_SINGLE_THREAD_P are defined in sysdep.h */
+
+/* Override SYSCALL_CANCEL macros to use SYS_##name instead of __NR_##name.
+   These are defined in sysdeps/unix/sysdep.h with __NR_##name,
+   but Ironclad uses SYS_* as the primary syscall number constants.
+   Must be placed AFTER #include <sysdep.h> to override unix/sysdep.h.  */
+
+#undef __SYSCALL_CANCEL0
+#undef __SYSCALL_CANCEL1
+#undef __SYSCALL_CANCEL2
+#undef __SYSCALL_CANCEL3
+#undef __SYSCALL_CANCEL4
+#undef __SYSCALL_CANCEL5
+#undef __SYSCALL_CANCEL6
+#undef __SYSCALL_CANCEL7
+
+#define __SYSCALL_CANCEL0(name)						\
+  __syscall_cancel (0, 0, 0, 0, 0, 0, __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __SYSCALL_CANCEL1(name, a1)					\
+  __syscall_cancel (__SSC (a1), 0, 0, 0, 0, 0,				\
+		    __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __SYSCALL_CANCEL2(name, a1, a2)					\
+  __syscall_cancel (__SSC (a1), __SSC (a2), 0, 0, 0, 0,			\
+		    __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __SYSCALL_CANCEL3(name, a1, a2, a3)				\
+  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3), 0, 0, 0,	\
+		    __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __SYSCALL_CANCEL4(name, a1, a2, a3, a4)				\
+  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3),			\
+		    __SSC(a4), 0, 0, __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __SYSCALL_CANCEL5(name, a1, a2, a3, a4, a5)			\
+  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3), __SSC (a4),	\
+		    __SSC (a5), 0, __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __SYSCALL_CANCEL6(name, a1, a2, a3, a4, a5, a6)			\
+  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3), __SSC (a4),	\
+		    __SSC (a5), __SSC (a6), __SYSCALL_CANCEL7_ARG	\
+		    SYS_##name)
+#define __SYSCALL_CANCEL7(name, a1, a2, a3, a4, a5, a6, a7)		\
+  __syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3), __SSC (a4),	\
+		    __SSC (a5), __SSC (a6), __SSC (a7), SYS_##name)
+
+#undef __INTERNAL_SYSCALL_CANCEL0
+#undef __INTERNAL_SYSCALL_CANCEL1
+#undef __INTERNAL_SYSCALL_CANCEL2
+#undef __INTERNAL_SYSCALL_CANCEL3
+#undef __INTERNAL_SYSCALL_CANCEL4
+#undef __INTERNAL_SYSCALL_CANCEL5
+#undef __INTERNAL_SYSCALL_CANCEL6
+#undef __INTERNAL_SYSCALL_CANCEL7
+
+#define __INTERNAL_SYSCALL_CANCEL0(name)				\
+  __internal_syscall_cancel (0, 0, 0, 0, 0, 0, __SYSCALL_CANCEL7_ARG	\
+			     SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL1(name, a1)				\
+  __internal_syscall_cancel (__SSC (a1), 0, 0, 0, 0, 0,			\
+			     __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL2(name, a1, a2)			\
+  __internal_syscall_cancel (__SSC (a1), __SSC (a2), 0, 0, 0, 0,	\
+			     __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL3(name, a1, a2, a3)			\
+  __internal_syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3),	\
+			     0, 0, __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL4(name, a1, a2, a3, a4)		\
+  __internal_syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3),	\
+			     __SSC (a4), 0, 0,				\
+			     __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL5(name, a1, a2, a3, a4, a5)		\
+  __internal_syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3),	\
+			     __SSC (a4), __SSC (a5), 0,			\
+			     __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL6(name, a1, a2, a3, a4, a5, a6)	\
+  __internal_syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3),	\
+			     __SSC (a4), __SSC (a5), __SSC (a6),	\
+			     __SYSCALL_CANCEL7_ARG SYS_##name)
+#define __INTERNAL_SYSCALL_CANCEL7(name, a1, a2, a3, a4, a5, a6, a7)	\
+  __internal_syscall_cancel (__SSC (a1), __SSC (a2), __SSC (a3),	\
+			     __SSC (a4), __SSC (a5), __SSC (a6),	\
+			     __SSC (a7), SYS_##name)
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/sysdep.h glibc-workdir/sysdeps/unix/sysv/ironclad/sysdep.h
new file mode 100644
index 0000000..e0633b2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/sysdep.h
@@ -0,0 +1,98 @@
+#ifndef _SYSDEP_IRONCLAD_H
+#define _SYSDEP_IRONCLAD_H
+
+#include <bits/wordsize.h>
+#include <kernel-features.h>
+#include <endian.h>
+#include <errno.h>
+#include <arch-syscall.h>
+
+/* Ironclad returns errno in a separate register (rdx on x86_64),
+   not encoded in the return value like Linux does.  The syscall
+   returns the actual result in rax and the error code in rdx.
+   If rdx is non-zero, there was an error.
+
+   To maintain compatibility with generic glibc code that expects
+   Linux-style error returns, INTERNAL_SYSCALL_NCS returns -errno
+   when there's an error (errno in rdx is non-zero).  This allows
+   INTERNAL_SYSCALL_ERROR_P to check for negative values.  */
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val) \
+  ((long int) (val) < 0)
+
+#ifndef SYSCALL_ERROR_LABEL
+# define SYSCALL_ERROR_LABEL(sc_err)					\
+  ({									\
+    __set_errno (sc_err);						\
+    -1L;								\
+  })
+#endif
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  It sets the errno and returns -1 on a failure, or the syscall
+   return value otherwise.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({									\
+    unsigned long int _sc_err;						\
+    long int sc_ret = INTERNAL_SYSCALL_NCS_ERR (SYS_##name, _sc_err, nr, ##args); \
+    __glibc_unlikely (_sc_err != 0)					\
+    ? SYSCALL_ERROR_LABEL (_sc_err)					\
+    : sc_ret;								\
+  })
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val)     (-(val))
+
+/* Set error number and return -1.  */
+#define INLINE_SYSCALL_ERROR_RETURN_VALUE(err)  \
+  ({						\
+    __set_errno (err);				\
+    -1l;					\
+  })
+
+/* Provide a dummy argument that can be used to force register
+   alignment for register pairs if required by the syscall ABI.  */
+#ifdef __ASSUME_ALIGNED_REGISTER_PAIRS
+#define __ALIGNMENT_ARG 0,
+#define __ALIGNMENT_COUNT(a,b) b
+#else
+#define __ALIGNMENT_ARG
+#define __ALIGNMENT_COUNT(a,b) a
+#endif
+
+/* Provide a common macro to pass 64-bit value on syscalls.  */
+#if __WORDSIZE == 64 || defined __ASSUME_WORDSIZE64_ILP32
+# define SYSCALL_LL(val)   (val)
+# define SYSCALL_LL64(val) (val)
+#else
+#define SYSCALL_LL(val)   \
+  __LONG_LONG_PAIR ((val) >> 31, (val))
+#define SYSCALL_LL64(val) \
+  __LONG_LONG_PAIR ((long) ((val) >> 32), (long) ((val) & 0xffffffff))
+#endif
+
+/* Provide a common macro to pass 64-bit value on pread and pwrite
+   syscalls.  */
+#ifdef __ASSUME_PRW_DUMMY_ARG
+# define SYSCALL_LL_PRW(val)   0, SYSCALL_LL (val)
+# define SYSCALL_LL64_PRW(val) 0, SYSCALL_LL64 (val)
+#else
+# define SYSCALL_LL_PRW(val)   __ALIGNMENT_ARG SYSCALL_LL (val)
+# define SYSCALL_LL64_PRW(val) __ALIGNMENT_ARG SYSCALL_LL64 (val)
+#endif
+
+/* Provide a macro to pass the off{64}_t argument on p{readv,writev}{64}.  */
+#define LO_HI_LONG(val) \
+ (long) (val), \
+ (long) (((uint64_t) (val)) >> 32)
+
+/* Export the ___brk_addr symbol on brk.c implementation.  */
+#define HAVE_INTERNAL_BRK_ADDR_SYMBOL   0
+
+/* NOTE: SYSCALL_CANCEL macros that use SYS_##name instead of __NR_##name
+   are defined in sysdep-cancel.h, which is included AFTER unix/sysdep.h
+   so that they properly override the __NR_##name versions.  */
+
+#endif /* _SYSDEP_IRONCLAD_H  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcdrain.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcdrain.c
new file mode 100644
index 0000000..0124fde
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcdrain.c
@@ -0,0 +1,15 @@
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sysdep-cancel.h>
+
+#define TCSBRK 0x5409
+
+/* Wait for pending output to be written on FD.  */
+int
+__tcdrain (int fd)
+{
+  /* TCSBRK with arg 1 is defined to wait for output to drain.  */
+  return SYSCALL_CANCEL (ioctl, fd, TCSBRK, 1);
+}
+weak_alias (__tcdrain, tcdrain)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcflow.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcflow.c
new file mode 100644
index 0000000..611c934
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcflow.c
@@ -0,0 +1,12 @@
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+
+#define TCXONC 0x540A
+
+/* Suspend or restart transmission on FD.  */
+int
+tcflow (int fd, int action)
+{
+  return __ioctl (fd, TCXONC, action);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcflush.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcflush.c
new file mode 100644
index 0000000..7984d59
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcflush.c
@@ -0,0 +1,12 @@
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+
+#define TCFLSH 0x540B
+
+/* Flush pending data on FD.  */
+int
+tcflush (int fd, int queue_selector)
+{
+  return __ioctl (fd, TCFLSH, queue_selector);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcgetattr.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcgetattr.c
new file mode 100644
index 0000000..a4d165c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcgetattr.c
@@ -0,0 +1,15 @@
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+
+/* Ironclad uses the same TCGETS ioctl as Linux (0x5401).  */
+#define TCGETS 0x5401
+
+/* Put the state of FD into *TERMIOS_P.  */
+int
+__tcgetattr (int fd, struct termios *termios_p)
+{
+  return __ioctl (fd, TCGETS, termios_p);
+}
+libc_hidden_def (__tcgetattr)
+weak_alias (__tcgetattr, tcgetattr)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcgetpgrp.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcgetpgrp.c
new file mode 100644
index 0000000..d899fc7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcgetpgrp.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/bsd/tcgetpgrp.c>
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcsendbrk.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcsendbrk.c
new file mode 100644
index 0000000..2c20adb
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcsendbrk.c
@@ -0,0 +1,14 @@
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+
+#define TCSBRKP 0x5425
+
+/* Send zero bits on FD.  */
+int
+tcsendbreak (int fd, int duration)
+{
+  /* TCSBRKP is the SVR4/POSIX tcsendbreak ioctl.  The duration is
+     in deciseconds (tenths of a second).  */
+  return __ioctl (fd, TCSBRKP, duration);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcsetattr.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcsetattr.c
new file mode 100644
index 0000000..3f755bc
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcsetattr.c
@@ -0,0 +1,30 @@
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+
+/* Ironclad uses Linux-style TCSETS/TCSETSW/TCSETSF ioctls,
+   not BSD-style TIOCSETA/TIOCSETAW/TIOCSETAF.  */
+
+/* Set the state of FD to *TERMIOS_P.  */
+int
+__tcsetattr (int fd, int optional_actions, const struct termios *termios_p)
+{
+  switch (optional_actions)
+    {
+    case TCSANOW:
+      return __ioctl (fd, TCSETS, termios_p);
+
+    case TCSADRAIN:
+      return __ioctl (fd, TCSETSW, termios_p);
+
+    case TCSAFLUSH:
+      return __ioctl (fd, TCSETSF, termios_p);
+
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+libc_hidden_def (__tcsetattr)
+weak_alias (__tcsetattr, tcsetattr)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tcsetpgrp.c glibc-workdir/sysdeps/unix/sysv/ironclad/tcsetpgrp.c
new file mode 100644
index 0000000..e4d4833
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tcsetpgrp.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/bsd/tcsetpgrp.c>
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/telldir.c glibc-workdir/sysdeps/unix/sysv/ironclad/telldir.c
new file mode 100644
index 0000000..a8a6df0
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/telldir.c
@@ -0,0 +1,15 @@
+#include <dirent.h>
+#include <dirstream.h>
+
+/* Return the current position of DIRP.  */
+long int
+telldir (DIR *dirp)
+{
+  long int ret;
+
+  __libc_lock_lock (dirp->lock);
+  ret = dirp->filepos;
+  __libc_lock_unlock (dirp->lock);
+
+  return ret;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tgkill.c glibc-workdir/sysdeps/unix/sysv/ironclad/tgkill.c
new file mode 100644
index 0000000..575540b
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tgkill.c
@@ -0,0 +1,15 @@
+#include <signal.h>
+#include <sysdep.h>
+
+/* Ironclad doesn't distinguish between tgkill and kill - the tid argument
+   is effectively ignored and the signal is sent to the process.  This is
+   consistent with mlibc's implementation for Ironclad.  */
+int
+__tgkill (pid_t tgid, pid_t tid, int sig)
+{
+  /* On Ironclad, we just use kill since it doesn't have true thread-directed
+     signals.  The tgid is used as the target.  */
+  (void) tid;  /* Unused on Ironclad */
+  return INLINE_SYSCALL_CALL (send_signal, tgid, sig);
+}
+weak_alias (__tgkill, tgkill)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/timer_create.c glibc-workdir/sysdeps/unix/sysv/ironclad/timer_create.c
new file mode 100644
index 0000000..34ecb0d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/timer_create.c
@@ -0,0 +1,21 @@
+/* Ironclad does not support POSIX timers.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include "kernel-posix-timers.h"
+#include <shlib-compat.h>
+
+int
+___timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+versioned_symbol (libc, ___timer_create, timer_create, GLIBC_2_34);
+libc_hidden_ver (___timer_create, __timer_create)
+
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (librt, ___timer_create, timer_create, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/timer_delete.c glibc-workdir/sysdeps/unix/sysv/ironclad/timer_delete.c
new file mode 100644
index 0000000..9157a03
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/timer_delete.c
@@ -0,0 +1,20 @@
+/* Ironclad does not support POSIX timers.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <time.h>
+#include "kernel-posix-timers.h"
+#include <shlib-compat.h>
+
+int
+___timer_delete (timer_t timerid)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+versioned_symbol (libc, ___timer_delete, timer_delete, GLIBC_2_34);
+libc_hidden_ver (___timer_delete, __timer_delete)
+
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (librt, ___timer_delete, timer_delete, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/timer_getoverr.c glibc-workdir/sysdeps/unix/sysv/ironclad/timer_getoverr.c
new file mode 100644
index 0000000..6a11120
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/timer_getoverr.c
@@ -0,0 +1,20 @@
+/* Ironclad does not support POSIX timers.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <time.h>
+#include "kernel-posix-timers.h"
+#include <shlib-compat.h>
+
+int
+___timer_getoverrun (timer_t timerid)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+versioned_symbol (libc, ___timer_getoverrun, timer_getoverrun, GLIBC_2_34);
+libc_hidden_ver (___timer_getoverrun, __timer_getoverrun)
+
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (librt, ___timer_getoverrun, timer_getoverrun, GLIBC_2_2);
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/timer_gettime.c glibc-workdir/sysdeps/unix/sysv/ironclad/timer_gettime.c
new file mode 100644
index 0000000..d993cf4
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/timer_gettime.c
@@ -0,0 +1,29 @@
+/* Ironclad does not support POSIX timers.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <time.h>
+#include "kernel-posix-timers.h"
+#include <shlib-compat.h>
+
+int
+___timer_gettime64 (timer_t timerid, struct __itimerspec64 *value)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+versioned_symbol (libc, ___timer_gettime64, timer_gettime, GLIBC_2_34);
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (librt, ___timer_gettime64, timer_gettime, GLIBC_2_2);
+#endif
+
+/* 32-bit time compat - just call the 64-bit version.  */
+#if __TIMESIZE != 64
+int
+__timer_gettime (timer_t timerid, struct itimerspec *value)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/timer_routines.c glibc-workdir/sysdeps/unix/sysv/ironclad/timer_routines.c
new file mode 100644
index 0000000..847fc09
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/timer_routines.c
@@ -0,0 +1,137 @@
+#include <errno.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <sysdep-cancel.h>
+#include <pthreadP.h>
+#include "kernel-posix-timers.h"
+
+
+/* List of active SIGEV_THREAD timers.  */
+struct timer *__timer_active_sigev_thread;
+
+/* Lock for _timer_active_sigev_thread.  */
+pthread_mutex_t __timer_active_sigev_thread_lock = PTHREAD_MUTEX_INITIALIZER;
+
+struct thread_start_data
+{
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+};
+
+
+/* Helper thread to call the user-provided function.  */
+static void *
+timer_sigev_thread (void *arg)
+{
+  signal_unblock_sigtimer ();
+
+  struct thread_start_data *td = (struct thread_start_data *) arg;
+  void (*thrfunc) (sigval_t) = td->thrfunc;
+  sigval_t sival = td->sival;
+
+  /* The TD object was allocated in timer_helper_thread.  */
+  free (td);
+
+  /* Call the user-provided function.  */
+  thrfunc (sival);
+
+  return NULL;
+}
+
+
+/* Helper function to support starting threads for SIGEV_THREAD.  */
+static _Noreturn void *
+timer_helper_thread (void *arg)
+{
+  /* Endless loop of waiting for signals.  The loop is only ended when
+     the thread is canceled.  */
+  while (1)
+    {
+      siginfo_t si;
+
+      while (__sigwaitinfo (&sigtimer_set, &si) < 0);
+      if (si.si_code == SI_TIMER)
+	{
+	  struct timer *tk = (struct timer *) si.si_ptr;
+
+	  /* Check the timer is still used and will not go away
+	     while we are reading the values here.  */
+	  __pthread_mutex_lock (&__timer_active_sigev_thread_lock);
+
+	  struct timer *runp = __timer_active_sigev_thread;
+	  while (runp != NULL)
+	    if (runp == tk)
+	      break;
+	  else
+	    runp = runp->next;
+
+	  if (runp != NULL)
+	    {
+	      struct thread_start_data *td = malloc (sizeof (*td));
+
+	      /* There is not much we can do if the allocation fails.  */
+	      if (td != NULL)
+		{
+		  /* This is the signal we are waiting for.  */
+		  td->thrfunc = tk->thrfunc;
+		  td->sival = tk->sival;
+
+		  pthread_t th;
+		  __pthread_create (&th, &tk->attr, timer_sigev_thread, td);
+		}
+	    }
+
+	  __pthread_mutex_unlock (&__timer_active_sigev_thread_lock);
+	}
+    }
+}
+
+
+/* Control variable for helper thread creation.  */
+pthread_once_t __timer_helper_once = PTHREAD_ONCE_INIT;
+
+
+/* TID of the helper thread.  */
+pid_t __timer_helper_tid;
+
+
+/* Reset variables so that after a fork a new helper thread gets started.  */
+void
+__timer_fork_subprocess (void)
+{
+  __timer_helper_once = PTHREAD_ONCE_INIT;
+  __timer_helper_tid = 0;
+}
+
+
+void
+__timer_start_helper_thread (void)
+{
+  /* The helper thread needs only very little resources
+     and should go away automatically when canceled.  */
+  pthread_attr_t attr;
+  __pthread_attr_init (&attr);
+  __pthread_attr_setstacksize (&attr, __pthread_get_minstack (&attr));
+
+  /* Block all signals in the helper thread but SIGSETXID.  */
+  sigset_t ss;
+  __sigfillset (&ss);
+  __sigdelset (&ss, SIGSETXID);
+  int res = __pthread_attr_setsigmask_internal (&attr, &ss);
+  if (res != 0)
+    {
+      __pthread_attr_destroy (&attr);
+      return;
+    }
+
+  /* Create the helper thread for this timer.  */
+  pthread_t th;
+  res = __pthread_create (&th, &attr, timer_helper_thread, NULL);
+  if (res == 0)
+    /* We managed to start the helper thread.  */
+    __timer_helper_tid = ((struct pthread *) th)->tid;
+
+  /* No need for the attribute anymore.  */
+  __pthread_attr_destroy (&attr);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/timer_settime.c glibc-workdir/sysdeps/unix/sysv/ironclad/timer_settime.c
new file mode 100644
index 0000000..990877f
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/timer_settime.c
@@ -0,0 +1,33 @@
+/* Ironclad does not support POSIX timers.  This stub returns ENOSYS
+   without issuing any syscall to the kernel.  */
+
+#include <errno.h>
+#include <time.h>
+#include "kernel-posix-timers.h"
+#include <shlib-compat.h>
+
+int
+___timer_settime64 (timer_t timerid, int flags,
+                    const struct __itimerspec64 *value,
+                    struct __itimerspec64 *ovalue)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+
+versioned_symbol (libc, ___timer_settime64, timer_settime, GLIBC_2_34);
+#if OTHER_SHLIB_COMPAT (librt, GLIBC_2_2, GLIBC_2_34)
+compat_symbol (librt, ___timer_settime64, timer_settime, GLIBC_2_2);
+#endif
+
+/* 32-bit time compat - just call the 64-bit version.  */
+#if __TIMESIZE != 64
+int
+__timer_settime (timer_t timerid, int flags,
+                 const struct itimerspec *value,
+                 struct itimerspec *ovalue)
+{
+  __set_errno (ENOSYS);
+  return -1;
+}
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/times.c glibc-workdir/sysdeps/unix/sysv/ironclad/times.c
new file mode 100644
index 0000000..ac23600
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/times.c
@@ -0,0 +1,47 @@
+#include <errno.h>
+#include <sys/times.h>
+#include <sys/resource.h>
+#include <time.h>
+#include <unistd.h>
+
+/* Convert timeval to clock ticks.  */
+static inline clock_t
+timeval_to_clock (struct timeval *tv)
+{
+  long clk_tck = sysconf (_SC_CLK_TCK);
+  if (clk_tck <= 0)
+    clk_tck = 100;  /* Default to 100 Hz if sysconf fails.  */
+  return (clock_t) (tv->tv_sec * clk_tck + tv->tv_usec * clk_tck / 1000000);
+}
+
+clock_t
+__times (struct tms *buf)
+{
+  struct rusage self, children;
+  struct timespec ts;
+
+  if (__getrusage (RUSAGE_SELF, &self) < 0)
+    return (clock_t) -1;
+
+  if (__getrusage (RUSAGE_CHILDREN, &children) < 0)
+    return (clock_t) -1;
+
+  if (buf != NULL)
+    {
+      buf->tms_utime = timeval_to_clock (&self.ru_utime);
+      buf->tms_stime = timeval_to_clock (&self.ru_stime);
+      buf->tms_cutime = timeval_to_clock (&children.ru_utime);
+      buf->tms_cstime = timeval_to_clock (&children.ru_stime);
+    }
+
+  /* Return elapsed real time in clock ticks.  Use CLOCK_MONOTONIC.  */
+  if (__clock_gettime (CLOCK_MONOTONIC, &ts) < 0)
+    return (clock_t) -1;
+
+  long clk_tck = sysconf (_SC_CLK_TCK);
+  if (clk_tck <= 0)
+    clk_tck = 100;
+
+  return (clock_t) (ts.tv_sec * clk_tck + ts.tv_nsec * clk_tck / 1000000000);
+}
+weak_alias (__times, times)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/tls-internal.h glibc-workdir/sysdeps/unix/sysv/ironclad/tls-internal.h
new file mode 100644
index 0000000..a8ed9f9
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/tls-internal.h
@@ -0,0 +1,15 @@
+#ifndef _TLS_INTERNAL_H
+#define _TLS_INTERNAL_H 1
+
+#include <stdlib.h>
+#include <pthreadP.h>
+
+static inline struct tls_internal_t *
+__glibc_tls_internal (void)
+{
+  return &THREAD_SELF->tls_state;
+}
+
+extern void __glibc_tls_internal_free (void) attribute_hidden;
+
+#endif
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/truncate.c glibc-workdir/sysdeps/unix/sysv/ironclad/truncate.c
new file mode 100644
index 0000000..bbcd309
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/truncate.c
@@ -0,0 +1 @@
+/* Ironclad is 64-bit only - truncate is provided by truncate64.c via strong_alias.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/truncate64.c glibc-workdir/sysdeps/unix/sysv/ironclad/truncate64.c
new file mode 100644
index 0000000..69ef0ba
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/truncate64.c
@@ -0,0 +1,29 @@
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+/* Truncate PATH to LENGTH bytes.
+   Ironclad doesn't have a path-based truncate syscall, so we
+   implement it as open + ftruncate + close.  */
+int
+__truncate64 (const char *path, off64_t length)
+{
+  int fd = __open (path, O_WRONLY);
+  if (fd < 0)
+    return -1;
+
+  int ret = __ftruncate64 (fd, length);
+  int save_errno = errno;
+
+  __close (fd);
+
+  if (ret < 0)
+    __set_errno (save_errno);
+
+  return ret;
+}
+weak_alias (__truncate64, truncate64)
+
+/* Ironclad is 64-bit only, so truncate/truncate64 are identical.  */
+strong_alias (__truncate64, __truncate)
+weak_alias (__truncate64, truncate)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ttyname.c glibc-workdir/sysdeps/unix/sysv/ironclad/ttyname.c
new file mode 100644
index 0000000..2ed80c2
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ttyname.c
@@ -0,0 +1,44 @@
+/* Ironclad ttyname implementation.  Uses the ttyname syscall via ttyname_r.
+
+   This is similar to Linux's ttyname.c but uses a smaller buffer size
+   since Ironclad's kernel limits paths to 1024 bytes.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <termios.h>
+#include <stdlib.h>
+#include <set-freeres.h>
+
+/* Ironclad kernel's maximum path/buffer length.  */
+#define IRONCLAD_PATH_MAX_LEN 1024
+
+static char *ttyname_buf = NULL;
+weak_alias (ttyname_buf, __ttyname_freemem_ptr)
+
+/* Return the pathname of the terminal FD is open on, or NULL on errors.
+   The returned storage is good only until the next call to this function.  */
+char *
+ttyname (int fd)
+{
+  /* isatty check, tcgetattr is used because it sets the correct
+     errno (EBADF resp. ENOTTY) on error.  Fast error path to avoid the
+     allocation.  */
+  struct termios term;
+  if (__glibc_unlikely (__tcgetattr (fd, &term) < 0))
+    return NULL;
+
+  if (ttyname_buf == NULL)
+    {
+      ttyname_buf = malloc (IRONCLAD_PATH_MAX_LEN);
+      if (ttyname_buf == NULL)
+	return NULL;
+    }
+
+  int result = __ttyname_r (fd, ttyname_buf, IRONCLAD_PATH_MAX_LEN);
+  if (result != 0)
+    {
+      __set_errno (result);
+      return NULL;
+    }
+  return ttyname_buf;
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/ttyname_r.c glibc-workdir/sysdeps/unix/sysv/ironclad/ttyname_r.c
new file mode 100644
index 0000000..582c3c8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/ttyname_r.c
@@ -0,0 +1,32 @@
+/* Ironclad ttyname_r implementation using the ttyname syscall.
+
+   Note: Ironclad kernel limits buffer size to 1024 bytes (Path_Max_Len).
+   We clamp the buffer size here to avoid ENAMETOOLONG errors.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Ironclad kernel's maximum path/buffer length.  */
+#define IRONCLAD_PATH_MAX_LEN 1024
+
+/* Store at most BUFLEN character of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success, otherwise an error number.  */
+int
+__ttyname_r (int fd, char *buf, size_t buflen)
+{
+  /* Ironclad kernel rejects buffer sizes > 1024.  Clamp to avoid ENAMETOOLONG.
+     TTY names are always short paths (e.g., /dev/pts/0), so this is safe.  */
+  size_t kernel_buflen = buflen > IRONCLAD_PATH_MAX_LEN ? IRONCLAD_PATH_MAX_LEN : buflen;
+
+  int result = INTERNAL_SYSCALL_CALL (ttyname, fd, buf, kernel_buflen);
+  if (INTERNAL_SYSCALL_ERROR_P (result))
+    {
+      int err = INTERNAL_SYSCALL_ERRNO (result);
+      __set_errno (err);
+      return err;
+    }
+  return 0;
+}
+libc_hidden_def (__ttyname_r)
+weak_alias (__ttyname_r, ttyname_r)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/umask.c glibc-workdir/sysdeps/unix/sysv/ironclad/umask.c
new file mode 100644
index 0000000..80935b7
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/umask.c
@@ -0,0 +1,9 @@
+#include <sys/stat.h>
+#include <sysdep.h>
+
+mode_t
+__umask (mode_t mask)
+{
+  return INLINE_SYSCALL_CALL (umask, mask);
+}
+weak_alias (__umask, umask)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/umount.c glibc-workdir/sysdeps/unix/sysv/ironclad/umount.c
new file mode 100644
index 0000000..3a14c96
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/umount.c
@@ -0,0 +1,13 @@
+#include <errno.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sysdep.h>
+
+/* Ironclad native umount interface.
+   Kernel syscall takes: target, target_len, flags.  */
+int
+umount (const char *target, int flags)
+{
+  size_t target_len = strlen (target);
+  return INLINE_SYSCALL_CALL (umount, target, target_len, flags);
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/uname.c glibc-workdir/sysdeps/unix/sysv/ironclad/uname.c
new file mode 100644
index 0000000..f4fb403
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/uname.c
@@ -0,0 +1,11 @@
+#include <sys/utsname.h>
+#include <sysdep.h>
+
+int
+__uname (struct utsname *buf)
+{
+  return INLINE_SYSCALL_CALL (uname, buf);
+}
+weak_alias (__uname, uname)
+libc_hidden_def (__uname)
+libc_hidden_def (uname)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/unlink.c glibc-workdir/sysdeps/unix/sysv/ironclad/unlink.c
new file mode 100644
index 0000000..09562b6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/unlink.c
@@ -0,0 +1,22 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Remove the link named NAME.
+   Ironclad unlink syscall: (dirfd, path, path_len, flags).
+   For unlink(), use AT_FDCWD and flags=0.  */
+
+int
+__unlink (const char *name)
+{
+  if (name == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  size_t path_len = __builtin_strlen (name);
+  return INLINE_SYSCALL_CALL (unlink, AT_FDCWD, name, path_len, 0);
+}
+weak_alias (__unlink, unlink)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/unlinkat.c glibc-workdir/sysdeps/unix/sysv/ironclad/unlinkat.c
new file mode 100644
index 0000000..375c82c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/unlinkat.c
@@ -0,0 +1,23 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Remove the link named NAME relative to FD.
+   Ironclad unlink syscall: (dirfd, path, path_len, flags).  */
+
+int
+__unlinkat (int fd, const char *name, int flag)
+{
+  if (name == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* Compute path_len first to avoid clobbering later arguments.  */
+  size_t path_len = __builtin_strlen (name);
+  /* Ironclad syscall is named 'unlink' not 'unlinkat'.  */
+  return INLINE_SYSCALL_CALL (unlink, fd, name, path_len, flag);
+}
+weak_alias (__unlinkat, unlinkat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/unlockpt.c glibc-workdir/sysdeps/unix/sysv/ironclad/unlockpt.c
new file mode 100644
index 0000000..554c8ba
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/unlockpt.c
@@ -0,0 +1,19 @@
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+
+/* Unlock the slave pseudo terminal associated with the master pseudo
+   terminal specified by FD.  */
+int
+unlockpt (int fd)
+{
+  int unlock = 0;
+
+  int ret = __ioctl (fd, TIOCSPTLCK, &unlock);
+  if (ret != 0 && errno == ENOTTY)
+    /* POSIX mandates EINVAL for non-ptmx descriptors.  */
+    __set_errno (EINVAL);
+  return ret;
+}
+libc_hidden_def (unlockpt)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/utimensat.c glibc-workdir/sysdeps/unix/sysv/ironclad/utimensat.c
new file mode 100644
index 0000000..33eab1e
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/utimensat.c
@@ -0,0 +1,68 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+#include <time.h>
+
+/* Ironclad's utimes syscall signature:
+   utimes(dirfd, pathname, path_len, times, flags)
+   This differs from Linux's utimensat which doesn't have path_len.  */
+
+/* Helper function for the Ironclad utimes syscall.  */
+int
+__utimensat64_helper (int fd, const char *file,
+                      const struct __timespec64 tsp64[2], int flags)
+{
+  const char *path = file;
+  size_t path_len;
+
+  /* Handle NULL file by using empty string with AT_EMPTY_PATH.  */
+  if (file == NULL)
+    {
+      path = "";
+      path_len = 0;
+      flags |= AT_EMPTY_PATH;
+    }
+  else
+    {
+      path_len = strlen (file);
+    }
+
+  /* Handle NULL times by getting current time.
+     Following mlibc: when times is NULL, use current time.  */
+  const struct __timespec64 *times_ptr;
+  struct __timespec64 now_times[2];
+
+  if (tsp64 == NULL)
+    {
+      struct __timespec64 now;
+      if (__clock_gettime64 (CLOCK_REALTIME, &now) != 0)
+        return -1;
+      now_times[0] = now;
+      now_times[1] = now;
+      times_ptr = now_times;
+    }
+  else
+    {
+      times_ptr = tsp64;
+    }
+
+  /* Ironclad's utimes syscall takes 5 arguments:
+     (dirfd, pathname, path_len, times, flags)  */
+  return INLINE_SYSCALL_CALL (utimes, fd, path, path_len, times_ptr, flags);
+}
+libc_hidden_def (__utimensat64_helper)
+
+/* Ironclad is 64-bit only, so utimensat/utimensat64 are identical.
+   On 64-bit systems, __utimensat64 is already a macro for __utimensat.  */
+
+/* Change the access time of FILE to TSP[0] and
+   the modification time of FILE to TSP[1].  */
+int
+__utimensat64 (int fd, const char *file, const struct __timespec64 tsp64[2],
+               int flags)
+{
+  return __utimensat64_helper (fd, file, tsp64, flags);
+}
+weak_alias (__utimensat, utimensat)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/utimes.c glibc-workdir/sysdeps/unix/sysv/ironclad/utimes.c
new file mode 100644
index 0000000..448bc0c
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/utimes.c
@@ -0,0 +1,41 @@
+#include <time.h>
+#include <fcntl.h>
+
+/* Ironclad's utimes syscall requires path_len, so we route through
+   utimensat which handles this correctly.
+
+   On 64-bit systems, __utimes64 is macro-defined to __utimes in
+   include/time.h, so defining __utimes64 here actually defines __utimes.  */
+
+int
+__utimes64 (const char *file, const struct __timeval64 tvp[2])
+{
+  struct __timespec64 ts64[2];
+
+  if (tvp != NULL)
+    {
+      ts64[0] = timeval64_to_timespec64 (tvp[0]);
+      ts64[1] = timeval64_to_timespec64 (tvp[1]);
+    }
+
+  return __utimensat64_helper (AT_FDCWD, file, tvp ? ts64 : NULL, 0);
+}
+
+#if __TIMESIZE != 64
+libc_hidden_def (__utimes64)
+
+int
+__utimes (const char *file, const struct timeval tvp[2])
+{
+  struct __timeval64 tv64[2];
+
+  if (tvp != NULL)
+    {
+      tv64[0] = valid_timeval_to_timeval64 (tvp[0]);
+      tv64[1] = valid_timeval_to_timeval64 (tvp[1]);
+    }
+
+  return __utimes64 (file, tvp ? tv64 : NULL);
+}
+#endif
+weak_alias (__utimes, utimes)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/wait4.c glibc-workdir/sysdeps/unix/sysv/ironclad/wait4.c
new file mode 100644
index 0000000..cfd47ef
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/wait4.c
@@ -0,0 +1,21 @@
+#include <sys/wait.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad's wait syscall (SYSCALL_WAIT) takes only 3 arguments:
+   (pid, status, flags). The rusage parameter is not supported.  */
+
+/* Ironclad is 64-bit only, so wait4/wait4_time64 are identical.
+   On 64-bit systems, __wait4_time64 is already a macro for __wait4.  */
+pid_t
+__wait4_time64 (pid_t pid, int *stat_loc, int options, struct __rusage64 *usage)
+{
+  /* Ironclad doesn't support rusage in wait - ignore it.  */
+  (void) usage;
+
+  /* Ironclad syscall is named 'wait' not 'wait4'.  */
+  return SYSCALL_CANCEL (wait, pid, stat_loc, options);
+}
+libc_hidden_def (__wait4);
+weak_alias (__wait4, wait4)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/write.c glibc-workdir/sysdeps/unix/sysv/ironclad/write.c
new file mode 100644
index 0000000..63453f5
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/write.c
@@ -0,0 +1,17 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+/* Write NBYTES of BUF to FD.  Return the number written, or -1.  */
+ssize_t
+__libc_write (int fd, const void *buf, size_t nbytes)
+{
+  /* Ironclad write syscall takes 5 arguments:
+     fd, buf, count, offset, flag (0=normal write, 1=pwrite).  */
+  return SYSCALL_CANCEL (write, fd, buf, nbytes, 0, 0);
+}
+libc_hidden_def (__libc_write)
+
+weak_alias (__libc_write, __write)
+libc_hidden_weak (__write)
+weak_alias (__libc_write, write)
+libc_hidden_weak (write)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/write_nocancel.c glibc-workdir/sysdeps/unix/sysv/ironclad/write_nocancel.c
new file mode 100644
index 0000000..7287557
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/write_nocancel.c
@@ -0,0 +1,12 @@
+#include <unistd.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+ssize_t
+__write_nocancel (int fd, const void *buf, size_t nbytes)
+{
+  /* Ironclad write syscall takes 5 arguments:
+     fd, buf, count, offset, flag (0=normal write, 1=pwrite).  */
+  return INLINE_SYSCALL_CALL (write, fd, buf, nbytes, 0, 0);
+}
+hidden_def (__write_nocancel)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/writev.c glibc-workdir/sysdeps/unix/sysv/ironclad/writev.c
new file mode 100644
index 0000000..d03d0d3
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/writev.c
@@ -0,0 +1,44 @@
+#include <errno.h>
+#include <unistd.h>
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+
+/* Ironclad has no native writev syscall.  Emulate by calling write
+   for each iovec entry.  This is not atomic but matches mlibc's behavior.  */
+
+ssize_t
+__writev (int fd, const struct iovec *iov, int iovcnt)
+{
+  if (iovcnt < 0)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  ssize_t total = 0;
+  for (int i = 0; i < iovcnt; i++)
+    {
+      if (iov[i].iov_len == 0)
+	continue;
+
+      /* Ironclad write syscall: (fd, buf, count, offset, flag).
+	 Use offset=0 and flag=0 for normal sequential write.  */
+      ssize_t ret = SYSCALL_CANCEL (write, fd, iov[i].iov_base,
+				    iov[i].iov_len, 0, 0);
+      if (ret < 0)
+	{
+	  if (total > 0)
+	    return total;
+	  return ret;
+	}
+      total += ret;
+
+      /* Short write - return what we have.  */
+      if ((size_t) ret < iov[i].iov_len)
+	return total;
+    }
+
+  return total;
+}
+libc_hidden_def (__writev)
+weak_alias (__writev, writev)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/64/arch-syscall.h glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/64/arch-syscall.h
new file mode 100644
index 0000000..2bcbfc9
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/64/arch-syscall.h
@@ -0,0 +1,162 @@
+#ifndef _ARCH_SYSCALL_H
+#define _ARCH_SYSCALL_H
+
+/* Ironclad syscall numbers - matches mlibc sysdeps/ironclad/include/sys/syscall.h exactly.
+   Only real Ironclad syscalls are defined here with their native names.  */
+
+#define SYS_exit                      0
+#define SYS_arch_prctl                1
+#define SYS_open                      2
+#define SYS_close                     3
+#define SYS_read                      4
+#define SYS_write                     5
+#define SYS_seek                      6
+#define SYS_mmap                      7
+#define SYS_munmap                    8
+#define SYS_getpid                    9
+#define SYS_getppid                  10
+#define SYS_exec                     11
+#define SYS_fork                     12
+#define SYS_wait                     13
+#define SYS_socket                   14
+#define SYS_sethostname              15
+#define SYS_unlink                   16
+#define SYS_stat                     17
+#define SYS_pivot_root               18
+#define SYS_chdir                    19
+#define SYS_ioctl                    20
+#define SYS_sched_yield              21
+#define SYS_get_min_prio             22
+#define SYS_pipe                     23
+#define SYS_getuid                   24
+#define SYS_rename                   25
+#define SYS_listprocs                26
+#define SYS_getsid                   27
+#define SYS_gettid                   28
+#define SYS_get_max_prio             29
+#define SYS_fcntl                    30
+#define SYS_exit_thread              31
+#define SYS_getentropy               32
+#define SYS_mprotect                 33
+#define SYS_sync                     34
+#define SYS_set_mac_capabilities     35
+#define SYS_get_mac_capabilities     36
+#define SYS_add_mac_permissions      37
+#define SYS_set_mac_enforcement      38
+#define SYS_mount                    39
+#define SYS_umount                   40
+#define SYS_readlink                 41
+#define SYS_getdents                 42
+#define SYS_makenode                 43
+#define SYS_truncate                 44
+#define SYS_bind                     45
+#define SYS_symlink                  46
+#define SYS_connect                  47
+#define SYS_openpty                  48
+#define SYS_fsync                    49
+#define SYS_link                     50
+#define SYS_ptrace                   51
+#define SYS_listen                   52
+#define SYS_accept                   53
+#define SYS_rlimit                   54
+/* 55 is unused */
+#define SYS_access                   56
+#define SYS_ppoll                    57
+#define SYS_geteuid                  58
+#define SYS_setuids                  59
+#define SYS_fchmod                   60
+#define SYS_umask                    61
+#define SYS_reboot                   62
+#define SYS_fchown                   63
+#define SYS_getpgid                  64
+#define SYS_setpgid                  65
+#define SYS_getsockname              66
+#define SYS_getpeername              67
+#define SYS_shutdown                 68
+#define SYS_futex                    69
+#define SYS_clock                    70
+#define SYS_clock_nanosleep          71
+#define SYS_getrusage                72
+#define SYS_recvfrom                 73
+#define SYS_sendto                   74
+#define SYS_config_netinter          75
+#define SYS_utimes                   76
+#define SYS_get_scheduler            77
+#define SYS_set_scheduler            78
+#define SYS_sigprocmask              79
+#define SYS_sigaction                80
+#define SYS_send_signal              81
+#define SYS_getprio                  82
+#define SYS_setprio                  83
+#define SYS_getgid                   84
+#define SYS_getegid                  85
+#define SYS_setgids                  86
+#define SYS_getgroups                87
+#define SYS_setgroups                88
+#define SYS_ttyname                  89
+#define SYS_fadvise                  90
+#define SYS_shmat                    91
+#define SYS_shmctl                   92
+#define SYS_shmdt                    93
+#define SYS_shmget                   94
+#define SYS_getsockopt               95
+#define SYS_setsockopt               96
+#define SYS_gettidid                 97
+#define SYS_settidid                 98
+#define SYS_failure_policy           99
+#define SYS_create_thread           100
+#define SYS_signal_return           101
+#define SYS_sigaltstack             102
+#define SYS_recvsockctl             103
+#define SYS_listmounts              104
+#define SYS_uname                   105
+#define SYS_listthreads             106
+#define SYS_sendsockctl             107
+#define SYS_listnetinter            108
+#define SYS_dumplogs                109
+#define SYS_listflocks              110
+#define SYS_loadavg                 111
+#define SYS_meminfo                 112
+#define SYS_listpci                 113
+#define SYS_getcpuinfo              114
+#define SYS_socketpair              115
+#define SYS_madvise                 116
+#define SYS_nvmm_capability         117
+#define SYS_nvmm_machine_create     118
+#define SYS_nvmm_machine_del        119
+#define SYS_nvmm_machine_conf       120
+#define SYS_nvmm_vcpu_create        121
+#define SYS_nvmm_vcpu_destroy       122
+#define SYS_nvmm_vcpu_conf          123
+#define SYS_nvmm_vcpu_setstate      124
+#define SYS_nvmm_vcpu_getstate      125
+#define SYS_nvmm_vcpu_inject        126
+#define SYS_nvmm_vcpu_run           127
+#define SYS_nvmm_gpa_map            128
+#define SYS_nvmm_gpa_unmap          129
+#define SYS_nvmm_hva_map            130
+#define SYS_nvmm_hva_unmap          131
+#define SYS_nvmm_gva2gpa            132
+#define SYS_nvmm_gpa2hva            133
+#define SYS_nvmm_assist_io          134
+#define SYS_nvmm_assist_mem         135
+#define SYS_nvmm_vcpu_dump          136
+#define SYS_nvmm_vcpu_stop          137
+#define SYS_setsid                  138
+#define SYS_pci_read                139
+#define SYS_pci_write               140
+
+/* Aliases for Linux syscall names used by generic glibc code.
+   These map to Ironclad equivalents where argument counts match.  */
+
+/* Thread exit - Linux exit_group terminates all threads, Ironclad
+   exit_thread terminates just the current thread (correct for pthread).  */
+#define SYS_exit_group              SYS_exit_thread
+
+/* Scheduler syscall used by nptl/pthread_create.c */
+#define SYS_sched_setscheduler      SYS_set_scheduler
+
+/* __NR_* alias for tls.h which uses __NR_arch_prctl directly in inline asm.  */
+#define __NR_arch_prctl             SYS_arch_prctl
+
+#endif /* _ARCH_SYSCALL_H */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/64/shlib-versions glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/64/shlib-versions
new file mode 100644
index 0000000..d882d52
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/64/shlib-versions
@@ -0,0 +1,4 @@
+# DEFAULT			Earliest symbol set
+# ---------------		------------------------------
+DEFAULT				GLIBC_2.42
+ld=ld-ironclad-x86-64.so.2
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/Implies glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/Implies
new file mode 100644
index 0000000..a1a5f45
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/Implies
@@ -0,0 +1,4 @@
+# x86_64-specific Ironclad sysdeps includes
+unix/sysv/ironclad
+x86_64/nptl
+x86/nptl
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/Versions glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/Versions
new file mode 100644
index 0000000..4877469
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/Versions
@@ -0,0 +1,25 @@
+# Version definitions for Ironclad x86_64.
+# This file ensures historical x86_64 versions are defined even though
+# Ironclad is a new port starting at GLIBC_2.42.  The versions are needed
+# because x86_64 multiarch code uses SHLIB_COMPAT checks for them.
+
+libc {
+  # Historical x86_64 versions (all map to GLIBC_2.42 via firstversions).
+  # These need to exist so ABI_libc_GLIBC_* macros are defined.
+  GLIBC_2.2.5 {
+  }
+  GLIBC_2.3 {
+  }
+  GLIBC_2.3.2 {
+  }
+  GLIBC_2.3.3 {
+  }
+  GLIBC_2.3.4 {
+  }
+  GLIBC_2.4 {
+  }
+  GLIBC_2.13 {
+  }
+  GLIBC_2.14 {
+  }
+}
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/clone.S glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/clone.S
new file mode 100644
index 0000000..7e0445d
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/clone.S
@@ -0,0 +1,125 @@
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <asm-syntax.h>
+
+/* The userland implementation is:
+   int clone (int (*fn)(void *arg), void *child_stack, int flags,
+	      void *arg, pid_t *parent_tid, void *tls, pid_t *child_tid);
+
+   Ironclad's create_thread syscall (100) expects:
+   int create_thread (void (*entry)(void), int unused, void *stack, void *tcb);
+
+   Kernel register mapping:
+   rax: syscall number (100)
+   rdi: entry point
+   rsi: unused (0)
+   rdx: stack
+   r12: tcb/tls
+
+   The parameters are passed in register and on the stack from userland:
+   rdi: fn
+   rsi: child_stack
+   rdx: flags (ignored for Ironclad - we always create threads)
+   rcx: arg
+    r8: parent_tid (ignored)
+    r9: tls
+%rsp+8: child_tid (ignored)  */
+
+
+        .text
+ENTRY (__clone)
+	/* Save r12 - it's callee-saved but we need it for syscall arg 4.  */
+	pushq	%r12
+	cfi_adjust_cfa_offset(8)
+	cfi_rel_offset(%r12, 0)
+
+	/* Sanity check arguments.  */
+	movq	$-EINVAL,%rax
+	testq	%rdi,%rdi		/* no NULL function pointers */
+	jz	L(error_early)
+
+	/* Align stack to 16 bytes per the x86-64 psABI.  */
+	andq	$-16, %rsi
+	jz	L(error_early)		/* no NULL stack pointers */
+
+	/* Insert the argument onto the new stack.  */
+	movq	%rcx,-8(%rsi)
+
+	subq	$16,%rsi
+
+	/* Save the function pointer on the new stack.
+	   It will be popped off in the child.  */
+	movq	%rdi,0(%rsi)
+
+	/* Set up arguments for Ironclad's create_thread syscall:
+	   rdi = entry point (L(thread_start))
+	   rsi = 0 (unused)
+	   rdx = stack
+	   r12 = tls  */
+	leaq	L(thread_start)(%rip), %rdi	/* entry point */
+	movq	%rsi, %rdx			/* stack -> rdx */
+	xorq	%rsi, %rsi			/* unused = 0 */
+	movq	%r9, %r12			/* tls -> r12 */
+
+	movl	$SYS_ify(create_thread),%eax	/* syscall 100 = create_thread */
+
+	/* End FDE now, because in the child the unwind info will be
+	   wrong.  */
+	cfi_endproc;
+	syscall
+
+	/* Ironclad returns error in rdx, not negative rax.  */
+	testq	%rdx, %rdx
+	jnz	L(syscall_error)
+
+	/* Parent path - rax contains the new thread's TID.
+	   Restore r12 and return.  */
+	popq	%r12
+	ret
+
+L(syscall_error):
+	/* Syscall error - restore r12 and jump to error handler.  */
+	popq	%r12
+	jmp	SYSCALL_ERROR_LABEL
+
+	/* Early error handling.  */
+	cfi_startproc;
+	cfi_adjust_cfa_offset(8)
+	cfi_rel_offset(%r12, 0)
+L(error_early):
+	popq	%r12
+	cfi_adjust_cfa_offset(-8)
+	cfi_restore(%r12)
+	jmp	SYSCALL_ERROR_LABEL
+	cfi_endproc;
+
+L(thread_start):
+	/* This is the entry point for the new thread.
+	   The stack has: [rsp] = fn, [rsp+8] = arg
+	   Note: We're in a new thread, don't need to restore r12.  */
+	cfi_startproc;
+	cfi_undefined (rip);
+
+	/* Clear the frame pointer.  */
+	xorl	%ebp, %ebp
+
+	/* Set up arguments for the function call.  */
+	popq	%rax		/* Function to call.  */
+	popq	%rdi		/* Argument.  */
+	call	*%rax
+
+	/* Call exit with return value from function call.  */
+	movq	%rax, %rdi
+	movl	$SYS_ify(exit), %eax
+	syscall
+	cfi_endproc;
+
+	cfi_startproc;
+PSEUDO_END (__clone)
+
+libc_hidden_def (__clone)
+weak_alias (__clone, clone)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/dl-cet.h glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/dl-cet.h
new file mode 100644
index 0000000..86d95d8
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/dl-cet.h
@@ -0,0 +1,34 @@
+/* CET (Control-flow Enforcement Technology) is not supported on Ironclad.
+   These are stub implementations that report CET as unavailable.  */
+
+#include <stdbool.h>
+
+static __always_inline int
+dl_cet_disable_cet (unsigned int cet_feature __attribute__ ((unused)))
+{
+  return -1;
+}
+
+static __always_inline int
+dl_cet_lock_cet (unsigned int cet_feature __attribute__ ((unused)))
+{
+  return -1;
+}
+
+static __always_inline unsigned int
+dl_cet_get_cet_status (void)
+{
+  return 0;
+}
+
+static __always_inline bool
+dl_cet_ibt_enabled (void)
+{
+  return false;
+}
+
+/* Enable shadow stack - no-op on Ironclad.  */
+#define ENABLE_X86_CET(cet_feature) /* nothing */
+
+/* No CET setup needed for dynamic linker startup on Ironclad.  */
+#define RTLD_START_ENABLE_X86_FEATURES ""
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/dl-sysdep.c glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/dl-sysdep.c
new file mode 100644
index 0000000..37c308a
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/dl-sysdep.c
@@ -0,0 +1,3 @@
+#include <config.h>
+#include <sysdeps/x86/cpu-tunables.c>
+#include <sysdeps/unix/sysv/ironclad/dl-sysdep.c>
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/multiarch/memmove-shlib-compat.h glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/multiarch/memmove-shlib-compat.h
new file mode 100644
index 0000000..8988833
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/multiarch/memmove-shlib-compat.h
@@ -0,0 +1,6 @@
+/* Ironclad is a new port starting at GLIBC_2.42, so we don't need
+   backward compatibility symbols for GLIBC_2.2.5 memcpy/memmove.
+   This file overrides sysdeps/x86_64/multiarch/memmove-shlib-compat.h
+   to avoid checking for versions that don't exist on Ironclad.  */
+
+/* No compat symbols needed.  */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/stackinfo.h glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/stackinfo.h
new file mode 100644
index 0000000..04c60f9
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/stackinfo.h
@@ -0,0 +1,36 @@
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+#ifdef __ILP32__
+# define RSP_REG "esp"
+#else
+# define RSP_REG "rsp"
+#endif
+
+/* On x86_64 the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Ironclad does not need legacy binary compatibility, so default to a
+   non-executable stack.  This prevents errors when loading shared objects
+   that lack a PT_GNU_STACK segment (which would otherwise be assumed to
+   require an executable stack).  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W)
+
+/* Access to the stack pointer.  The macros are used in alloca_account
+   for which they need to act as barriers as well, hence the additional
+   (unnecessary) parameters.  */
+#define stackinfo_get_sp() \
+  ({ register void * p__ __asm__(RSP_REG); \
+     asm volatile("" : "=r" (p__)); \
+     p__; })
+#define stackinfo_sub_sp(ptr) \
+  ({ ptrdiff_t d__;						\
+     asm volatile ("sub %%" RSP_REG " , %0" : "=r" (d__) : "0" (ptr));	\
+     d__; })
+
+#endif	/* stackinfo.h */
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/syscall.S glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/syscall.S
new file mode 100644
index 0000000..1becfbf
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/syscall.S
@@ -0,0 +1,42 @@
+#include <sysdep.h>
+
+/* Ironclad syscall() implementation for x86-64.
+
+   Ironclad syscall ABI:
+   - syscall number in rax
+   - arg 1 in rdi
+   - arg 2 in rsi
+   - arg 3 in rdx
+   - arg 4 in r12 (NOTE: Linux uses r10)
+   - arg 5 in r8
+   - arg 6 in r9
+   - return value in rax
+   - error code in rdx (0 = success)
+
+   Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)
+   We need to do some arg shifting, the syscall_number will be in rax.
+
+   IMPORTANT: r12 is a callee-saved register in the x86_64 ABI.
+   We must save and restore it since we use it for arg4.  */
+
+	.text
+ENTRY (syscall)
+	pushq %r12		/* Save r12 (callee-saved register).  */
+	cfi_adjust_cfa_offset(8)
+	cfi_rel_offset(%r12, 0)
+	movq %rdi, %rax		/* Syscall number -> rax.  */
+	movq %rsi, %rdi		/* shift arg1 - arg5.  */
+	movq %rdx, %rsi
+	movq %rcx, %rdx
+	movq %r8, %r12		/* NOTE: Ironclad uses r12 for arg4, not r10!  */
+	movq %r9, %r8
+	movq 16(%rsp),%r9	/* arg6 is on the stack (offset adjusted for push).  */
+	syscall			/* Do the system call.  */
+	popq %r12		/* Restore r12.  */
+	cfi_adjust_cfa_offset(-8)
+	cfi_restore(%r12)
+	testq %rdx, %rdx	/* Check error code in rdx.  */
+	jnz SYSCALL_ERROR_LABEL	/* Jump to error handler if error.  */
+	ret			/* Return to caller.  */
+
+PSEUDO_END (syscall)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/syscall_cancel.S glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/syscall_cancel.S
new file mode 100644
index 0000000..7f10086
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/syscall_cancel.S
@@ -0,0 +1,60 @@
+#include <sysdep.h>
+#include <descr-const.h>
+
+/* long int [rax] __syscall_cancel_arch (volatile int *cancelhandling [%rdi],
+					 __syscall_arg_t nr   [%rsi],
+					 __syscall_arg_t arg1 [%rdx],
+					 __syscall_arg_t arg2 [%rcx],
+					 __syscall_arg_t arg3 [%r8],
+					 __syscall_arg_t arg4 [%r9],
+					 __syscall_arg_t arg5 [SP+8],
+					 __syscall_arg_t arg6 [SP+16])
+
+   Ironclad syscall convention:
+     arg1: rdi
+     arg2: rsi
+     arg3: rdx
+     arg4: r12 (NOT r10 like Linux!)
+     arg5: r8
+     arg6: r9
+     syscall number: rax
+     return: rax (result), rdx (0 on success, errno on failure)  */
+
+ENTRY (__syscall_cancel_arch)
+	.globl __syscall_cancel_arch_start
+__syscall_cancel_arch_start:
+
+	/* if (*cancelhandling & CANCELED_BITMASK)
+	     __syscall_do_cancel()  */
+	mov    (%rdi),%eax
+	testb  $TCB_CANCELED_BITMASK, (%rdi)
+	jne    __syscall_do_cancel
+
+	/* Save r12 (callee-saved register) since Ironclad uses it for arg4.  */
+	pushq  %r12
+	cfi_adjust_cfa_offset(8)
+	cfi_rel_offset(%r12, 0)
+
+	/* Issue a 6 argument syscall for Ironclad.
+	   Input:  nr=%rsi, arg1=%rdx, arg2=%rcx, arg3=%r8, arg4=%r9,
+	           arg5=16(%rsp), arg6=24(%rsp) (offsets adjusted for push)
+	   Syscall: rax=nr, rdi=arg1, rsi=arg2, rdx=arg3, r12=arg4,
+	            r8=arg5, r9=arg6  */
+	mov    %rsi,%rax	/* Syscall number.  */
+	mov    %rdx,%rdi	/* arg1 -> rdi.  */
+	mov    %rcx,%rsi	/* arg2 -> rsi.  */
+	mov    %r8,%rdx		/* arg3 -> rdx.  */
+	mov    %r9,%r12		/* arg4 -> r12 (Ironclad uses r12, not r10!).  */
+	mov    16(%rsp),%r8	/* arg5 -> r8 (adjusted for push).  */
+	mov    24(%rsp),%r9	/* arg6 -> r9 (adjusted for push).  */
+	syscall
+
+	/* Restore r12.  */
+	popq   %r12
+	cfi_adjust_cfa_offset(-8)
+	cfi_restore(%r12)
+
+	.globl __syscall_cancel_arch_end
+__syscall_cancel_arch_end:
+	ret
+END (__syscall_cancel_arch)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/sysdep.S glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/sysdep.S
new file mode 100644
index 0000000..ca662fe
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/sysdep.S
@@ -0,0 +1,28 @@
+#include <sysdep.h>
+#include <errno.h>
+#include <tls.h>
+
+#if IS_IN (rtld)
+# include <dl-sysdep.h>		/* Defines RTLD_PRIVATE_ERRNO.  */
+#endif
+
+.globl C_SYMBOL_NAME(errno)
+.globl syscall_error
+
+/* Ironclad syscall error handling.
+   On Ironclad, the syscall error code is already in %eax when we get here
+   (it was moved from %rdx by the calling code).  */
+
+	.text
+ENTRY(__syscall_error)
+#ifdef PIC
+	movq C_SYMBOL_NAME(errno@GOTTPOFF)(%rip), %rcx
+	movl %eax, %fs:0(%rcx)
+#else
+	movl %eax, %fs:C_SYMBOL_NAME(errno@TPOFF)
+#endif
+	or $-1, %RAX_LP
+	ret
+END (__syscall_error)
+
+libc_hidden_def (__syscall_error)
diff --git glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/sysdep.h glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/sysdep.h
new file mode 100644
index 0000000..f55cdf6
--- /dev/null
+++ glibc-workdir/sysdeps/unix/sysv/ironclad/x86_64/sysdep.h
@@ -0,0 +1,537 @@
+#ifndef _IRONCLAD_X86_64_SYSDEP_H
+#define _IRONCLAD_X86_64_SYSDEP_H 1
+
+#include <sysdeps/unix/sysv/ironclad/sysdep.h>
+#include <sysdeps/unix/x86_64/sysdep.h>
+#include <sysdeps/x86_64/sysdep.h>
+#include <tls.h>
+
+/* Defines RTLD_PRIVATE_ERRNO.  */
+#include <dl-sysdep.h>
+
+/* SYS_ify macro to create syscall number from name.
+   On Ironclad, syscall constants are named SYS_* directly.  */
+#undef SYS_ify
+#define SYS_ify(syscall_name)	SYS_##syscall_name
+
+#ifdef __ASSEMBLER__
+
+/* Ironclad x86_64 syscall ABI:
+
+   syscall number  rax
+   arg 1           rdi
+   arg 2           rsi
+   arg 3           rdx
+   arg 4           r12   (NOTE: Linux uses r10)
+   arg 5           r8
+   arg 6           r9
+
+   Return:
+   result          rax
+   errno           rdx   (0 if no error, otherwise error code)
+
+   Clobbered:
+   rcx (return address)
+   r11 (eflags)
+*/
+
+# undef SYSCALL_ERROR_LABEL
+# ifdef PIC
+#  define SYSCALL_ERROR_LABEL 0f
+# else
+#  define SYSCALL_ERROR_LABEL syscall_error
+# endif
+
+/* PSEUDO macros for assembly syscalls.  */
+# undef	PSEUDO
+# define PSEUDO(name, syscall_name, args) \
+  .text;							      \
+  ENTRY (name)							      \
+    DO_CALL (syscall_name, args);				      \
+    testq %rdx, %rdx;						      \
+    jnz SYSCALL_ERROR_LABEL
+
+# undef	PSEUDO_END
+# define PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+# undef	PSEUDO_NOERRNO
+# define PSEUDO_NOERRNO(name, syscall_name, args) \
+  .text;							      \
+  ENTRY (name)							      \
+    DO_CALL (syscall_name, args)
+
+# undef	PSEUDO_END_NOERRNO
+# define PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+# define ret_NOERRNO ret
+
+# undef	PSEUDO_ERRVAL
+# define PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;							\
+  ENTRY (name)							\
+    DO_CALL (syscall_name, args);				\
+    movq %rdx, %rax
+
+# undef	PSEUDO_END_ERRVAL
+# define PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+# define ret_ERRVAL ret
+
+# if defined PIC && RTLD_PRIVATE_ERRNO
+#  define SYSCALL_SET_ERRNO			\
+  lea rtld_errno(%rip), %rcx;			\
+  movl %edx, (%rcx)
+# else
+#  if IS_IN (libc)
+#   define SYSCALL_ERROR_ERRNO __libc_errno
+#  else
+#   define SYSCALL_ERROR_ERRNO errno
+#  endif
+#  define SYSCALL_SET_ERRNO			\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  movl %edx, %fs:(%rcx);
+# endif
+
+# ifndef PIC
+#  define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+# else
+#  define SYSCALL_ERROR_HANDLER			\
+0:						\
+  SYSCALL_SET_ERRNO;				\
+  or $-1, %RAX_LP;				\
+  ret;
+# endif
+
+/* DO_CALL macro - Ironclad uses r12 for 4th argument instead of r10.
+   IMPORTANT: r12 is callee-saved, so we must save/restore it for 4+ arg syscalls.  */
+# undef	DO_CALL
+# define DO_CALL(syscall_name, args) \
+    DOARGS_##args				\
+    movl $SYS_ify (syscall_name), %eax;		\
+    syscall;					\
+    UNDOARGS_##args
+
+# define DOARGS_0 /* nothing */
+# define DOARGS_1 /* nothing */
+# define DOARGS_2 /* nothing */
+# define DOARGS_3 /* nothing */
+# define DOARGS_4 pushq %r12; movq %rcx, %r12;
+# define DOARGS_5 pushq %r12; movq %rcx, %r12;
+# define DOARGS_6 pushq %r12; movq %rcx, %r12;
+
+# define UNDOARGS_0 /* nothing */
+# define UNDOARGS_1 /* nothing */
+# define UNDOARGS_2 /* nothing */
+# define UNDOARGS_3 /* nothing */
+# define UNDOARGS_4 popq %r12;
+# define UNDOARGS_5 popq %r12;
+# define UNDOARGS_6 popq %r12;
+
+#else /* !__ASSEMBLER__ */
+
+/* C inline syscall definitions for Ironclad x86_64.
+
+   Ironclad syscall convention:
+   - Syscall number in rax
+   - Args in rdi, rsi, rdx, r12, r8, r9
+   - Return value in rax
+   - Error code in rdx (0 = success)
+*/
+
+/* Define INTERNAL_SYSCALL_NCS for raw syscall without error checking.
+   IMPORTANT: On Ironclad, rdx is ALWAYS clobbered (set to errno) after syscall.
+   For syscalls with 3+ args, rdx is used as arg3 input.
+   For syscalls with 0-2 args, we must explicitly clobber rdx.  */
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(number, nr, args...) \
+  __INTERNAL_SYSCALL_NCS_DISP(number, nr, ##args)
+
+/* Dispatch macro to handle 0-arg case specially (no trailing comma).  */
+#define __INTERNAL_SYSCALL_NCS_DISP(number, nr, ...) \
+  __INTERNAL_SYSCALL_NCS_##nr (number, ##__VA_ARGS__)
+
+#define __INTERNAL_SYSCALL_NCS_0(number, ...) \
+  INTERNAL_SYSCALL_NCS_0(number)
+#define __INTERNAL_SYSCALL_NCS_1(number, a1) \
+  INTERNAL_SYSCALL_NCS_1(number, a1)
+#define __INTERNAL_SYSCALL_NCS_2(number, a1, a2) \
+  INTERNAL_SYSCALL_NCS_2(number, a1, a2)
+#define __INTERNAL_SYSCALL_NCS_3(number, a1, a2, a3) \
+  INTERNAL_SYSCALL_NCS_3(number, a1, a2, a3)
+#define __INTERNAL_SYSCALL_NCS_4(number, a1, a2, a3, a4) \
+  INTERNAL_SYSCALL_NCS_4(number, a1, a2, a3, a4)
+#define __INTERNAL_SYSCALL_NCS_5(number, a1, a2, a3, a4, a5) \
+  INTERNAL_SYSCALL_NCS_5(number, a1, a2, a3, a4, a5)
+#define __INTERNAL_SYSCALL_NCS_6(number, a1, a2, a3, a4, a5, a6) \
+  INTERNAL_SYSCALL_NCS_6(number, a1, a2, a3, a4, a5, a6)
+#define __INTERNAL_SYSCALL_NCS_7(number, a1, a2, a3, a4, a5, a6, a7) \
+  INTERNAL_SYSCALL_NCS_7(number, a1, a2, a3, a4, a5, a6, a7)
+
+/* 0-2 args: rdx is not used as input, capture it as output for errno.
+   Return -errno if errno is non-zero, otherwise return result.  */
+#define INTERNAL_SYSCALL_NCS_0(number) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number)							\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_1(number, a1) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a1 asm ("rdi") = (long int) (a1);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "r" (_a1)						\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_2(number, a1, a2) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a1 asm ("rdi") = (long int) (a1);		\
+    register long int _a2 asm ("rsi") = (long int) (a2);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "r" (_a1), "r" (_a2)				\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+/* 3+ args: rdx is used as input (arg3) and output (errno).
+   Following mlibc pattern: use separate input "d" and output "=d" constraints.
+   This matches how mlibc handles the dual-purpose rdx register.
+   Return -errno if errno is non-zero, otherwise return result.  */
+#define INTERNAL_SYSCALL_NCS_3(number, a1, a2, a3) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a1 asm ("rdi") = (long int) (a1);		\
+    register long int _a2 asm ("rsi") = (long int) (a2);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "r" (_a1), "r" (_a2), "d" ((long int) (a3))		\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+/* 4+ args: r12 is used for arg4 on Ironclad (not r10 like Linux).  */
+#define INTERNAL_SYSCALL_NCS_4(number, a1, a2, a3, a4) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4)					\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_5(number, a1, a2, a3, a4, a5) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    register long int _a5 asm ("r8") = (long int) (a5);			\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4), "r" (_a5)			\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+#define INTERNAL_SYSCALL_NCS_6(number, a1, a2, a3, a4, a5, a6) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    register long int _a5 asm ("r8") = (long int) (a5);			\
+    register long int _a6 asm ("r9") = (long int) (a6);			\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4), "r" (_a5), "r" (_a6)		\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+/* 7 args: r10 is used for arg7 on Ironclad.  */
+#define INTERNAL_SYSCALL_NCS_7(number, a1, a2, a3, a4, a5, a6, a7) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    register long int _a5 asm ("r8") = (long int) (a5);			\
+    register long int _a6 asm ("r9") = (long int) (a6);			\
+    register long int _a7 asm ("r10") = (long int) (a7);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "0" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4), "r" (_a5), "r" (_a6), "r" (_a7)	\
+    : "memory", "cc", "rcx", "r11");					\
+    _err != 0 ? -(long int)_err : (long int) resultvar;			\
+  })
+
+/* Define INTERNAL_SYSCALL_NCS_ERR that also returns the error code.
+   Following mlibc pattern: use separate input "d" and output "=d" constraints
+   for rdx. Use register variables for all arguments to ensure proper
+   register allocation.  */
+#undef INTERNAL_SYSCALL_NCS_ERR
+#define INTERNAL_SYSCALL_NCS_ERR(number, err, nr, args...) \
+  INTERNAL_SYSCALL_NCS_ERR_##nr (number, err, ##args)
+
+#define INTERNAL_SYSCALL_NCS_ERR_0(number, err) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number)							\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_1(number, err, a1) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a1 asm ("rdi") = (long int) (a1);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "r" (_a1)						\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_2(number, err, a1, a2) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a1 asm ("rdi") = (long int) (a1);		\
+    register long int _a2 asm ("rsi") = (long int) (a2);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "r" (_a1), "r" (_a2)				\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_3(number, err, a1, a2, a3) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a1 asm ("rdi") = (long int) (a1);		\
+    register long int _a2 asm ("rsi") = (long int) (a2);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "r" (_a1), "r" (_a2), "d" ((long int) (a3))		\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_4(number, err, a1, a2, a3, a4) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4)					\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_5(number, err, a1, a2, a3, a4, a5) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    register long int _a5 asm ("r8") = (long int) (a5);			\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4), "r" (_a5)			\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_6(number, err, a1, a2, a3, a4, a5, a6) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    register long int _a5 asm ("r8") = (long int) (a5);			\
+    register long int _a6 asm ("r9") = (long int) (a6);			\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4), "r" (_a5), "r" (_a6)		\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#define INTERNAL_SYSCALL_NCS_ERR_7(number, err, a1, a2, a3, a4, a5, a6, a7) \
+  ({									\
+    unsigned long int resultvar;					\
+    unsigned long int _err;						\
+    register long int _a4 asm ("r12") = (long int) (a4);		\
+    register long int _a5 asm ("r8") = (long int) (a5);			\
+    register long int _a6 asm ("r9") = (long int) (a6);			\
+    register long int _a7 asm ("r10") = (long int) (a7);		\
+    asm volatile (							\
+    "syscall\n\t"							\
+    : "=a" (resultvar), "=d" (_err)					\
+    : "a" (number), "D" ((long int) (a1)), "S" ((long int) (a2)),	\
+      "d" ((long int) (a3)), "r" (_a4), "r" (_a5), "r" (_a6), "r" (_a7)	\
+    : "memory", "cc", "rcx", "r11");					\
+    err = _err;								\
+    (long int) resultvar;						\
+  })
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, nr, args...) \
+  INTERNAL_SYSCALL_NCS (SYS_##name, nr, args)
+
+/* Load arguments into registers.  Note: arg4 uses r12, not r10!  */
+# define LOAD_ARGS_0()
+# define LOAD_REGS_0
+# define ASM_ARGS_0
+
+# define LOAD_ARGS_1(a1)				\
+  long int __arg1 = (long int) (a1);			\
+  LOAD_ARGS_0 ()
+# define LOAD_REGS_1					\
+  register long int _a1 asm ("rdi") = __arg1;		\
+  LOAD_REGS_0
+# define ASM_ARGS_1	ASM_ARGS_0, "r" (_a1)
+
+# define LOAD_ARGS_2(a1, a2)				\
+  long int __arg2 = (long int) (a2);			\
+  LOAD_ARGS_1 (a1)
+# define LOAD_REGS_2					\
+  register long int _a2 asm ("rsi") = __arg2;		\
+  LOAD_REGS_1
+# define ASM_ARGS_2	ASM_ARGS_1, "r" (_a2)
+
+# define LOAD_ARGS_3(a1, a2, a3)			\
+  long int __arg3 = (long int) (a3);			\
+  LOAD_ARGS_2 (a1, a2)
+# define LOAD_REGS_3					\
+  register long int _a3 asm ("rdx") = __arg3;		\
+  LOAD_REGS_2
+# define ASM_ARGS_3	ASM_ARGS_2, "r" (_a3)
+
+/* NOTE: Ironclad uses r12 for 4th argument, not r10 like Linux!  */
+# define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long int __arg4 = (long int) (a4);			\
+  LOAD_ARGS_3 (a1, a2, a3)
+# define LOAD_REGS_4					\
+  register long int _a4 asm ("r12") = __arg4;		\
+  LOAD_REGS_3
+# define ASM_ARGS_4	ASM_ARGS_3, "r" (_a4)
+
+# define LOAD_ARGS_5(a1, a2, a3, a4, a5)		\
+  long int __arg5 = (long int) (a5);			\
+  LOAD_ARGS_4 (a1, a2, a3, a4)
+# define LOAD_REGS_5					\
+  register long int _a5 asm ("r8") = __arg5;		\
+  LOAD_REGS_4
+# define ASM_ARGS_5	ASM_ARGS_4, "r" (_a5)
+
+# define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)		\
+  long int __arg6 = (long int) (a6);			\
+  LOAD_ARGS_5 (a1, a2, a3, a4, a5)
+# define LOAD_REGS_6					\
+  register long int _a6 asm ("r9") = __arg6;		\
+  LOAD_REGS_5
+# define ASM_ARGS_6	ASM_ARGS_5, "r" (_a6)
+
+/* NOTE: Ironclad uses r10 for 7th argument.  */
+# define LOAD_ARGS_7(a1, a2, a3, a4, a5, a6, a7)	\
+  long int __arg7 = (long int) (a7);			\
+  LOAD_ARGS_6 (a1, a2, a3, a4, a5, a6)
+# define LOAD_REGS_7					\
+  register long int _a7 asm ("r10") = __arg7;		\
+  LOAD_REGS_6
+# define ASM_ARGS_7	ASM_ARGS_6, "r" (_a7)
+
+/* For C code: INLINE_SYSCALL_CALL macro.  */
+#define INLINE_SYSCALL_CALL(...) \
+  __INLINE_SYSCALL_DISP (__INLINE_SYSCALL, __VA_ARGS__)
+
+#define __INLINE_SYSCALL_DISP(b,...) \
+  __SYSCALL_CONCAT (b,__INLINE_SYSCALL_NARGS(__VA_ARGS__))(__VA_ARGS__)
+
+#define __SYSCALL_CONCAT_X(a,b)     a##b
+#define __SYSCALL_CONCAT(a,b)       __SYSCALL_CONCAT_X (a, b)
+
+#define __INLINE_SYSCALL_NARGS_X(a,b,c,d,e,f,g,h,n,...) n
+#define __INLINE_SYSCALL_NARGS(...) \
+  __INLINE_SYSCALL_NARGS_X (__VA_ARGS__,7,6,5,4,3,2,1,0,)
+
+#define __INLINE_SYSCALL0(name) \
+  INLINE_SYSCALL (name, 0)
+#define __INLINE_SYSCALL1(name, a1) \
+  INLINE_SYSCALL (name, 1, a1)
+#define __INLINE_SYSCALL2(name, a1, a2) \
+  INLINE_SYSCALL (name, 2, a1, a2)
+#define __INLINE_SYSCALL3(name, a1, a2, a3) \
+  INLINE_SYSCALL (name, 3, a1, a2, a3)
+#define __INLINE_SYSCALL4(name, a1, a2, a3, a4) \
+  INLINE_SYSCALL (name, 4, a1, a2, a3, a4)
+#define __INLINE_SYSCALL5(name, a1, a2, a3, a4, a5) \
+  INLINE_SYSCALL (name, 5, a1, a2, a3, a4, a5)
+#define __INLINE_SYSCALL6(name, a1, a2, a3, a4, a5, a6) \
+  INLINE_SYSCALL (name, 6, a1, a2, a3, a4, a5, a6)
+#define __INLINE_SYSCALL7(name, a1, a2, a3, a4, a5, a6, a7) \
+  INLINE_SYSCALL (name, 7, a1, a2, a3, a4, a5, a6, a7)
+
+#endif /* __ASSEMBLER__ */
+
+/* Cancellation support - needed for NPTL.  */
+#undef SINGLE_THREAD_P
+#if IS_IN (libc) || IS_IN (rtld)
+# define SINGLE_THREAD_P \
+  __glibc_likely (THREAD_GETMEM (THREAD_SELF, header.multiple_threads) == 0)
+#else
+# define SINGLE_THREAD_P (1)
+#endif
+
+#endif /* _IRONCLAD_X86_64_SYSDEP_H */
diff --git glibc-clean/wcsmbs/wchar.h glibc-workdir/wcsmbs/wchar.h
index b31ca2d..496ae13 100644
--- glibc-clean/wcsmbs/wchar.h
+++ glibc-workdir/wcsmbs/wchar.h
@@ -387,14 +387,14 @@ extern size_t wcsnrtombs (char *__restrict __dst,
 
 
 /* The following functions are extensions found in X/Open CAE.  */
-#ifdef __USE_XOPEN
+#if defined __USE_XOPEN || defined __USE_MISC
 /* Determine number of column positions required for C.  */
 extern int wcwidth (wchar_t __c) __THROW;
 
 /* Determine number of column positions required for first N wide
    characters (or fewer if S ends before this) in S.  */
 extern int wcswidth (const wchar_t *__s, size_t __n) __THROW;
-#endif	/* Use X/Open.  */
+#endif	/* Use X/Open or Misc.  */
 
 
 /* Convert initial portion of the wide string NPTR to `double'
