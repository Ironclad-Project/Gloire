diff --git mlibc-clean/abis/ironclad/fcntl.h mlibc-workdir/abis/ironclad/fcntl.h
index d1e9f02..1bb446f 100644
--- mlibc-clean/abis/ironclad/fcntl.h
+++ mlibc-workdir/abis/ironclad/fcntl.h
@@ -1,51 +1,52 @@
 #ifndef _ABIBITS_FCNTL_H
 #define _ABIBITS_FCNTL_H
 
-// reserve 3 bits for the access mode
-#define O_ACCMODE 0x0007
-#define O_RDONLY 1
-#define O_WRONLY 2
-#define O_RDWR   3
+// Flags supported by the kernel.
+#define O_ACCMODE   0x0007
+#define O_RDONLY    0b00000000001
+#define O_WRONLY    0b00000000010
+#define O_RDWR      0b00000000011
+#define O_APPEND    0b00000000100
+#define O_CLOEXEC   0b00000001000
+#define O_NOFOLLOW  0b00100000000
+#define O_NONBLOCK  0b01000000000
+
+// Flags emulated by userland.
+#define O_CREAT  0b010000000000
+#define O_EXCL   0b100000000000
+
+// Stubbed open flags.
 #define O_SEARCH 4
 #define O_EXEC   7
-
-// This flags are stubs.
-#define O_APPEND 0x00008
-#define O_CREAT 0x00010
-#define O_DIRECTORY 0x00020
-#define O_EXCL 0x00040
 #define O_NOCTTY 0x00080
-#define O_NOFOLLOW 0x00100
 #define O_TRUNC 0x00200
-#define O_NONBLOCK 0x00400
 #define O_DSYNC 0x00800
 #define O_RSYNC 0x01000
 #define O_SYNC 0x02000
-#define O_CLOEXEC 0x04000
 #define O_PATH 0x08000
+#define O_DIRECTORY 0x10000
 #define O_LARGEFILE 0x10000
 #define O_NOATIME 0x20000
 #define O_TMPFILE 0x40000
 
-// The constants below are copied from abis/mlibc/fcntl.h.
+// Fcntl flags.
+#define FD_CLOEXEC 1
+#define F_GETFD    3
+#define F_SETFD    4
+#define F_GETFL    5
+#define F_SETFL    6
+
+// Stubbed fcntl flags.
 #define F_DUPFD 1
 #define F_DUPFD_CLOEXEC 2
-#define F_GETFD 3
-#define F_SETFD 4
-#define F_GETFL 5
-#define F_SETFL 6
 #define F_GETLK 7
 #define F_SETLK 8
 #define F_SETLKW 9
 #define F_GETOWN 10
 #define F_SETOWN 11
-
 #define F_RDLCK 1
 #define F_UNLCK 2
 #define F_WRLCK 3
-
-#define FD_CLOEXEC 1
-
 #define F_SEAL_SHRINK 0x0002
 #define F_SEAL_GROW   0x0004
 #define F_SEAL_WRITE  0x0008
@@ -53,12 +54,12 @@
 #define F_ADD_SEALS   1033
 #define F_GET_SEALS   1034
 
-#define AT_EMPTY_PATH 1
-#define AT_SYMLINK_FOLLOW 2
-#define AT_SYMLINK_NOFOLLOW 4
-#define AT_REMOVEDIR 8
-#define AT_EACCESS 512
-
-#define AT_FDCWD -100
+// At flags.
+#define AT_REMOVEDIR        500
+#define AT_EACCESS          512
+#define AT_FDCWD            0x7FFFFFFF
+#define AT_EMPTY_PATH       1
+#define AT_SYMLINK_FOLLOW   0
+#define AT_SYMLINK_NOFOLLOW 2
 
 #endif // _ABIBITS_FCNTL_H
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..6e87ed8 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -1,6 +1,7 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
 
+/*
 int backtrace(void **, int) {
 	__ensure(!"Not implemented");
 	__builtin_unreachable();
@@ -15,3 +16,4 @@ void backtrace_symbols_fd(void *const *, int, int) {
 	__ensure(!"Not implemented");
 	__builtin_unreachable();
 }
+*/
diff --git mlibc-clean/options/posix/generic/dirent-stubs.cpp mlibc-workdir/options/posix/generic/dirent-stubs.cpp
index 1352585..f6a0975 100644
--- mlibc-clean/options/posix/generic/dirent-stubs.cpp
+++ mlibc-workdir/options/posix/generic/dirent-stubs.cpp
@@ -66,14 +66,14 @@ DIR *opendir(const char *path) {
 }
 struct dirent *readdir(DIR *dir) {
 	__ensure(dir->__ent_next <= dir->__ent_limit);
-	if(dir->__ent_next == dir->__ent_limit) {
+	if(dir->__ent_next == 0 && dir->__ent_limit == 0) {
 		MLIBC_CHECK_OR_ENOSYS(mlibc::sys_read_entries, nullptr);
 		if(int e = mlibc::sys_read_entries(dir->__handle, dir->__ent_buffer, 2048, &dir->__ent_limit); e)
 			__ensure(!"mlibc::sys_read_entries() failed");
 		dir->__ent_next = 0;
-		if(!dir->__ent_limit)
-			return nullptr;
-	}
+	} else if (dir->__ent_next == dir->__ent_limit) {
+	   return nullptr;
+   }
 
 	auto entp = reinterpret_cast<struct dirent *>(dir->__ent_buffer + dir->__ent_next);
 	// We only copy as many bytes as we need to avoid buffer-overflows.
diff --git mlibc-clean/options/posix/generic/unistd-stubs.cpp mlibc-workdir/options/posix/generic/unistd-stubs.cpp
index e2c40ce..0a170e5 100644
--- mlibc-clean/options/posix/generic/unistd-stubs.cpp
+++ mlibc-workdir/options/posix/generic/unistd-stubs.cpp
@@ -684,8 +684,8 @@ unsigned long sysconf(int number) {
 			return mlibc::page_size;
 		case _SC_OPEN_MAX:
 			// TODO: actually return a proper value for _SC_OPEN_MAX
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns arbitrary value 256\e[39m" << frg::endlog;
-			return 256;
+			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns arbitrary value 100\e[39m" << frg::endlog;
+			return 100;
 		case _SC_PHYS_PAGES:
 			// TODO: actually return a proper value for _SC_PHYS_PAGES
 			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_PHYS_PAGES) returns arbitrary value 1024\e[39m" << frg::endlog;
diff --git mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S
new file mode 100644
index 0000000..911b078
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-x86_64/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S
new file mode 100644
index 0000000..0187e50
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-x86_64/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index d6dbca3..2004c76 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -10,24 +10,23 @@
 #include <string.h>
 #include <stdio.h>
 #include <sys/syscall.h>
+#include <sys/ironclad.h>
+#include <sched.h>
+#include <sys/mman.h>
 
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-	/*
 	ssize_t unused;
 	char new_line = '\n';
-	sys_write(1, message, strlen(message), &unused);
-	sys_write(1, &new_line, 1, &unused);
-	*/
-	(void)message;
-	return;
+	sys_write(2, message, strlen(message), &unused);
+	sys_write(2, &new_line, 1, &unused);
 }
 
 void sys_libc_panic() {
 	ssize_t unused;
 	char const *message = "mlibc panicked unrecoverably\n";
-	sys_write(1, message, strlen(message), &unused);
+	sys_write(2, message, strlen(message), &unused);
 	sys_exit(1);
 }
 
@@ -39,15 +38,32 @@ void sys_exit(int status) {
 
 int sys_tcb_set(void *pointer) {
 	int ret, errno;
-	SYSCALL1(SYSCALL_SET_TCB, pointer);
+	SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
 	return errno;
 }
 
 int sys_open(const char *path, int flags, mode_t mode, int *fd) {
 	int ret, errno;
-	(void)mode;
 
-	SYSCALL2(SYSCALL_OPEN, path, flags);
+	SYSCALL4(SYSCALL_OPEN, AT_FDCWD, path, strlen (path), flags);
+	if (ret == -1) {
+	    SYSCALL4(SYSCALL_CREATE, AT_FDCWD, path, strlen (path), mode);
+	    SYSCALL4(SYSCALL_OPEN,   AT_FDCWD, path, strlen (path), flags);
+	}
+
+	*fd = ret;
+	return errno;
+}
+
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+	int ret, errno;
+
+	SYSCALL4(SYSCALL_OPEN, dirfd, path, strlen (path), flags);
+	if (ret == -1) {
+	    SYSCALL4(SYSCALL_CREATE, dirfd, path, strlen (path), mode);
+	    SYSCALL4(SYSCALL_OPEN,   dirfd, path, strlen (path), flags);
+	}
+
 	*fd = ret;
 	return errno;
 }
@@ -56,12 +72,42 @@ int sys_open_dir(const char *path, int *handle) {
 	return sys_open(path, O_RDONLY, 0660, handle);
 }
 
+int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
+	size_t ret;
+	int errno;
+	SYSCALL3(SYSCALL_GETDENTS, handle, buffer, max_size);
+	if (errno != 0) {
+		return errno;
+	} else {
+		*bytes_read = ret;
+		return 0;
+	}
+}
+
+void sys_thread_exit() {
+    int ret, errno;
+    SYSCALL0(SYSCALL_EXIT_THREAD);
+    __builtin_unreachable();
+}
+
 int sys_close(int fd) {
 	int ret, errno;
 	SYSCALL1(SYSCALL_CLOSE, fd);
 	return errno;
 }
 
+void sys_sync() {
+   int ret, errno;
+   SYSCALL0(SYSCALL_SYNC);
+}
+
+int sys_fsync(int fd) {
+   int ret, errno;
+   (void)fd;
+   SYSCALL0(SYSCALL_SYNC);
+   return 0;
+}
+
 int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
 	ssize_t ret;
 	int errno;
@@ -113,6 +159,16 @@ int sys_vm_unmap(void *pointer, size_t size) {
 	}
 }
 
+int sys_vm_protect(void *pointer, size_t size, int prot) {
+	int ret;
+	int errno;
+	SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
+	if (ret != 0) {
+		return errno;
+	}
+	return 0;
+}
+
 pid_t sys_getpid() {
 	pid_t ret;
 	int errno;
@@ -131,100 +187,68 @@ int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *old
 	(void)signum;
 	(void)act;
 	(void)oldact;
-	mlibc::infoLogger() << "sigaction() is a stub" << frg::endlog;
+	// FIXME: Stub.
 	return 0;
 }
 
 int sys_fcntl(int fd, int request, va_list args, int *result) {
-	(void)fd;
-	(void)request;
-	(void)args;
-	(void)result;
-	mlibc::infoLogger() << "fcntl() is a stub!" << frg::endlog;
-	return 0;
+	int ret, errno;
+	SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
+	*result = ret;
+	return errno;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
 	(void)how;
 	(void)set;
 	(void)retrieve;
-	mlibc::infoLogger() << "sigprocmask() is a stub!" << frg::endlog;
+	// FIXME: Stub.
 	return ENOSYS;
 }
 
-int sys_ttyname(int fd, char *buf, size_t size) {
-	(void)fd;
-	(void)buf;
-	(void)size;
-	mlibc::infoLogger() << "ttyname() is a stub!" << frg::endlog;
-	return ENOSYS;
-}
-
-int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid;
-	(void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
-	return 0;
-}
-
-int sys_pselect(int num_fds, fd_set *read_set, fd_set *write_set, fd_set *except_set,
-	const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
-	(void)num_fds;
-	(void)read_set;
-	(void)write_set;
-	(void)except_set;
-	(void)timeout;
-	(void)sigmask;
-	(void)num_events;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
-}
-
 int sys_isatty(int fd) {
-	(void)fd;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!\n" << frg::endlog;
-	return 0;
+	struct termios t;
+	if (sys_tcgetattr(fd, &t) == 0) {
+		return 0;
+	} else {
+		return ENOTTY;
+	}
 }
 
 uid_t sys_getuid() {
-	mlibc::infoLogger() << "getuid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 uid_t sys_geteuid() {
-	mlibc::infoLogger() << "geteuid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 gid_t sys_getgid() {
-	mlibc::infoLogger() << "getgid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 gid_t sys_getegid() {
-	mlibc::infoLogger() << "getegid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	return 0;
 }
 
 pid_t sys_getpgid(pid_t pid, pid_t *pgid) {
 	(void)pid;
-	mlibc::infoLogger() << "getpgid() is a stub" << frg::endlog;
+	// FIXME: Stub needed by mlibc.
 	*pgid = 0;
 	return 0;
 }
 
-int sys_clock_get(int clock, time_t *secs, long *nanos) {
-	(void)clock;
-	(void)secs;
-	(void)nanos;
-	mlibc::infoLogger() << "clock_get() is a stub" << frg::endlog;
-	return 0;
-}
-
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
-	int ret, errno;
+	int ret, errno, argv_len, envp_len;
+   for (argv_len = 0; argv[argv_len] != NULL; argv_len++);
+   for (envp_len = 0; envp[envp_len] != NULL; envp_len++);
 
-	SYSCALL3(SYSCALL_EXEC, path, argv, envp);
+   size_t path_len = strlen (path);
+	SYSCALL6(SYSCALL_EXEC, path, path_len, argv, argv_len, envp, envp_len);
 
 	if (ret == -1) {
 		return errno;
@@ -234,17 +258,20 @@ int sys_execve(const char *path, char *const argv[], char *const envp[]) {
 }
 
 int sys_fork(pid_t *child) {
-    pid_t ret;
-    int errno;
+	pid_t ret;
+	int errno;
 
-    SYSCALL0(SYSCALL_FORK);
+	SYSCALL5(SYSCALL_CLONE, 0, 0, 0, 0, 0);
 
-    if (ret == -1) {
-        return errno;
-    }
+	if (ret == -1) {
+		return errno;
+	}
 
-    *child = ret;
-    return 0;
+	if (child != NULL) {
+		*child = ret;
+	}
+
+	return 0;
 }
 
 int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
@@ -290,7 +317,7 @@ int sys_sethostname(const char *buff, size_t size) {
 	return 0;
 }
 
-int sys_getcwd(const char *buff, size_t size) {
+int sys_getcwd(char *buff, size_t size) {
 	char* ret;
 	int errno;
 
@@ -306,7 +333,7 @@ int sys_getcwd(const char *buff, size_t size) {
 int sys_chdir(const char *buff) {
 	int ret, errno;
 
-	SYSCALL1(SYSCALL_CHDIR, buff);
+	SYSCALL2(SYSCALL_CHDIR, buff, strlen(buff));
 
 	if (ret == -1) {
 		return errno;
@@ -328,16 +355,9 @@ int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
 	return 0;
 }
 
-int sys_sched_yield(void) {
+void sys_yield(void) {
 	int ret, errno;
-
 	SYSCALL0(SYSCALL_SCHED_YIELD);
-
-	if (ret == -1) {
-		return errno;
-	}
-
-	return 0;
 }
 
 int sys_dup(int fd, int flags, int *newfd) {
@@ -357,16 +377,14 @@ int sys_dup(int fd, int flags, int *newfd) {
 int sys_dup2(int fd, int flags, int newfd) {
 	int ret, errno;
 
-	if (flags) {
-		SYSCALL3(SYSCALL_DUP3, fd, newfd, flags);
-	} else {
-		SYSCALL2(SYSCALL_DUP2, fd, newfd);
-	}
-
+   SYSCALL2(SYSCALL_DUP2, fd, newfd);
 	if (ret == -1) {
         return errno;
 	} else {
-		return 0;
+		if (flags) {
+		   SYSCALL3(SYSCALL_FCNTL, fd, F_SETFL, flags);
+	   }
+	   return 0;
 	}
 }
 
@@ -401,10 +419,17 @@ int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
     return 0;
 }
 
+int sys_pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+                const struct timespec *timeout, const sigset_t *sigmask,
+                int *num_events) {
+    return 0;
+}
+
 int sys_access(const char *path, int mode) {
 	int ret, errno;
 
-	SYSCALL2(SYSCALL_ACCESS, path, mode);
+   int path_len = strlen(path);
+	SYSCALL5(SYSCALL_ACCESS, AT_FDCWD, path, path_len, mode, 0);
 
 	if (ret == -1) {
         return errno;
@@ -413,46 +438,112 @@ int sys_access(const char *path, int mode) {
    }
 }
 
-int sys_getpriority(int which, id_t who, int *value) {
-	int ret, errno;
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+	(void)pointer;
+	(void)expected;
+	(void)time;
+	return 0;
+}
 
-	SYSCALL2(SYSCALL_GETPRIORITY, which, who);
+int sys_futex_wake(int *pointer) {
+	(void)pointer;
+	return 0;
+}
 
-	if (ret == -1 && errno != 0) {
-        return errno;
-	} else {
-			*value = ret;
-        return 0;
-   }
+int sys_pipe(int *fds, int flags) {
+   int ret, errno;
+	SYSCALL2(SYSCALL_PIPE, fds, flags);
+	return errno;
 }
 
-int sys_setpriority(int which, id_t who, int prio) {
-	int ret, errno;
+int sys_getentropy(void *buffer, size_t length) {
+	ssize_t ret;
+	int errno;
+	SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
+	return errno;
+}
+	
+#ifndef MLIBC_BUILDING_RTDL
 
-	SYSCALL3(SYSCALL_SETPRIORITY, which, who, prio);
+extern "C" void __mlibc_thread_entry();
 
-	if (ret == -1) {
+int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
+    int ret, errno;
+    SYSCALL5(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb);
+
+    if (ret == -1) {
         return errno;
-	} else {
-        return 0;
-   }
+    }
+
+    *tid_out = (pid_t)ret;
+    return 0;
 }
 
-int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-	(void)pointer;
-	(void)expected;
-	(void)time;
-	__ensure(!"sys_futex is a stub!");
-	__builtin_unreachable();
+int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size) {
+	// TODO guard
+
+	mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+
+	*guard_size = 0;
+   *stack_size = *stack_size ? *stack_size : 0x400000;
+
+	if (!*stack) {
+		*stack = (void *)((char *)mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size);
+		if (*stack == MAP_FAILED) {
+			return errno;
+		}
+	}
+
+	void **stack_it = (void **)*stack;
+
+	*--stack_it = arg;
+	*--stack_it = tcb;
+	*--stack_it = entry;
+
+	*stack = (void *)stack_it;
+
+	return 0;
 }
 
-int sys_futex_wake(int *pointer) {
-	(void)pointer;
-	__ensure(!"sys_futex is a stub!");
-	__builtin_unreachable();
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+	switch (clock) {
+		case CLOCK_REALTIME: {
+			// Use the RTC interface, there is no native kernel entity.
+			// RTC gives true month and year, substract to make epoch.
+			int fd, ret;
+			struct rtc_time rtc;
+			struct tm tm;
+			if (sys_open("/dev/rtc", O_RDONLY, 0, &fd) ||
+				 sys_ioctl(fd, RTC_RD_TIME, &rtc, &ret))
+			{
+				return -1;
+			}
+			tm = {
+				.tm_sec  = rtc.tm_sec,
+				.tm_min  = rtc.tm_min,
+				.tm_hour = rtc.tm_hour,
+				.tm_mday = rtc.tm_mday,
+				.tm_mon  = rtc.tm_mon  - 1,
+				.tm_year = rtc.tm_year - 1900,
+				.tm_wday = rtc.tm_wday,
+				.tm_yday = rtc.tm_yday,
+				.tm_isdst = rtc.tm_isdst
+			};
+			*nanos = 0;
+			*secs  = mktime(&tm);
+			sys_close (fd);
+			return 0;
+		}
+		default:
+			return -1;
+	}
 }
 
-#ifndef MLIBC_BUILDING_RTDL
+int sys_sleep(time_t *secs, long *nanos) {
+	*secs  = 0;
+	*nanos = 0;
+	return 0;
+}
 
 int sys_gethostname(char *buffer, size_t bufsize) {
 	struct utsname buf;
@@ -470,19 +561,18 @@ int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat
 
 	switch (fsfdt) {
 		case fsfd_target::fd: {
-			// mlibc wants us to do a fstat.
-			SYSCALL2(SYSCALL_FSTAT, fd, statbuf);
+			SYSCALL5(SYSCALL_LSTAT, fd, NULL, 0, statbuf, AT_EMPTY_PATH);
 			return errno;
 		}
 		case fsfd_target::path: {
-			// mlibc wants us to do a lstat.
-			SYSCALL2(SYSCALL_LSTAT, path, statbuf);
+			size_t path_len = strlen(path);
+			SYSCALL5(SYSCALL_LSTAT, AT_FDCWD, path, path_len, statbuf, AT_SYMLINK_NOFOLLOW);
 			return errno;
 		}
 		case fsfd_target::fd_path: {
-			// mlibc wants us to do an fstatat
-			__ensure(!"stat: Invalid fstatat");
-			__builtin_unreachable();
+			size_t path_len = strlen(path);
+			SYSCALL5(SYSCALL_LSTAT, fd, path, path_len, statbuf, 0);
+			return errno;
 		}
 		default: {
 			__ensure(!"stat: Invalid fsfdt");
@@ -493,5 +583,106 @@ int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat
 	__builtin_unreachable();
 }
 
+int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) {
+	ssize_t ret;
+	int errno;
+	size_t path_len = strlen(path);
+	SYSCALL5(SYSCALL_READLINK, AT_FDCWD, path, path_len, buffer, max_size);
+	if (ret == -1) {
+		return errno;
+	} else {
+		*length = ret;
+		return 0;
+	}
+}
+
+int sys_mount(const char *source, const char *target,
+	const char *fstype, unsigned long flags, const void *data) {
+	(void)data;
+
+	int ret;
+	int errno;
+	size_t source_len = strlen(source);
+	size_t target_len = strlen(target);
+   int val;
+   if (!strcmp(fstype, "ext")) {
+      val = 1;
+   } else if (!strcmp(fstype, "fat32")) {
+      val = 2;
+   } else {
+      return EINVAL;
+   }
+
+	SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, val, flags);
+   return errno;
+}
+
+int sys_umount2(const char *target, int flags) {
+	int ret;
+	int errno;
+	size_t target_len = strlen(target);
+	SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
+   return errno;
+}
+
 #endif
 } // namespace mlibc
+
+#ifndef MLIBC_BUILDING_RTDL
+extern "C" {
+// Syscalls for ironclad.h
+int get_thread_sched(void) {
+	int ret, errn;
+	SYSCALL0(SYSCALL_GET_THREAD_SCHED);
+	errno = errn;
+	return ret;
+}
+
+int set_thread_sched(int flags) {
+	int ret, errn;
+	SYSCALL1(SYSCALL_SET_THREAD_SCHED, flags);
+	errno = errn;
+	return ret;
+}
+
+int set_mac_capabilities(unsigned long request) {
+	int ret;
+	int errn;
+	SYSCALL1(SYSCALL_SET_MAC_CAPABILITIES, request);
+	errno = errn;
+	return ret;
+}
+
+int lock_mac(void) {
+	int ret;
+	int errn;
+	SYSCALL0(SYSCALL_LOCK_MAC);
+	errno = errn;
+	return ret;
+}
+
+int add_mac_filter(struct mac_filter *filt) {
+	int ret;
+	int errn;
+	SYSCALL1(SYSCALL_ADD_MAC_FILTER, filt);
+	errno = errn;
+	return ret;
+}
+
+int set_mac_enforcement(unsigned long enforcement) {
+	int ret;
+	int errn;
+	SYSCALL1(SYSCALL_SET_MAC_ENFORCEMENT, enforcement);
+	errno = errn;
+	return ret;
+}
+
+int set_deadlines(int runtime, int period) {
+	int ret;
+	int errn;
+	SYSCALL2(SYSCALL_SET_DEADLINES, runtime, period);
+	errno = errn;
+	return ret;
+}
+}
+#endif
diff --git mlibc-workdir/sysdeps/ironclad/generic/thread.S mlibc-workdir/sysdeps/ironclad/generic/thread.S
new file mode 100644
index 0000000..47ab6a9
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/thread.S
@@ -0,0 +1,9 @@
+.section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_thread_trampoline
+
+.section .note.GNU-stack,"",%progbits
diff --git mlibc-workdir/sysdeps/ironclad/generic/thread.cpp mlibc-workdir/sysdeps/ironclad/generic/thread.cpp
new file mode 100644
index 0000000..687ef8c
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/generic/thread.cpp
@@ -0,0 +1,19 @@
+#include <sys/mman.h>
+#include <mlibc/debug.hpp>
+#include <errno.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <bits/ensure.h>
+#include <mlibc/tcb.hpp>
+
+extern "C" void __mlibc_thread_trampoline(void *(*fn)(void *), Tcb *tcb, void *arg) {
+	while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0) {
+		mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);
+	}
+
+	tcb->returnValue = fn(arg);
+
+	__atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&tcb->didExit);
+
+	mlibc::sys_thread_exit();
+}
diff --git mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h mlibc-workdir/sysdeps/ironclad/include/sys/ironclad.h
index 89a3851..78031f6 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/ironclad.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/ironclad.h
@@ -3,6 +3,7 @@
 
 #include <stdint.h>
 #include <stdbool.h>
+#include <sys/types.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -11,16 +12,10 @@ extern "C" {
 #define FB_DIMENSIONS 1
 
 struct ironclad_fb_dimensions {
-	uint16_t width;
-	uint16_t height;
-	uint16_t pitch;
-	uint16_t bpp;
-	uint8_t  red_mask_size;
-	uint8_t  red_mask_shift;
-	uint8_t  green_mask_size;
-	uint8_t  green_mask_shift;
-	uint8_t  blue_mask_size;
-	uint8_t  blue_mask_shift;
+	uint32_t width;
+	uint32_t height;
+	uint32_t pitch;
+	uint8_t  bpp;
 };
 
 #define PS2MOUSE_2_1_SCALING     1
@@ -34,6 +29,59 @@ struct ironclad_mouse_data {
 	bool is_left;
 	bool is_right;
 };
+
+#define RTC_RD_TIME  1
+#define RTC_SET_TIME 2
+
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;     /* unused */
+	int tm_yday;     /* unused */
+	int tm_isdst;    /* unused */
+};
+
+// Syscalls declared on the documentation, but without libc equivalents.
+// Implemented in generic.cpp
+#define THREAD_RT     0b0001
+#define THREAD_MONO   0b0010
+#define THREAD_MLOCK  0b0100
+#define THREAD_BANNED 0b1000
+int get_thread_sched(void);
+int set_thread_sched(int flags);
+
+#define MAC_EXIT_ITSELF   0b000001
+#define MAC_CREATE_OTHERS 0b000010
+#define MAC_CHANGE_SCHED  0b000100
+#define MAC_ACC_ENTROPY   0b001000
+#define MAC_ALLOC_MEM     0b010000
+#define MAC_DEALLOC_MEM   0b100000
+int set_mac_capabilities(unsigned long request);
+int lock_mac(void);
+
+#define MAC_FILTER_INC_FILES 0b0000001
+#define MAC_FILTER_INC_DIRS  0b0000010
+#define MAC_FILTER_R         0b0000100
+#define MAC_FILTER_W         0b0001000
+#define MAC_FILTER_EXEC      0b0010000
+struct mac_filter {
+    char    path[75];
+    int     length;
+    uint8_t perms;
+};
+int add_mac_filter(struct mac_filter *filt);
+
+#define MAC_DENY            0b001
+#define MAC_DENY_AND_SCREAM 0b010
+#define MAC_KILL            0b100
+int set_mac_enforcement(unsigned long enforcement);
+
+int set_deadlines(int runtime, int period);
+
 #ifdef __cplusplus
 }
 #endif
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index 28d233e..292257e 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -38,9 +38,18 @@
 				  : "memory"); \
 })
 
+#define SYSCALL5(NUM, ARG0, ARG1, ARG2, ARG3, ARG4) ({ \
+   register auto arg_r8 asm("r8") = ARG4; \
+	asm volatile ("int $0x80" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), "c"(ARG3), \
+				    "r"(arg_r8) \
+				  : "memory"); \
+})
+
 #define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
-	register uint64_t arg_r8 asm("r8") = (uint64_t)ARG4; \
-	register uint64_t arg_r9 asm("r9") = (uint64_t)ARG5; \
+	register auto arg_r8 asm("r8") = ARG4; \
+	register auto arg_r9 asm("r9") = ARG5; \
 	asm volatile ("int $0x80" \
 				  : "=a"(ret), "=d"(errno) \
 				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
@@ -48,33 +57,60 @@
 				  : "memory"); \
 })
 
-#define SYSCALL_EXIT               0
-#define SYSCALL_SET_TCB            1
-#define SYSCALL_OPEN               2
-#define SYSCALL_CLOSE              3
-#define SYSCALL_READ               4
-#define SYSCALL_WRITE              5
-#define SYSCALL_SEEK               6
-#define SYSCALL_MMAP               7
-#define SYSCALL_MUNMAP             8
-#define SYSCALL_GETPID             9
-#define SYSCALL_GETPPID           10
-#define SYSCALL_EXEC              11
-#define SYSCALL_FORK              12
-#define SYSCALL_WAIT              13
-#define SYSCALL_UNAME             14
-#define SYSCALL_SETHOSTNAME       15
-#define SYSCALL_FSTAT             16
-#define SYSCALL_LSTAT             17
-#define SYSCALL_GETCWD            18
-#define SYSCALL_CHDIR             19
-#define SYSCALL_IOCTL             20
-#define SYSCALL_SCHED_YIELD       21
-#define SYSCALL_GETPRIORITY       22
-#define SYSCALL_SETPRIORITY       23
-#define SYSCALL_DUP               24
-#define SYSCALL_DUP2              25
-#define SYSCALL_DUP3              26
-#define SYSCALL_ACCESS            27
+#define SYSCALL7(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ({ \
+	register auto arg_r8  asm("r8")  = ARG4; \
+	register auto arg_r9  asm("r9")  = ARG5; \
+	register auto arg_r10 asm("r10") = ARG6; \
+	asm volatile ("int $0x80" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+					"c"(ARG3), "r"(arg_r8), "r"(arg_r9), "r"(arg_r10) \
+				  : "memory"); \
+})
+
+#define SYSCALL_EXIT                  0
+#define SYSCALL_ARCH_PRCTL            1
+#define SYSCALL_OPEN                  2
+#define SYSCALL_CLOSE                 3
+#define SYSCALL_READ                  4
+#define SYSCALL_WRITE                 5
+#define SYSCALL_SEEK                  6
+#define SYSCALL_MMAP                  7
+#define SYSCALL_MUNMAP                8
+#define SYSCALL_GETPID                9
+#define SYSCALL_GETPPID              10
+#define SYSCALL_EXEC                 11
+#define SYSCALL_CLONE                12
+#define SYSCALL_WAIT                 13
+#define SYSCALL_UNAME                14
+#define SYSCALL_SETHOSTNAME          15
+#define SYSCALL_DELETE               16
+#define SYSCALL_LSTAT                17
+#define SYSCALL_GETCWD               18
+#define SYSCALL_CHDIR                19
+#define SYSCALL_IOCTL                20
+#define SYSCALL_SCHED_YIELD          21
+#define SYSCALL_SET_DEADLINES        22
+#define SYSCALL_PIPE                 23
+#define SYSCALL_DUP                  24
+#define SYSCALL_DUP2                 25
+#define SYSCALL_SYSCONF              26
+#define SYSCALL_ACCESS               27
+#define SYSCALL_GET_THREAD_SCHED     28
+#define SYSCALL_SET_THREAD_SCHED     29
+#define SYSCALL_FCNTL                30
+#define SYSCALL_EXIT_THREAD          31
+#define SYSCALL_GETRANDOM            32
+#define SYSCALL_MPROTECT             33
+#define SYSCALL_SYNC                 34
+#define SYSCALL_SET_MAC_CAPABILITIES 35
+#define SYSCALL_LOCK_MAC             36
+#define SYSCALL_ADD_MAC_FILTER       37
+#define SYSCALL_SET_MAC_ENFORCEMENT  38
+#define SYSCALL_MOUNT                39
+#define SYSCALL_UMOUNT               40
+#define SYSCALL_READLINK             41
+#define SYSCALL_GETDENTS             42
+#define SYSCALL_CREATE               43
 
 #endif // _SYSCALL_H
diff --git mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
index 09c724d..a96c912 100644
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -5,7 +5,9 @@ rtdl_sources += files(
 
 libc_sources += files(
 	'generic/entry.cpp',
-	'generic/generic.cpp'
+	'generic/generic.cpp',
+	'generic/thread.cpp',
+	'generic/thread.S'
 )
 
 if not no_headers
@@ -69,5 +71,23 @@ if not headers_only
 		install: true,
 		install_dir: get_option('libdir')
 	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
 endif
 
