#! /bin/sh

# Copyright (C) 2022-2025 mintsuki

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

set -e

IFS=" ""	"'
'

LC_COLLATE=C
export LC_COLLATE

umask 0022

jinx_major_ver="0.6"
jinx_minor_ver="15"

jinx_version="${jinx_major_ver}.${jinx_minor_ver}"

debian_snapshot="20250627T143139Z"

XBPS_VERSION=0.60.5
XBPS_SHA256SUM=fba39edfdcfeb6f7e3f348a091453fefb087089999cf5bea20ea65ac6cf009dc

die() {
    echo "$1"
    exit 1
}

if [ -z "$1" ]; then
    die "$0: no command specified."
fi

cmd_help() {
    echo "usage: $0 <command> <package(s)>"
    printf "\n   help|--help        Displays this message"
    printf "\n   version|--version  Prints the version"
    printf "\n   init               Initialises a build directory"
    printf "\n   build              Builds package(s), does incremental builds"
    printf "\n   build-if-needed    Builds package(s) if necessary"
    printf "\n   rebuild            Rebuilds package(s)"
    printf "\n   host-build         Same as build, but for host package(s)"
    printf "\n   host-rebuild       Same as rebuild, but for host package(s)"
    printf "\n   regenerate|regen   Regenerates patch for package(s) and re-runs prepare step"
    printf "\n   install            Installs package(s)"
    printf "\n   reinstall          Reinstalls package(s)"
    printf "\n   rebuild-cache      Rebuilds Jinx cache"
    printf "\n\nexample: $0 build-if-needed '*'\n"
}

cmd_init() {
    if ! [ -f "$1"/Jinxfile ]; then
        die "$0: Provided source directory contains no Jinxfile"
    fi

    srcdir="$1"

    if [ -f ".jinx-parameters" ]; then
        die "$0: Current directory already initialised, run '$0 deinit' first"
    fi

    if [ -f "Jinxfile" ]; then
        die "$0: In-tree builds are not supported"
    fi

    cat <<EOF >.jinx-parameters
#! /bin/sh

JINX_SOURCE_DIR="${srcdir}"
JINX_ARCH="$(uname -m)"
EOF

    shift 1

    for p in "$@"; do
        echo "JINX_$p" | sed 's/=/="/g;s/$/"/g' >>.jinx-parameters
    done

    echo "Initialised with '${srcdir}' as source directory"
}

case "$1" in
    version|--version)
        echo "Jinx version $jinx_version"
        exit 0
        ;;
    help|--help)
        cmd_help
        exit 0
        ;;
    init)
        shift 1
        cmd_init "$@"
        exit 0
        ;;
esac

if ! [ "$(uname -s)" = "Linux" ]; then
    die "$0: Jinx only supports running on Linux hosts."
fi

script_name="$(basename "$0")"
script_dir="$(dirname "$0")"
if [ "$script_dir" = "." ] || [ -z "$script_dir" ]; then
    if echo "$0" | grep "/" >/dev/null 2>&1; then
        script_dir=.
    else
        script_dir="$(dirname $(which "${script_name}"))"
    fi
fi
script_dir="$(cd "${script_dir}" && pwd -P)"
script="${script_dir}/${script_name}"

in_container=false
if [ "$script" = "/base_dir/jinx" ]; then
    in_container=true
fi

case "$1" in
    install)
        ;;
    *)
        if [ "${in_container}" = "false" ] && [ "$(id -u)" = "0" ]; then
            die "$0: Jinx does not support running as root."
        fi
        ;;
esac

if [ -z "$JINX_PARALLELISM" ]; then
    max_threads_by_mem="$(( ((($(free | awk '/^Mem:/{print $2}') + 1048575) / 1048576) + 1) / 2 ))"
    parallelism="$(nproc 2>/dev/null || echo 1)"
    parallelism="$(( $parallelism < $max_threads_by_mem ? $parallelism : $max_threads_by_mem ))"
else
    parallelism="$JINX_PARALLELISM"
fi

if [ "$in_container" = "false" ]; then
    build_dir="$(pwd -P)"
else
    build_dir=/build_dir
fi

if ! [ -f "${build_dir}"/.jinx-parameters ]; then
    die "$0: Please run '$0 init <source dir> <parameters>' first"
fi

. "${build_dir}"/.jinx-parameters

if [ "$in_container" = "false" ]; then
    base_dir="$(cd "$JINX_SOURCE_DIR" && pwd -P)"
else
    base_dir=/base_dir
fi

JINX_CONFIG_FILE="${base_dir}/Jinxfile"

if ! [ -d "$(dirname "$JINX_CONFIG_FILE")" ]; then
    die "$0: cannot access Jinxfile directory"
fi
JINX_CONFIG_FILE="$(cd "$(dirname "$JINX_CONFIG_FILE")" && pwd -P)"/"$(basename "$JINX_CONFIG_FILE")"

if [ -z "$JINX_CACHE_DIR" ]; then
    JINX_CACHE_DIR="${base_dir}/.jinx-cache"
fi
if ! [ -d "$(dirname "$JINX_CACHE_DIR")" ]; then
    die "$0: cannot access cache directory parent"
fi

if [ "$in_container" = "false" ]; then
    mkdir -p "$JINX_CACHE_DIR"
    JINX_CACHE_DIR="$(cd "$JINX_CACHE_DIR" && pwd -P)"

    export PATH="${JINX_CACHE_DIR}/xbps/bin:${PATH}:/usr/sbin:/sbin"
    export LD_LIBRARY_PATH="${JINX_CACHE_DIR}/xbps/lib:${PATH}"

    mkdir -p "${base_dir}/sources" "${build_dir}/host-builds" "${build_dir}/host-pkgs" "${build_dir}/builds" "${build_dir}/pkgs"
fi

apt_cache="$JINX_CACHE_DIR/apt-cache"

temp_collect=""

cleanup_done=no
cleanup() {
    if [ "${cleanup_done}" = "yes" ]; then
        return
    fi
    cleanup_done=yes
    eval "rm -rf ${temp_collect}"
}

trap 'cleanup; exit 1' INT TERM HUP QUIT
trap 'cleanup' EXIT

make_temp() {
    mkdir -p "$JINX_CACHE_DIR/tmp"
    tmp="$(mktemp "$JINX_CACHE_DIR/tmp/tmp.XXXXXXXX")"
    temp_collect="${temp_collect} \"${tmp}\""
    if [ "$1" = "-d" ]; then
        rm -f "${tmp}"
        mkdir -p "${tmp}"
    fi
}

build_hostdeps() {
    for hostdep in ${hostdeps} ${hostrundeps}; do
        [ -f "${base_dir}"/host-recipes/${hostdep} ] || die "missing host dependency '${hostdep}' for recipe '${name}'"

        [ -d "${build_dir}"/host-pkgs/${hostdep} ] && continue

        "${script}" host-build ${hostdep}
    done
}

build_deps() {
    for dep in ${deps} ${builddeps}; do
        [ -f "${base_dir}"/recipes/${dep} ] || die "missing dependency '${dep}' for recipe '${name}'"

        (
            set -e
            unset version
            unset from_source
            . "${base_dir}"/recipes/${dep}
            if ! [ -z "${from_source}" ]; then
                version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            fi

            [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]
        ) && continue

        "${script}" build ${dep}
    done
}

get_hostdeps_file_run() {
    deps_to_do=""

    for hostdep in ${hostrundeps}; do
        grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1 || deps_to_do="${deps_to_do} ${hostdep}"
        grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1 || printf " ${hostdep} " >> "${hostdeps_file}"
    done

    for hostdep in ${deps_to_do}; do
        "${script}" internal-get-hostdeps-file ${hostdep} "${hostdeps_file}"
    done
}

get_hostdeps_file() {
    deps_to_do=""

    for hostdep in ${hostdeps} ${hostrundeps}; do
        grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1 || deps_to_do="${deps_to_do} ${hostdep}"
        grep " ${hostdep} " "${hostdeps_file}" >/dev/null 2>&1 || printf " ${hostdep} " >> "${hostdeps_file}"
    done

    for hostdep in ${deps_to_do}; do
        "${script}" internal-get-hostdeps-file ${hostdep} "${hostdeps_file}"
    done
}

get_builddeps_file() {
    deps_to_do=""

    for dep in ${deps} ${builddeps}; do
        grep " ${dep} " "${deps_file}" >/dev/null 2>&1 || deps_to_do="${deps_to_do} ${dep}"
        grep " ${dep} " "${deps_file}" >/dev/null 2>&1 || printf " ${dep} " >> "${deps_file}"
    done

    for dep in ${deps_to_do}; do
        "${script}" internal-get-deps-file ${dep} "${deps_file}"
    done
}

get_deps_file() {
    deps_to_do=""

    for dep in ${deps}; do
        grep " ${dep} " "${deps_file}" >/dev/null 2>&1 || deps_to_do="${deps_to_do} ${dep}"
        grep " ${dep} " "${deps_file}" >/dev/null 2>&1 || printf " ${dep} " >> "${deps_file}"
    done

    for dep in ${deps_to_do}; do
        "${script}" internal-get-deps-file ${dep} "${deps_file}"
    done
}

run_in_container1() {
    run_in_cont1_root="$1"
    shift 1

    unshare --user --map-root-user --mount --pid --fork -- sh -c "
        set -e

        mount --rbind --make-rslave /dev '${run_in_cont1_root}/dev'
        mount -t proc proc '${run_in_cont1_root}/proc'
        mount --rbind --make-rslave /sys '${run_in_cont1_root}/sys'
        mount -t tmpfs run '${run_in_cont1_root}/run'
        mount -t tmpfs tmpfs '${run_in_cont1_root}/tmp'
        mount -t tmpfs tmpfs '${run_in_cont1_root}/var/tmp'

        mount -o ro --bind /etc/resolv.conf '${run_in_cont1_root}/etc/resolv.conf'
        mount --bind '${apt_cache}' '${run_in_cont1_root}/var/cache/apt/archives'

        env -i PATH="${PATH}" chroot '${run_in_cont1_root}' /bin/sh -c '
            set -e

            LD_PRELOAD=/nochown.so \
            HOME=/root \
            LANG=en_US.UTF-8 \
            LC_COLLATE=C \
            PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin \
            LD_LIBRARY_PATH=/usr/local/lib64:/usr/local/lib:/usr/lib64:/usr/lib \
            DEBIAN_FRONTEND=noninteractive \
            $(for arg in "$@"; do echo '"'"$(echo "${arg}" | sed 's/"/\\"/g')"'" \'; done)
            # keep this whitespace
        '
    "
}

check_duplicates() {
    for elem in $(cd "$1" && find .); do
        if [ -f "$2"/${elem} ] || [ -L "$2"/${elem} ]; then
            return 1
        fi
    done
}

prepare_container() {
    cd "${build_dir}"

    make_temp
    hostdeps_file="${tmp}"
    make_temp
    deps_file="${tmp}"

    build_hostdeps
    build_deps

    get_hostdeps_file
    get_builddeps_file

    make_temp -d
    container_pkgs="${tmp}"
    make_temp -d
    sysroot_dir="${tmp}"

    for dep in $(cat "${deps_file}"); do
        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
            xbps-install -y -r "${sysroot_dir}" -R "${build_dir}"/pkgs "${dep}" >/dev/null 2>&1
    done

    if [ "$JINX_NATIVE_MODE" = "yes" ] && [ -z "$cross_compile" ]; then
        imgroot="${sysroot_dir}"
    else
        for hostdep in $(cat "${hostdeps_file}"); do
            if ! check_duplicates "${build_dir}"/host-pkgs/${hostdep}/usr/local "${container_pkgs}"; then
                die "jinx: error: Dependency '${hostdep}' contains file confilcts"
            fi
            cp -Pplr "${build_dir}"/host-pkgs/${hostdep}/usr/local/. "${container_pkgs}"/
        done

        imagedeps="$(echo "${imagedeps}" | xargs -n1 | sort -u | xargs)"

        pkgset=""
        for pkg in ${imagedeps}; do
            pkgset="${pkgset}${pkg}/"

            if [ -f "$JINX_CACHE_DIR/sets/${pkgset}.image/.jinx-set-valid" ]; then
                continue
            fi

            rm -rf "$JINX_CACHE_DIR/sets/${pkgset}"
            mkdir -p "$JINX_CACHE_DIR/sets/${pkgset}"

            want_link='l'
            want_experimental=''
            if echo "${pkg}" | grep -q '^experimental:'; then
                want_link=''
                want_experimental='-t experimental'
                pkg="$(echo "${pkg}" | sed 's/^experimental://g')"
            fi

            cp -Pp${want_link}rf "$JINX_CACHE_DIR/sets/${pkgset}../.image" "$JINX_CACHE_DIR/sets/${pkgset}.image"

            rm -f "$JINX_CACHE_DIR/sets/${pkgset}.image/.jinx-set-valid"

            run_in_container1 "$JINX_CACHE_DIR/sets/${pkgset}.image" apt-get install -y ${want_experimental} "${pkg}"

            # Fix permissions of files
            for f in $(find "$JINX_CACHE_DIR/sets/${pkgset}.image" -perm 000 2>/dev/null); do
                chmod 755 "$f"
            done

            touch "$JINX_CACHE_DIR/sets/${pkgset}.image/.jinx-set-valid"
        done

        imgroot="$JINX_CACHE_DIR/sets/${pkgset}.image"
    fi
}

run_in_container() {
    if [ "${allow_network}" = "yes" ]; then
        unshare_net_flag=""
    else
        unshare_net_flag="--net"
    fi

    if [ ! -z "$TERM" ]; then
        run_in_cont_term="TERM=\"$TERM\""
    fi

    if ! [ -z "$COLORTERM" ]; then
        run_in_cont_colorterm="COLORTERM=\"$COLORTERM\""
    fi

    mkdir -p "${imgroot}/base_dir" "${imgroot}/sources" "${imgroot}/build_dir"

    container_pkgs_native_mount=""
    sysroot_native_mount=""
    if ( [ "$JINX_NATIVE_MODE" = "yes" ] && [ "$cross_compile" = "yes" ] ) || ( ! [ "$JINX_NATIVE_MODE" = "yes" ] ); then
        mkdir -p "${imgroot}/sysroot"

        container_pkgs_native_mount="mount -o ro --bind '${container_pkgs}' '${imgroot}/usr/local'"
        sysroot_native_mount="mount -o ro --bind '${sysroot_dir}' '${imgroot}/sysroot'"

        run_in_cont_lang=en_US.UTF-8
    else
        if ! [ -z "$JINX_NATIVE_LANG" ]; then
            run_in_cont_lang="$JINX_NATIVE_LANG"
        else
            run_in_cont_lang=C
        fi
    fi

    shadow_git_dir_build=""
    if [ -d "${build_dir}"/.git ]; then
        make_temp -d
        shadow_git_dir_build="mount --bind '${tmp}' '${imgroot}/build_dir/.git'"
    fi

    shadow_git_dir_base=""
    if [ -d "${base_dir}"/.git ]; then
        make_temp -d
        shadow_git_dir_base="mount --bind '${tmp}' '${imgroot}/base_dir/.git'"
    fi

    unshare --user --map-root-user --mount --pid --fork ${unshare_net_flag} -- sh -c "
        set -e

        mount -o ro --bind '${imgroot}' '${imgroot}'

        mount --rbind --make-rslave /dev '${imgroot}/dev'
        mount -t proc proc '${imgroot}/proc'
        mount --rbind --make-rslave /sys '${imgroot}/sys'
        mount -t tmpfs run '${imgroot}/run'
        mount -t tmpfs tmpfs '${imgroot}/tmp'
        mount -t tmpfs tmpfs '${imgroot}/var/tmp'

        mount -o ro --bind /etc/resolv.conf '${imgroot}/etc/resolv.conf'

        mount ${container_base_dir_ro} --bind '${base_dir}' '${imgroot}/base_dir'
        mount --bind '${base_dir}/.jinx-cache/tmp' '${imgroot}/base_dir/.jinx-cache/tmp'
        mount --bind '${build_dir}' '${imgroot}/build_dir'
        mount ${container_sources_ro} --bind '${base_dir}/sources' '${imgroot}/base_dir/sources'
        ${container_pkgs_native_mount}
        ${sysroot_native_mount}
        ${shadow_git_dir_base}
        ${shadow_git_dir_build}

        env -i PATH="${PATH}" chroot '${imgroot}' /bin/sh -c '
            set -e

            cd /build_dir

            LD_PRELOAD=/nochown.so \
            HOME=/root \
            LANG=${run_in_cont_lang} \
            LC_COLLATE=C \
            PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin \
            LD_LIBRARY_PATH=/usr/local/lib64:/usr/local/lib:/usr/lib64:/usr/lib \
            ${run_in_cont_term} \
            ${run_in_cont_colorterm} \
            JINX_PARALLELISM=${parallelism} \
            JINX_CONFIG_FILE=/base_dir/Jinxfile \
            JINX_SOURCE_DIR=/base_dir \
            /bin/bash /base_dir/jinx \
            $(for arg in "$@"; do echo '"'"$(echo "${arg}" | sed 's/"/\\"/g')"'" \'; done)
            # keep this whitespace
        '
    "

    rm -rf "${imgroot}/sysroot" "${imgroot}/base_dir" "${imgroot}/sources" "${imgroot}/build_dir"
}

destroy_container() {
    rm -rf "${container_pkgs}" "${sysroot_dir}"
}

do_hg_fetch() {
    hg clone "${hg_url}" "${base_dir}"/sources/${name}
    ( cd "${base_dir}"/sources/${name} && hg up "${tag}" )
}

do_git_fetch() {
    if [ -z "${commit}" ]; then
        die "* error: Git commit not specified"
    fi

    if ! ( echo "${commit}" | grep -qE '^[0-9a-f]{40}$' ); then
        die "* error: Invalid commit hash"
    fi

    if [ "${shallow}" = "no" ]; then
        git clone "${git_url}" "${base_dir}"/sources/${name}
        git -C "${base_dir}"/sources/${name} -c advice.detachedHead=false checkout "${commit}"
    else
        git clone "${git_url}" -c advice.detachedHead=false --revision="${commit}" --depth=1 "${base_dir}"/sources/${name}
    fi
}

do_tarball_fetch() {
    tarball_path="${base_dir}"/sources/"$(basename "${tarball_url}")"

    if ! [ -f "$tarball_path" ]; then
        make_temp
        download_path="${tmp}"

        curl -L -o "${download_path}" "${tarball_url}"
        mv "${download_path}" "${tarball_path}"
    fi

    checksum_verified=no

    if ! [ -z "${tarball_sha256}" ]; then
        actual_sha256="$(sha256sum "${tarball_path}" | awk '{print $1;}')"
        if ! [ ${actual_sha256} = ${tarball_sha256} ]; then
            die "* error: Failed to verify SHA256 for ${name}.
  Expected '${tarball_sha256}';
  got '${actual_sha256}'."
        fi
        checksum_verified=yes
    fi
    if ! [ -z "${tarball_sha512}" ]; then
        actual_sha512="$(sha512sum "${tarball_path}" | awk '{print $1;}')"
        if ! [ ${actual_sha512} = ${tarball_sha512} ]; then
            die "* error: Failed to verify SHA512 for ${name}.
  Expected '${tarball_sha512}';
  got '${actual_sha512}'."
        fi
        checksum_verified=yes
    fi
    if ! [ -z "${tarball_blake2b}" ]; then
        actual_blake2b="$(b2sum "${tarball_path}" | awk '{print $1;}')"
        if ! [ ${actual_blake2b} = ${tarball_blake2b} ]; then
            die "* error: Failed to verify BLAKE2B for ${name}.
  Expected '${tarball_blake2b}';
  got '${actual_blake2b}'."
        fi
        checksum_verified=yes
    fi

    if [ "${checksum_verified}" = "no" ]; then
        die "* error: No checksum method specified for ${name}"
    fi

    make_temp -d
    extract_dir="${tmp}"

    ( cd "${extract_dir}" && tar -xf "${tarball_path}" )

    mv "${extract_dir}"/* "${base_dir}"/sources/${name} >/dev/null 2>&1 || (
        mkdir -p "${base_dir}"/sources/${name}
        mv "${extract_dir}"/* "${base_dir}"/sources/${name}/
    )

    rm -rf "${extract_dir}" "${tarball_path}"
}

get_real_source_dir() {
    unset is_local_package
    unset is_sourceless_package

    if [ -z "${source_dir}" ] && [ -z "${git_url}" ] && [ -z "${hg_url}" ] && [ -z "${tarball_url}" ]; then
        source_dir=/dev/null
        is_local_package=true
        is_sourceless_package=true
        return
    fi

    if [ -z "${source_dir}" ]; then
        source_dir="${base_dir}"/sources/${name}
    else
        source_dir="${base_dir}"/"${source_dir}"
        if ! [ -d "${source_dir}" ]; then
            die "* source_dir of a local package is not a valid path"
        fi
        is_local_package=true
    fi
}

default_recipe_steps() {
    early_prepare() {
        :
    }

    prepare() {
        :
    }

    configure() {
        :
    }

    build() {
        :
    }

    package() {
        :
    }
}

source_source_recipe() {
    if [ -f "${base_dir}"/source-recipes/$1 ]; then
        . "${base_dir}"/source-recipes/$1
    elif [ -f "${base_dir}"/recipes/$1 ]; then
        . "${base_dir}"/recipes/$1

        unset deps
        unset builddeps
        unset hostrundeps
        imagedeps="${source_imagedeps}"
        hostdeps="${source_hostdeps}"
        deps="${source_deps}"
        allow_network="${source_allow_network}"
    else
        die "* could not find source recipe '$1'"
    fi
}

do_fetch() {
    default_recipe_steps

    source_source_recipe $1

    get_real_source_dir

    sysroot_dir="/sysroot"

    if ! [ "${is_local_package}" = true ] && ! [ "${is_sourceless_package}" = true ]; then
        if ! [ -z "${git_url}" ]; then
            do_git_fetch
        elif ! [ -z "${hg_url}" ]; then
            do_hg_fetch
        elif ! [ -z "${tarball_url}" ]; then
            do_tarball_fetch
        fi
    fi

    if ! [ "${is_sourceless_package}" = true ]; then
        (
            cd "${source_dir}"
            early_prepare
        )
    fi
}

do_patch() {
    source_source_recipe $1

    get_real_source_dir

    make_temp
    patch_trash="${tmp}"

    cd "${source_dir}"

    needs_match_timestamps=no
    rm -rf "${base_dir}"/sources/${name}-clean
    if [ -d "${base_dir}"/patches/${name} ]; then
        for patch in "${base_dir}"/patches/${name}/*; do
            [ "${patch}" = "${base_dir}/patches/${name}/*" ] && break
            [ "${patch}" = "${base_dir}"/patches/${name}/jinx-working-patch.patch ] && continue

            if ! [ -d "${base_dir}"/sources/${name}-clean ]; then
                cp -rp "${source_dir}" "${base_dir}"/sources/${name}-clean
                needs_match_timestamps=yes
            fi

            patch --no-backup-if-mismatch -p1 -r "${patch_trash}" < "${patch}"
        done

        if [ "${needs_match_timestamps}" = yes ]; then
            # make sure timestamps match
            for f in $(diff -rq --no-dereference "${base_dir}"/sources/${name}-clean "${source_dir}" | sed '/^Only in/d;s/^Files //g;s/ and.*$//g'); do
                touch --reference="$f" "$(echo "$f" | sed "s|sources/${name}-clean|sources/${name}|g")"
            done
            rm -rf "${base_dir}"/sources/${name}-clean
        fi
    fi

    cp -rp "${source_dir}" "${base_dir}"/sources/${name}-clean

    if [ -f "${base_dir}"/patches/${name}/jinx-working-patch.patch ]; then
        patch --no-backup-if-mismatch -p1 -r "${patch_trash}" < "${base_dir}"/patches/${name}/jinx-working-patch.patch

        # make sure timestamps match
        for f in $(diff -rq --no-dereference "${base_dir}"/sources/${name}-clean "${source_dir}" | sed '/^Only in/d;s/^Files //g;s/ and.*$//g'); do
            touch --reference="$f" "$(echo "$f" | sed "s|sources/${name}-clean|sources/${name}|g")"
        done
    fi

    cp -rp "${source_dir}" "${base_dir}"/sources/${name}-workdir

    cd "${base_dir}"
}

do_prepare() {
    default_recipe_steps

    source_source_recipe $1

    get_real_source_dir

    sysroot_dir="/sysroot"

    cd "${source_dir}"
    prepare
    cd "${base_dir}"
}

do_configure_host() {
    default_recipe_steps

    unset from_source
    . "${base_dir}"/host-recipes/$1

    mkdir -p "${build_dir}"/host-builds/${name}

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr/local"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/host-builds/${name}
    configure
    cd "${base_dir}"
}

do_build_host() {
    default_recipe_steps

    unset from_source
    . "${base_dir}"/host-recipes/$1

    mkdir -p "${build_dir}"/host-builds/${name}

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr/local"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/host-builds/${name}
    build
    cd "${base_dir}"
}

do_package_host() {
    default_recipe_steps

    unset from_source
    . "${base_dir}"/host-recipes/$1

    dest_dir="${build_dir}"/host-pkgs/${name}

    rm -rf "${dest_dir}"
    mkdir -p "${dest_dir}"

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr/local"
    sysroot_dir="/sysroot"

    mkdir -p "${dest_dir}${prefix}"

    cd "${build_dir}"/host-builds/${name}
    package

    # Remove libtool files
    for i in $(find "${dest_dir}${prefix}" -name "*.la"); do
        rm -rvf $i
    done

    cd "${base_dir}"
}

do_configure() {
    default_recipe_steps

    unset from_source
    . "${base_dir}"/recipes/$1

    mkdir -p "${build_dir}"/builds/${name}

    if ! [ -z "${from_source}" ] || ! [ -z "${tarball_url}" ] || ! [ -z "${git_url}" ] || ! [ -z "${hg_url}" ] || ! [ -z "${source_dir}" ]; then
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"
        else
            from_source=${name}
        fi

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/builds/${name}
    configure
    cd "${base_dir}"
}

do_build() {
    default_recipe_steps

    unset from_source
    . "${base_dir}"/recipes/$1

    mkdir -p "${build_dir}"/builds/${name}

    if ! [ -z "${from_source}" ] || ! [ -z "${tarball_url}" ] || ! [ -z "${git_url}" ] || ! [ -z "${hg_url}" ] || ! [ -z "${source_dir}" ]; then
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"
        else
            from_source=${name}
        fi

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr"
    sysroot_dir="/sysroot"

    cd "${build_dir}"/builds/${name}
    build
    cd "${base_dir}"
}

do_package() {
    default_recipe_steps

    unset from_source
    . "${base_dir}"/recipes/$1

    dest_dir="${build_dir}"/pkgs/${name}

    rm -rf "${dest_dir}"
    mkdir -p "${dest_dir}"

    if ! [ -z "${from_source}" ] || ! [ -z "${tarball_url}" ] || ! [ -z "${git_url}" ] || ! [ -z "${hg_url}" ] || ! [ -z "${source_dir}" ]; then
        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
            source_dir="$(unset source_dir && source_source_recipe ${from_source} && echo "$source_dir")"
        else
            from_source=${name}
        fi

        if [ -z "${source_dir}" ]; then
            source_dir="${base_dir}"/sources/${from_source}
        else
            source_dir="${base_dir}"/"${source_dir}"
        fi
    fi

    prefix="/usr"
    sysroot_dir="/sysroot"

    mkdir -p "${dest_dir}${prefix}"

    cd "${build_dir}"/builds/${name}
    package

    # Remove libtool files
    for i in $(find "${dest_dir}${prefix}" -name "*.la"); do
        rm -rvf $i
    done

    cd "${base_dir}"
}

clean_sources() {
    rm -rf "${base_dir}"/sources/$1
    rm -rf "${base_dir}"/sources/$1-clean
    rm -rf "${base_dir}"/sources/$1-workdir
    rm -rf "${base_dir}"/sources/$1.version
    rm -rf "${base_dir}"/sources/$1.patched
    rm -rf "${base_dir}"/sources/$1.prepared
}

need_repatch() {
    rm -rf "${base_dir}"/sources/$1

    if [ -d "${base_dir}"/sources/$1-clean ]; then
        mv "${base_dir}"/sources/$1-clean "${base_dir}"/sources/$1
    fi

    rm -rf "${base_dir}"/sources/$1-workdir
    rm -rf "${base_dir}"/sources/$1.patched
    rm -rf "${base_dir}"/sources/$1.prepared
}

do_source() {
    source_source_recipe $1

    get_real_source_dir

    cross_compile=yes
    prepare_container

    if ! [ -f "${base_dir}"/sources/$1.version ] || ! [ "$(cat "${base_dir}"/sources/$1.version)" = "${version}" ]; then
        (
            allow_network="yes"
            clean_sources $1
            [ "${is_local_package}" = true ] || container_base_dir_ro="-o ro"
            run_in_container internal-fetch $1
            echo "${version}" >"${base_dir}"/sources/$1.version
        )
    fi

    if ! [ -f "${base_dir}"/sources/$1.patched ]; then
        (
            if ! [ "${is_local_package}" = true ] && ! [ "${is_sourceless_package}" = true ]; then
                allow_network="yes"
                run_in_container internal-patch $1
            fi
            touch "${base_dir}"/sources/$1.patched
        )
    fi

    if ! [ -f "${base_dir}"/sources/$1.prepared ]; then
        (
            if ! [ "${is_sourceless_package}" = true ]; then
                [ "${is_local_package}" = true ] || container_base_dir_ro="-o ro"
                run_in_container internal-prepare $1
            fi
            touch "${base_dir}"/sources/$1.prepared
        )
    fi

    destroy_container
}

do_rebuild() {
    rm -rf "${build_dir}"/builds/"$1"

    do_pkg "$1"
}

do_host_rebuild() {
    rm -rf "${build_dir}"/host-builds/"$1"

    do_host_pkg "$1"
}

do_regen() {
    source_source_recipe $1

    [ -f "${base_dir}"/sources/$1.patched ] || die "cannot regenerate non-built package"

    get_real_source_dir

    make_temp
    patch_file="${tmp}"

    if ! [ "${is_local_package}" = true ]; then
        cd "${base_dir}"/sources

        # exclude version control dirs
        make_temp -d
        vc_dir_clean="${tmp}"
        rm -rf "${vc_dir_clean}"
        make_temp -d
        vc_dir_workdir="${tmp}"
        rm -rf "${vc_dir_workdir}"

        if ! [ -z "${git_url}" ]; then
            mv $1-clean/.git "${vc_dir_clean}"
            mv $1-workdir/.git "${vc_dir_workdir}"
        elif ! [ -z "${hg_url}" ]; then
            mv $1-clean/.hg "${vc_dir_clean}"
            mv $1-workdir/.hg "${vc_dir_workdir}"
        fi

        git diff --no-index --no-prefix $1-clean $1-workdir >"${patch_file}" || true

        if ! [ -z "${git_url}" ]; then
            mv "${vc_dir_clean}" $1-clean/.git
            mv "${vc_dir_workdir}" $1-workdir/.git
        elif ! [ -z "${hg_url}" ]; then
            mv "${vc_dir_clean}" $1-clean/.hg
            mv "${vc_dir_workdir}" $1-workdir/.hg
        fi

        if [ -s "${patch_file}" ]; then
            mkdir -p "${base_dir}"/patches/$1
            mv "${patch_file}" "${base_dir}"/patches/$1/jinx-working-patch.patch
        fi

        cd "${base_dir}"

        rm -rf "${source_dir}"
        cp -rp "${base_dir}"/sources/$1-workdir "${source_dir}"
    fi

    rm -rf "${base_dir}"/sources/$1.prepared

    cross_compile=yes
    prepare_container
    run_in_container internal-prepare $1
    destroy_container
}

do_host_pkg() {
    unset from_source
    . "${base_dir}"/host-recipes/$1

    echo "* building host package: $name"

    if ! [ -z "${from_source}" ]; then
        ( do_source "${from_source}" )
    else
        ( do_source "${name}" )
    fi

    cross_compile=yes
    prepare_container

    container_sources_ro="-o ro"
    if ! [ -d "${build_dir}"/host-builds/$1 ]; then
        run_in_container internal-configure-host $1
    fi
    run_in_container internal-build-host $1
    rm -rf "${build_dir}"/host-pkgs/$1
    run_in_container internal-package-host $1
    unset container_sources_ro

    destroy_container

    if [ "$JINX_CLEAN_WORKDIRS" = "yes" ]; then
        if ! [ "$clean_workdirs" = "no" ]; then
            rm -rf "${build_dir}"/host-builds/$1

            if [ -z "${from_source}" ]; then
                source_source_recipe $1
            else
                source_source_recipe ${from_source}
            fi

            get_real_source_dir

            if ! [ "${is_sourceless_package}" = true ] && ! [ "${is_local_package}" = true ]; then
                clean_sources "${name}"
            fi
        fi
    fi
}

do_pkg() {
    unset from_source
    . "${base_dir}"/recipes/$1

    echo "* building package: $name"

    if ! [ -z "${from_source}" ]; then
        version=$(unset version && source_source_recipe ${from_source} && echo "$version")
    fi

    case "${version}" in
        *git)
            if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
                rm -rf "${build_dir}"/builds/"$1"
                (
                if ! [ -z "${from_source}" ]; then
                    name=$(unset name && source_source_recipe ${from_source} && echo "${name}")
                fi
                clean_sources "${name}"
                )
            fi
            ;;
    esac

    if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
        rm -rf "${build_dir}"/builds/"$1"
        (
        if ! [ -z "${from_source}" ]; then
            name=$(unset name && source_source_recipe ${from_source} && echo "${name}")
        fi
        need_repatch "${name}"
        )
    fi

    if ! [ -z "${from_source}" ]; then
        ( do_source "${from_source}" )
    else
        ( do_source "${name}" )
    fi

    prepare_container

    container_sources_ro="-o ro"
    if ! [ -d "${build_dir}"/builds/$1 ]; then
        run_in_container internal-configure $1
    fi
    run_in_container internal-build $1
    rm -rf "${build_dir}"/pkgs/$1
    run_in_container internal-package $1
    unset container_sources_ro

    destroy_container

    xbps_deps=""
    for dep in ${deps}; do
        bootstrap_pkg=$(unset bootstrap_pkg && . "${base_dir}"/recipes/${dep} && echo "${bootstrap_pkg}")
        if [ "${bootstrap_pkg}" = "yes" ]; then
            continue
        fi

        xbps_deps="${xbps_deps} ${dep}>=0.0"
    done

    dest_dir="${build_dir}"/pkgs/${name}

    cd "${build_dir}"/pkgs
        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
    xbps-create \
        -A $JINX_ARCH \
        -s ${name} \
        -n ${name}-${version}_${revision} \
        -D "${xbps_deps}" \
        "${dest_dir}"

    rm -rf "${dest_dir}"

        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
    xbps-rindex \
        -a "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps \
        -f

    if [ "$JINX_CLEAN_WORKDIRS" = "yes" ]; then
        if ! [ "$clean_workdirs" = "no" ]; then
            rm -rf "${build_dir}"/builds/$1

            if [ -z "${from_source}" ]; then
                source_source_recipe $1
            else
                source_source_recipe ${from_source}
            fi

            get_real_source_dir

            if ! [ "${is_sourceless_package}" = true ] && ! [ "${is_local_package}" = true ]; then
                clean_sources "${name}"
            fi
        fi
    fi
}

cmd_host_build() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/host-recipes '&&' echo "${ppkg}" ')' ); do
            ( do_host_pkg "${pkg}" )
        done
    done
}

cmd_build() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            ( do_pkg "${pkg}" )
        done
    done
}

cmd_build_if_needed() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            (
                set -e
                unset version
                unset from_source
                . "${base_dir}"/recipes/${pkg}
                if ! [ -z "${from_source}" ]; then
                    version=$(unset version && source_source_recipe ${from_source} && echo "$version")
                fi

                [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]
            ) && continue

            ( do_pkg "${pkg}" )
        done
    done
}

cmd_regen() {
    for i in "$@"; do
        ( do_regen "$i" )
    done
}

cmd_host_rebuild() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/host-recipes '&&' echo "${ppkg}" ')' ); do
            ( do_host_rebuild "${pkg}" )
        done
    done
}

cmd_rebuild() {
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            ( do_rebuild "${pkg}" )
        done
    done
}

cmd_install() {
    force_install=""
    if [ "$1" = "-f" ]; then
        force_install="$1"
        shift 1
    fi
    sysroot="$1"
    shift 1
    mkdir -m 755 -p "${sysroot}"

    pkgs_to_install=""
    for ppkg in "$@"; do
        for pkg in $(eval '(' cd "'${base_dir}'"/recipes '&&' echo "${ppkg}" ')' ); do
            bootstrap_pkg=$(unset bootstrap_pkg && . "${base_dir}"/recipes/${pkg} && echo "${bootstrap_pkg}")
            if [ "${bootstrap_pkg}" = "yes" ]; then
                continue
            fi

            pkgs_to_install="${pkgs_to_install} ${pkg}"
        done
    done

    files_to_ignore='\.keep
\.plist
/INSTALL
/REMOVE'

    make_temp
    all_files="${tmp}"

    for pkg in ${pkgs_to_install}; do
        echo "* installing ${pkg}..."

        (
        . "${base_dir}"/recipes/${pkg}

        if ! [ -z "${from_source}" ]; then
            version=$(unset version && source_source_recipe ${from_source} && echo "$version")
        fi

        if ! [ -f "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps ]; then
            if [ "$(id -u)" = "0" ]; then
                die "$0: a package needs to be built, but Jinx was invoked as root"
            fi
            ( do_pkg "${pkg}" )
        fi

        # xbps seems to only install the package every second time when reinstalling.
        # Remove the package to be sure it gets reinstalled.
        if ! [ -z "${force_install}" ]; then
            XBPS_ARCH=invalid \
            XBPS_TARGET_ARCH="${JINX_ARCH}" \
                xbps-remove -Ffy -r "${sysroot}" ${pkg} >/dev/null 2>&1 || true
        fi

        XBPS_ARCH=invalid \
        XBPS_TARGET_ARCH="${JINX_ARCH}" \
            xbps-install -y $force_install -r "${sysroot}" -R "${build_dir}"/pkgs ${pkg} >/dev/null 2>&1

        tar -tf "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps | ( grep -v "${files_to_ignore}" || true ) >>"${all_files}"
        )
    done

    echo "* checking for conflicts..."

    make_temp
    all_files_sorted="${tmp}"

    make_temp
    all_files_uniq="${tmp}"

    sort <"${all_files}" >"${all_files_sorted}"
    uniq <"${all_files_sorted}" >"${all_files_uniq}"

    dup_elements="$(comm -23 "${all_files_sorted}" "${all_files_uniq}" | uniq)"

    if ! [ -z "${dup_elements}" ]; then
        echo "* error: duplicate files were found."
        for elem in ${dup_elements}; do
            echo "  file path: ${elem}"
            printf "  in packages:"
            for pkg in ${pkgs_to_install}; do
                (
                . "${base_dir}"/recipes/${pkg}

                if ! [ -z "${from_source}" ]; then
                    version=$(unset version && source_source_recipe ${from_source} && echo "$version")
                fi

                if tar -tf "${build_dir}"/pkgs/${name}-${version}_${revision}.${JINX_ARCH}.xbps | ( grep -v "${files_to_ignore}" || true ) | grep -q "${elem}"; then
                    printf " ${pkg}"
                fi
                )
            done
            printf "\n"
        done
        exit 1
    fi
}

reinit_container() {
    chmod -R 777 "$JINX_CACHE_DIR/sets" 2>/dev/null || true
    chmod -R 777 "$JINX_CACHE_DIR/apt-cache" 2>/dev/null || true
    rm -rf "$JINX_CACHE_DIR/sets" "$JINX_CACHE_DIR/apt-cache"

    mkdir -p "${apt_cache}"

    mkdir -p "$JINX_CACHE_DIR/sets/.image"

    cat >"$JINX_CACHE_DIR/nochown.c" <<EOF
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int chown(const char *pathname, uid_t owner, gid_t group) {
    (void)pathname; (void)owner; (void)group;
    return 0;
}

int fchown(int fd, uid_t owner, gid_t group) {
    (void)fd; (void)owner; (void)group;
    return 0;
}

int lchown(const char *pathname, uid_t owner, gid_t group) {
    (void)pathname; (void)owner; (void)group;
    return 0;
}

int fchownat(int dirfd, const char *pathname,
             uid_t owner, gid_t group, int flags) {
    (void)dirfd; (void)pathname; (void)owner; (void)group; (void)flags;
    return 0;
}
EOF
    cc -O2 -pipe -std=gnu99 -Wall -Wextra -fPIC -shared "$JINX_CACHE_DIR/nochown.c" -o "$JINX_CACHE_DIR/sets/.image/nochown.so"
    rm "$JINX_CACHE_DIR/nochown.c"

    DEBOOTSTRAP_ARCH="$(uname -m)"
    case "${DEBOOTSTRAP_ARCH}" in
        i?86) DEBOOTSTRAP_ARCH=i386 ;;
        x86_64) DEBOOTSTRAP_ARCH=amd64 ;;
        arm*) DEBOOTSTRAP_ARCH=armhf ;;
        aarch64) DEBOOTSTRAP_ARCH=arm64 ;;
        loongarch64) DEBOOTSTRAP_ARCH=loong64 ;;
        ppc64le) DEBOOTSTRAP_ARCH=ppc64el ;;
    esac

    if ! command -v debootstrap >/dev/null 2>&1; then
        die "error: missing debootstrap command"
    fi

    DEBOOTSTRAP_PATH="$(command -v debootstrap)"
    make_temp -d
    TMP_PATH="${tmp}"
    cp "${DEBOOTSTRAP_PATH}" "${TMP_PATH}"/
    sed "s/HOST_ARCH=[^;#]*/HOST_ARCH=${DEBOOTSTRAP_ARCH}/g" "${DEBOOTSTRAP_PATH}" >"${TMP_PATH}/debootstrap"
    chmod +x "${TMP_PATH}/debootstrap"

    cat >"$JINX_CACHE_DIR/debootstrap_wrap.c" <<EOF
#include <unistd.h>

int main(int argc, char *argv[]) {
    (void)argc;
    argv[0] = "${DEBOOTSTRAP_PATH}";
    execv("${TMP_PATH}/debootstrap", argv);
    return 1;
}
EOF
    cc -O2 -pipe -std=gnu99 -Wall -Wextra "$JINX_CACHE_DIR/debootstrap_wrap.c" -o "$JINX_CACHE_DIR/debootstrap_wrap"
    rm "$JINX_CACHE_DIR/debootstrap_wrap.c"

    mkdir -p "$JINX_CACHE_DIR/sets/.image/var/cache/apt/archives"

    unshare --user --map-root-user --mount --pid --fork -- sh -c "
        set -e

        mount --bind '${apt_cache}' '$JINX_CACHE_DIR/sets/.image/var/cache/apt/archives'

        LD_PRELOAD='$JINX_CACHE_DIR/sets/.image/nochown.so' '$JINX_CACHE_DIR/debootstrap_wrap' \
            --foreign sid '$JINX_CACHE_DIR/sets/.image' https://snapshot.debian.org/archive/debian/${debian_snapshot}/
    "
    rm "$JINX_CACHE_DIR/debootstrap_wrap"

    for dir in dev proc sys run tmp var/tmp; do
        rm -rf "${JINX_CACHE_DIR}/sets/.image/${dir}"
        mkdir -p "${JINX_CACHE_DIR}/sets/.image/${dir}"
    done

    echo >"${JINX_CACHE_DIR}/sets/.image/etc/resolv.conf"
    echo localhost >"${JINX_CACHE_DIR}/sets/.image/etc/hostname"

    run_in_container1 "$JINX_CACHE_DIR/sets/.image" /debootstrap/debootstrap --second-stage

    echo 'en_US.UTF-8 UTF-8' > "$JINX_CACHE_DIR/sets/.image/etc/locale.gen"
    echo 'APT::Install-Suggests "0";
APT::Install-Recommends "0";
APT::Sandbox::User "root";
Acquire::Check-Valid-Until "0";' >> "$JINX_CACHE_DIR/sets/.image/etc/apt/apt.conf"

    sources_list_tmp="$(sed 's/sid/experimental/g' "$JINX_CACHE_DIR/sets/.image/etc/apt/sources.list")"
    echo "${sources_list_tmp}" >>"$JINX_CACHE_DIR/sets/.image/etc/apt/sources.list"

    run_in_container1 "$JINX_CACHE_DIR/sets/.image" apt-get update
    run_in_container1 "$JINX_CACHE_DIR/sets/.image" apt-get install -y locales
    run_in_container1 "$JINX_CACHE_DIR/sets/.image" locale-gen

    # Fix permissions of files
    for f in $(find "$JINX_CACHE_DIR/sets/.image" -perm 000 2>/dev/null); do
        chmod 755 "$f"
    done

    run_in_container1 "$JINX_CACHE_DIR/sets/.image" apt-get install -y autopoint bash bison bzip2 cmake curl diffutils docbook-xsl doxygen file findutils flex gawk gettext git grep gzip lzip m4 make mercurial meson ninja-build patch perl python3 sed tar texinfo w3m which xmlto xsltproc xz-utils zstd

    # Build xbps
    SHA256_COMMAND="sha256sum"
    if ! command -v "${SHA256_COMMAND%% *}" >/dev/null 2>&1; then
        SHA256_COMMAND="sha256"
        if ! command -v "${SHA256_COMMAND%% *}" >/dev/null 2>&1; then
            die "error: Cannot find sha256(sum) command"
        fi
    fi

    curl -Lo "${JINX_CACHE_DIR}/xbps-${XBPS_VERSION}.tar.gz" https://github.com/void-linux/xbps/archive/refs/tags/${XBPS_VERSION}.tar.gz
    if ! "${SHA256_COMMAND}" "${JINX_CACHE_DIR}/xbps-${XBPS_VERSION}.tar.gz" | grep "${XBPS_SHA256SUM}" >/dev/null 2>&1; then
        die "Jinx: Failed to verify XBPS tarball"
    fi
    (

    cd "$JINX_CACHE_DIR"
    tar -zxf xbps-${XBPS_VERSION}.tar.gz
    cd xbps-${XBPS_VERSION}

    # XXX: xbps upstream forgot to bump version string
    sed 's/0\.60/'"${XBPS_VERSION}"'/g' configure >configure.sed
    mv configure.sed configure
    sed 's/&& DEBUG=yes/&& DEBUG=no/g' configure >configure.sed
    mv configure.sed configure
    chmod +x configure

    CFLAGS="-O2 -pipe -Wno-error" ./configure --verbose --prefix="$JINX_CACHE_DIR/xbps" --localstatedir=/var

    sed '/DBDIR/d' data/Makefile >data/Makefile.sed
    mv data/Makefile.sed data/Makefile

    sed 's/-lxml2/-lxml2 -llzma -lm/g' config.mk >config.mk.sed
    mv config.mk.sed config.mk

    if command -v gmake >/dev/null 2>&1; then
        MAKE=gmake
    else
        MAKE=make
    fi

    ${MAKE} -j${parallelism}
    ${MAKE} install

    cd ..
    rm -rf xbps-${XBPS_VERSION}*

    )
}

first_use() {
    echo "* preparing Jinx cache..."

    mkdir -p "$JINX_CACHE_DIR"

    reinit_container

    echo "$jinx_version" > "$JINX_CACHE_DIR/version"

    echo "* done"
}

redo_first_use() {
    echo "* purging old Jinx cache..."
    chmod -R 777 "$JINX_CACHE_DIR" || true
    rm -rf "$JINX_CACHE_DIR"
    first_use
}

if ! [ -f "$JINX_CONFIG_FILE" ]; then
    die "$0: missing Jinxfile in directory '$base_dir'"
fi

. "${JINX_CONFIG_FILE}"

if [ -z "$JINX_MAJOR_VER" ]; then
    die "$0: required config variable \$JINX_MAJOR_VER missing"
fi

if ! [ "$JINX_MAJOR_VER" = "$jinx_major_ver" ]; then
    die "$0: needed major version ($JINX_MAJOR_VER) differs from Jinx-provided major version ($jinx_major_ver)"
fi

if [ -z "$JINX_ARCH" ]; then
    die "$0: required config variable \$JINX_ARCH missing"
fi

if ! [ -d "$JINX_CACHE_DIR" ]; then
    first_use
fi

if ! [ -f "$JINX_CACHE_DIR/version" ] || ! [ "$(cat "$JINX_CACHE_DIR/version")" = "$jinx_version" ]; then
    redo_first_use
fi

case "$1" in
    internal-prepare)
        do_prepare "$2"
        ;;
    internal-fetch)
        do_fetch "$2"
        ;;
    internal-patch)
        do_patch "$2"
        ;;
    internal-configure-host)
        do_configure_host "$2"
        ;;
    internal-build-host)
        do_build_host "$2"
        ;;
    internal-package-host)
        do_package_host "$2"
        ;;
    internal-configure)
        do_configure "$2"
        ;;
    internal-build)
        do_build "$2"
        ;;
    internal-package)
        do_package "$2"
        ;;
    internal-get-deps-file)
        . "${base_dir}"/recipes/$2
        deps_file="$3"
        get_deps_file
        ;;
    internal-get-hostdeps-file)
        . "${base_dir}"/host-recipes/$2
        hostdeps_file="$3"
        get_hostdeps_file_run
        ;;
    host-build)
        shift 1
        cmd_host_build "$@"
        ;;
    build)
        shift 1
        cmd_build "$@"
        ;;
    build-if-needed)
        shift 1
        cmd_build_if_needed "$@"
        ;;
    regenerate|regen)
        shift 1
        cmd_regen "$@"
        ;;
    host-rebuild)
        shift 1
        cmd_host_rebuild "$@"
        ;;
    rebuild)
        shift 1
        cmd_rebuild "$@"
        ;;
    install)
        shift 1
        cmd_install "$@"
        ;;
    reinstall)
        shift 1
        cmd_install -f "$@"
        ;;
    rebuild-cache)
        redo_first_use
        ;;
    *)
        die "$0: unknown command: $1"
        ;;
esac
