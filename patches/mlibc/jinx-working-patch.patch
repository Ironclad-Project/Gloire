diff --git mlibc-clean/abis/ironclad/signal.h mlibc-workdir/abis/ironclad/signal.h
index f6eeed0..2634cbe 100644
--- mlibc-clean/abis/ironclad/signal.h
+++ mlibc-workdir/abis/ironclad/signal.h
@@ -160,7 +160,6 @@ typedef struct {
 } mcontext_t;
 
 typedef struct __ucontext {
-	unsigned long uc_flags;
 	struct __ucontext *uc_link;
 	stack_t uc_stack;
 	mcontext_t uc_mcontext;
diff --git mlibc-clean/options/ansi/generic/environment.cpp mlibc-workdir/options/ansi/generic/environment.cpp
index 5625592..4ac4999 100644
--- mlibc-clean/options/ansi/generic/environment.cpp
+++ mlibc-workdir/options/ansi/generic/environment.cpp
@@ -111,8 +111,12 @@ namespace mlibc {
 int putenv(char *string) {
 	frg::string_view view{string};
 	size_t s = view.find_first('=');
-	if(s == size_t(-1))
-		__ensure(!"Environment strings need to contain an equals sign");
+	if(s == size_t(-1)) {
+		// GLIBC EXTENSION
+		update_vector();
+		unassign_variable(string);
+		return 0;
+	}
 
 	update_vector();
 	assign_variable(view.sub_string(0, s), string, true);
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..232c229 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -13,36 +13,28 @@ bool charset::is_ascii_superset() {
 bool charset::is_alpha(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alpha() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_digit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= '0' && c <= '9';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_digit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_xdigit(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_xdigit() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_alnum(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_alnum() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -55,63 +47,49 @@ bool charset::is_punct(codepoint c) {
 				|| c == '@'
 				|| c == '[' || c == '\\' || c == ']' || c == '^' || c == '_' || c == '`'
 				|| c == '{' || c == '|' || c == '}' || c == '~';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_punct() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_graph(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x21 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_graph() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_blank(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_blank() is not implemented"
-				" for the full Unicode charset " << c << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_space(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_space() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'a' && c <= 'z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
 bool charset::is_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return (c >= 'A' && c <= 'Z');
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return false;
 }
 
@@ -119,9 +97,7 @@ codepoint charset::to_lower(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'A' && c <= 'Z')
 			return c - 'A' + 'a';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_lower() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
@@ -129,9 +105,7 @@ codepoint charset::to_upper(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		if(c >= 'a' && c <= 'z')
 			return c - 'a' + 'A';
-	if(c > 0x7F)
-		mlibc::infoLogger() << "mlibc: charset::to_upper() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+
 	return c;
 }
 
diff --git mlibc-clean/options/posix/generic/posix_locale.cpp mlibc-workdir/options/posix/generic/posix_locale.cpp
index bd8710a..feb59ee 100644
--- mlibc-clean/options/posix/generic/posix_locale.cpp
+++ mlibc-workdir/options/posix/generic/posix_locale.cpp
@@ -25,7 +25,7 @@ void freelocale(locale_t) {
 
 locale_t uselocale(locale_t) {
 	if(!uselocale_seen) {
-		mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
+		//mlibc::infoLogger() << "mlibc: uselocale() is a no-op" << frg::endlog;
 		uselocale_seen = true;
 	}
 	return nullptr;
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 8cf23ba..62d23ad 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -15,6 +15,7 @@
 #include <mlibc/allocator.hpp>
 #include <mlibc/debug.hpp>
 #include <mlibc/posix-sysdeps.hpp>
+#include <mlibc/bsd-sysdeps.hpp>
 #include <mlibc/rtld-config.hpp>
 
 namespace {
@@ -492,23 +493,16 @@ char *ptsname(int fd) {
 }
 
 int posix_openpt(int flags) {
-	int fd;
-	if(int e = mlibc::sys_open("/dev/ptmx", flags, 0, &fd); e) {
+	int mfd, sfd;
+	if(int e = mlibc::sys_openpty(&mfd, &sfd, NULL, NULL, NULL); e) {
 		errno = e;
 		return -1;
 	}
 
-	return fd;
+	return mfd;
 }
 
 int unlockpt(int fd) {
-	auto sysdep = MLIBC_CHECK_OR_ENOSYS(mlibc::sys_unlockpt, -1);
-
-	if(int e = sysdep(fd); e) {
-		errno = e;
-		return -1;
-	}
-
 	return 0;
 }
 
@@ -517,7 +511,7 @@ int grantpt(int) {
 }
 
 double strtod_l(const char *__restrict__ nptr, char ** __restrict__ endptr, locale_t) {
-	mlibc::infoLogger() << "mlibc: strtod_l ignores locale!" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: strtod_l ignores locale!" << frg::endlog;
 	return strtod(nptr, endptr);
 }
 
@@ -527,7 +521,7 @@ long double strtold_l(const char *__restrict__, char ** __restrict__, locale_t)
 }
 
 float strtof_l(const char *__restrict__ nptr, char **__restrict__ endptr, locale_t) {
-	mlibc::infoLogger() << "mlibc: strtof_l ignores locales" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: strtof_l ignores locales" << frg::endlog;
 	return strtof(nptr, endptr);
 }
 
diff --git mlibc-clean/options/posix/include/sys/stat.h mlibc-workdir/options/posix/include/sys/stat.h
index 98f1d2a..e648292 100644
--- mlibc-clean/options/posix/include/sys/stat.h
+++ mlibc-workdir/options/posix/include/sys/stat.h
@@ -19,11 +19,9 @@ int chmod(const char *__pathname, mode_t __mode);
 int fchmod(int __fd, mode_t __mode);
 int fchmodat(int __fd, const char *__pathname, mode_t __mode, int __flags);
 int fstat(int __fd, struct stat *__result);
-int fstat64(int __fd, struct stat64 *__result);
 int fstatat(int __fd, const char *__restrict __pathname, struct stat *__restrict __buf, int __flags);
 int futimens(int __fd, const struct timespec __times[2]);
 int lstat(const char *__restrict __pathname, struct stat *__restrict __buf);
-int lstat64(const char *__restrict __pathname, struct stat64 *__restrict __buf);
 int mkdir(const char *__pathname, mode_t __mode);
 int mkdirat(int __dirfd, const char *__pathname, mode_t __mode);
 int mkfifo(const char *__pathname, mode_t __mode);
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index cd1cc2c..99937a0 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -293,7 +293,6 @@ int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offse
 	*window = ret;
 
 	if ((errno == ENOMEM) && ((flags & MAP_ANON) == 0)) {
-		mlibc::infoLogger() << "mlibc: emulating file mmap" << frg::endlog;
 		int ret = sys_anon_allocate(size, window);
 		if (ret) {
 			return ret;
@@ -524,6 +523,10 @@ int sys_ttyname(int fd, char *buff, size_t size) {
 	return errno;
 }
 
+int sys_ptsname(int fd, char *buff, size_t size) {
+	return sys_ttyname(fd, buff, size);
+}
+
 int sys_sethostname(const char *buff, size_t size) {
 	int ret, errno;
 
@@ -1018,19 +1021,16 @@ int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval
 }
 
 int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
-	(void)flags;
+	int ret, errno;
 
 	if (hdr->msg_control != NULL) {
-		// mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
+		SYSCALL3(SYSCALL_RECVSOCKCTL, fd, hdr->msg_control, hdr->msg_controllen);
 	}
 
-	int ret;
 	size_t count = 0;
-	int errno;
-
 	for (int i = 0; i < hdr->msg_iovlen; i++) {
-		SYSCALL6(SYSCALL_RECVFROM, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
-					hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
+		SYSCALL6(SYSCALL_RECVFROM, fd, hdr->msg_iov[i].iov_base, hdr->msg_iov[i].iov_len,
+					flags, hdr->msg_name, hdr->msg_namelen);
 		if (ret == -1) {
 			return errno;
 		}
@@ -1042,19 +1042,16 @@ int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
 }
 
 int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
-	(void)flags;
+	int ret, errno;
 
 	if (hdr->msg_control != NULL) {
-		// mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
+		SYSCALL3(SYSCALL_SENDSOCKCTL, fd, hdr->msg_control, hdr->msg_controllen);
 	}
 
-	int ret;
 	size_t count = 0;
-	int errno;
-
 	for (int i = 0; i < hdr->msg_iovlen; i++) {
-		SYSCALL6(SYSCALL_SENDTO, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
-					hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
+		SYSCALL6(SYSCALL_SENDTO, fd, hdr->msg_iov[i].iov_base, hdr->msg_iov[i].iov_len,
+					flags, hdr->msg_name, hdr->msg_namelen);
 		if (ret == -1) {
 			return errno;
 		}
@@ -1258,7 +1255,7 @@ int sys_sysconf(int num, long *rret) {
 				return EFAULT;
 			}
 		case _SC_OPEN_MAX:
-			*rret = 100;
+			*rret = 1024;
 			return 0;
 		case _SC_AVPHYS_PAGES:
 			SYSCALL1(SYSCALL_MEMINFO, &mem);
@@ -1421,6 +1418,19 @@ int sys_mknodat(int dirfd, const char *path, mode_t mode, dev_t dev) {
 	return errno;
 }
 
+int sys_symlink(const char *target, const char *link_path) {
+	return sys_symlinkat(target, AT_FDCWD, link_path);
+}
+
+int sys_symlinkat(const char *target_path, int dirfd, const char *link_path) {
+	int ret;
+	int errno;
+	size_t target_len = strlen(target_path);
+	size_t link_len = strlen(link_path);
+	SYSCALL5(SYSCALL_SYMLINK, dirfd, target_path, target_len, link_path, link_len);
+	return errno;
+}
+
 int sys_brk(void **out) {
 	(void)out;
 	return -1;
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index cc56aa6..e11ad7f 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -111,10 +111,11 @@
 #define SYSCALL_CREATE_THREAD       100
 #define SYSCALL_SIGNAL_RETURN       101
 #define SYSCALL_SIGALTSTACK         102
-#define SYSCALL_SIGSUSPEND          103
+#define SYSCALL_RECVSOCKCTL         103
 #define SYSCALL_LISTMOUNTS          104
 #define SYSCALL_UNAME               105
 #define SYSCALL_LISTTHREADS         106
+#define SYSCALL_SENDSOCKCTL         107
 #define SYSCALL_LISTNETINTER        108
 #define SYSCALL_DUMPLOGS            109
 #define SYSCALL_LISTFLOCKS          110
