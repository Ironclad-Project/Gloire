diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..67b036c 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -2,16 +2,15 @@
 #include <bits/ensure.h>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 void backtrace_symbols_fd(void *const *, int, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..011d9c0 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -91,9 +91,9 @@ bool charset::is_space(codepoint c) {
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
+	/*if(c > 0x7F)
 		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+				" for the full Unicode charset" << frg::endlog;*/
 	return false;
 }
 
diff --git mlibc-clean/options/posix/generic/unistd-stubs.cpp mlibc-workdir/options/posix/generic/unistd-stubs.cpp
index 39cf76a..4e98d61 100644
--- mlibc-clean/options/posix/generic/unistd-stubs.cpp
+++ mlibc-workdir/options/posix/generic/unistd-stubs.cpp
@@ -25,323 +25,323 @@ constexpr bool logExecvpeTries = false;
 }
 
 unsigned int alarm(unsigned int seconds) {
-	struct itimerval it = {}, old = {};
-	it.it_value.tv_sec = seconds;
-	setitimer(ITIMER_REAL, &it, &old);
-	return old.it_value.tv_sec + !! old.it_value.tv_usec;
+   struct itimerval it = {}, old = {};
+   it.it_value.tv_sec = seconds;
+   setitimer(ITIMER_REAL, &it, &old);
+   return old.it_value.tv_sec + !! old.it_value.tv_usec;
 }
 
 int chdir(const char *path) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_chdir, -1);
-	if(int e = mlibc::sys_chdir(path); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_chdir, -1);
+   if(int e = mlibc::sys_chdir(path); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int fchdir(int fd) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchdir, -1);
-	if(int e = mlibc::sys_fchdir(fd); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchdir, -1);
+   if(int e = mlibc::sys_fchdir(fd); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int chown(const char *path, uid_t uid, gid_t gid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
-	if(int e = mlibc::sys_fchownat(AT_FDCWD, path, uid, gid, 0); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
+   if(int e = mlibc::sys_fchownat(AT_FDCWD, path, uid, gid, 0); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 ssize_t confstr(int name, char *buf, size_t len) {
-	const char *str = "";
-	if (name == _CS_PATH) {
-		str = "/bin:/usr/bin";
-	} else if(name == _CS_GNU_LIBPTHREAD_VERSION) {
-		// We are not glibc, so we can return 0 here.
-		return 0;
-	} else if(name == _CS_GNU_LIBC_VERSION) {
-		// We are not glibc, so we can return 0 here.
-		return 0;
-	} else {
-		mlibc::infoLogger() << "\e[31mmlibc: confstr() request " << name << " is unimplemented\e[39m"
-				<< frg::endlog;
-		__ensure(!"Not implemented");
-	}
-
-	return snprintf(buf, len, "%s", str) + 1;
+   const char *str = "";
+   if (name == _CS_PATH) {
+      str = "/bin:/usr/bin";
+   } else if(name == _CS_GNU_LIBPTHREAD_VERSION) {
+      // We are not glibc, so we can return 0 here.
+      return 0;
+   } else if(name == _CS_GNU_LIBC_VERSION) {
+      // We are not glibc, so we can return 0 here.
+      return 0;
+   } else {
+      mlibc::infoLogger() << "\e[31mmlibc: confstr() request " << name << " is unimplemented\e[39m"
+            << frg::endlog;
+      __ensure(!"Not implemented");
+   }
+
+   return snprintf(buf, len, "%s", str) + 1;
 }
 
 void _exit(int status) {
-	mlibc::sys_exit(status);
+   mlibc::sys_exit(status);
 }
 
 int execl(const char *path, const char *arg0, ...) {
-	// TODO: It's a stupid idea to limit the number of arguments here.
-	char *argv[16];
-	argv[0] = const_cast<char *>(arg0);
-
-	va_list args;
-	int n = 1;
-	va_start(args, arg0);
-	while(true) {
-		__ensure(n < 15);
-		auto argn = va_arg(args, const char *);
-		argv[n++] = const_cast<char *>(argn);
-		if(!argn)
-			break;
-	}
-	va_end(args);
-	argv[n] = nullptr;
-
-	return execve(path, argv, environ);
+   // TODO: It's a stupid idea to limit the number of arguments here.
+   char *argv[16];
+   argv[0] = const_cast<char *>(arg0);
+
+   va_list args;
+   int n = 1;
+   va_start(args, arg0);
+   while(true) {
+      __ensure(n < 15);
+      auto argn = va_arg(args, const char *);
+      argv[n++] = const_cast<char *>(argn);
+      if(!argn)
+         break;
+   }
+   va_end(args);
+   argv[n] = nullptr;
+
+   return execve(path, argv, environ);
 }
 
 // This function is taken from musl.
 int execle(const char *path, const char *arg0, ...) {
-	int argc;
-	va_list ap;
-	va_start(ap, arg0);
-	for(argc = 1; va_arg(ap, const char *); argc++);
-	va_end(ap);
-
-	int i;
-	char *argv[argc + 1];
-	char **envp;
-	va_start(ap, arg0);
-	argv[0] = (char *)argv;
-	for(i = 1; i <= argc; i++)
-		argv[i] = va_arg(ap, char *);
-	envp = va_arg(ap, char **);
-	va_end(ap);
-	return execve(path, argv, envp);
+   int argc;
+   va_list ap;
+   va_start(ap, arg0);
+   for(argc = 1; va_arg(ap, const char *); argc++);
+   va_end(ap);
+
+   int i;
+   char *argv[argc + 1];
+   char **envp;
+   va_start(ap, arg0);
+   argv[0] = (char *)argv;
+   for(i = 1; i <= argc; i++)
+      argv[i] = va_arg(ap, char *);
+   envp = va_arg(ap, char **);
+   va_end(ap);
+   return execve(path, argv, envp);
 }
 
 // This function is taken from musl
 int execlp(const char *file, const char *argv0, ...) {
-	int argc;
-	va_list ap;
-	va_start(ap, argv0);
-	for(argc = 1; va_arg(ap, const char *); argc++);
-	va_end(ap);
-	{
-		int i;
-		char *argv[argc + 1];
-		va_start(ap, argv0);
-		argv[0] = (char *)argv0;
-		for(i = 1; i < argc; i++)
-			argv[i] = va_arg(ap, char *);
-		argv[i] = NULL;
-		va_end(ap);
-		return execvp(file, argv);
-	}
+   int argc;
+   va_list ap;
+   va_start(ap, argv0);
+   for(argc = 1; va_arg(ap, const char *); argc++);
+   va_end(ap);
+   {
+      int i;
+      char *argv[argc + 1];
+      va_start(ap, argv0);
+      argv[0] = (char *)argv0;
+      for(i = 1; i < argc; i++)
+         argv[i] = va_arg(ap, char *);
+      argv[i] = NULL;
+      va_end(ap);
+      return execvp(file, argv);
+   }
 }
 
 int execv(const char *path, char *const argv[]) {
-	return execve(path, argv, environ);
+   return execve(path, argv, environ);
 }
 
 int execvp(const char *file, char *const argv[]) {
-	return execvpe(file, argv, environ);
+   return execvpe(file, argv, environ);
 }
 
 int execvpe(const char *file, char *const argv[], char *const envp[]) {
-	char *null_list[] = {
-		nullptr
-	};
-
-	if(!argv)
-		argv = null_list;
-	if(!envp)
-		envp = null_list;
-
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_execve, -1);
-
-	if(strchr(file, '/')) {
-		int e = mlibc::sys_execve(file, argv, envp);
-		__ensure(e && "sys_execve() is supposed to never return with success");
-		errno = e;
-		return -1;
-	}
-
-	frg::string_view dirs;
-	if(const char *pv = getenv("PATH"); pv) {
-		dirs = pv;
-	}else{
-		dirs = "/bin:/usr/bin";
-	}
-
-	size_t p = 0;
-	int res = ENOENT;
-	while(p < dirs.size()) {
-		size_t s; // Offset of next colon or end of string.
-		if(size_t cs = dirs.find_first(':', p); cs != size_t(-1)) {
-			s = cs;
-		}else{
-			s = dirs.size();
-		}
-
-		frg::string<MemoryAllocator> path{getAllocator()};
-		path += dirs.sub_string(p, s - p);
-		path += "/";
-		path += file;
-
-		if(logExecvpeTries)
-			mlibc::infoLogger() << "mlibc: execvpe() tries '" << path.data() << "'" << frg::endlog;
-
-		int e = mlibc::sys_execve(path.data(), argv, envp);
-		__ensure(e && "sys_execve() is supposed to never return with success");
-		switch(e) {
-		case ENOENT:
-		case ENOTDIR:
-			break;
-		case EACCES:
-			res = EACCES;
-			break;
-		default:
-			errno = e;
-			return -1;
-		}
-
-		p = s + 1;
-	}
-
-	errno = res;
-	return -1;
+   char *null_list[] = {
+      nullptr
+   };
+
+   if(!argv)
+      argv = null_list;
+   if(!envp)
+      envp = null_list;
+
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_execve, -1);
+
+   if(strchr(file, '/')) {
+      int e = mlibc::sys_execve(file, argv, envp);
+      __ensure(e && "sys_execve() is supposed to never return with success");
+      errno = e;
+      return -1;
+   }
+
+   frg::string_view dirs;
+   if(const char *pv = getenv("PATH"); pv) {
+      dirs = pv;
+   }else{
+      dirs = "/bin:/usr/bin";
+   }
+
+   size_t p = 0;
+   int res = ENOENT;
+   while(p < dirs.size()) {
+      size_t s; // Offset of next colon or end of string.
+      if(size_t cs = dirs.find_first(':', p); cs != size_t(-1)) {
+         s = cs;
+      }else{
+         s = dirs.size();
+      }
+
+      frg::string<MemoryAllocator> path{getAllocator()};
+      path += dirs.sub_string(p, s - p);
+      path += "/";
+      path += file;
+
+      if(logExecvpeTries)
+         mlibc::infoLogger() << "mlibc: execvpe() tries '" << path.data() << "'" << frg::endlog;
+
+      int e = mlibc::sys_execve(path.data(), argv, envp);
+      __ensure(e && "sys_execve() is supposed to never return with success");
+      switch(e) {
+      case ENOENT:
+      case ENOTDIR:
+         break;
+      case EACCES:
+         res = EACCES;
+         break;
+      default:
+         errno = e;
+         return -1;
+      }
+
+      p = s + 1;
+   }
+
+   errno = res;
+   return -1;
 }
 
 int faccessat(int dirfd, const char *pathname, int mode, int flags) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_faccessat, -1);
-	if(int e = mlibc::sys_faccessat(dirfd, pathname, mode, flags); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_faccessat, -1);
+   if(int e = mlibc::sys_faccessat(dirfd, pathname, mode, flags); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int fchown(int fd, uid_t uid, gid_t gid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
-	if(int e = mlibc::sys_fchownat(fd, "", uid, gid, AT_EMPTY_PATH); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
+   if(int e = mlibc::sys_fchownat(fd, "", uid, gid, AT_EMPTY_PATH); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flags) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
-	if(int e = mlibc::sys_fchownat(fd, path, uid, gid, flags); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
+   if(int e = mlibc::sys_fchownat(fd, path, uid, gid, flags); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int fdatasync(int fd) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fdatasync, -1);
-	if(int e = mlibc::sys_fdatasync(fd); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fdatasync, -1);
+   if(int e = mlibc::sys_fdatasync(fd); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int fexecve(int, char *const [], char *const []) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 long fpathconf(int, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int fsync(int fd) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fsync, -1);
-	if(auto e = mlibc::sys_fsync(fd); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fsync, -1);
+   if(auto e = mlibc::sys_fsync(fd); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int ftruncate(int fd, off_t size) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_ftruncate, -1);
-	if(int e = mlibc::sys_ftruncate(fd, size); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_ftruncate, -1);
+   if(int e = mlibc::sys_ftruncate(fd, size); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 char *getcwd(char *buffer, size_t size) {
-	if (buffer) {
-		if (size == 0) {
-			errno = EINVAL;
-			return NULL;
-		}
-	} else if (!buffer) {
-		if (size == 0)
-			size = PATH_MAX;
+   if (buffer) {
+      if (size == 0) {
+         errno = EINVAL;
+         return NULL;
+      }
+   } else if (!buffer) {
+      if (size == 0)
+         size = PATH_MAX;
 
-		buffer = (char *)malloc(size);
-	}
+      buffer = (char *)malloc(size);
+   }
 
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getcwd, nullptr);
-	if(int e = mlibc::sys_getcwd(buffer, size); e) {
-		errno = e;
-		return NULL;
-	}
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getcwd, nullptr);
+   if(int e = mlibc::sys_getcwd(buffer, size); e) {
+      errno = e;
+      return NULL;
+   }
 
-	return buffer;
+   return buffer;
 }
 
 int getgroups(int size, gid_t list[]) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getgroups, -1);
-	int ret;
-	if(int e = mlibc::sys_getgroups(size, list, &ret); e) {
-		errno = e;
-		return -1;
-	}
-	return ret;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getgroups, -1);
+   int ret;
+   if(int e = mlibc::sys_getgroups(size, list, &ret); e) {
+      errno = e;
+      return -1;
+   }
+   return ret;
 }
 
 long gethostid(void) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int gethostname(char *buffer, size_t bufsize) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_gethostname, -1);
-	if(auto e = mlibc::sys_gethostname(buffer, bufsize); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_gethostname, -1);
+   if(auto e = mlibc::sys_gethostname(buffer, bufsize); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int sethostname(const char *buffer, size_t bufsize) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_sethostname, -1);
-	if(auto e = mlibc::sys_sethostname(buffer, bufsize); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_sethostname, -1);
+   if(auto e = mlibc::sys_sethostname(buffer, bufsize); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 // Code taken from musl
 char *getlogin(void) {
-	return getenv("LOGNAME");
+   return getenv("LOGNAME");
 }
 
 int getlogin_r(char *, size_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 // optarg and optind are provided to us by the GLIBC part of the mlibc.
@@ -349,879 +349,878 @@ int getlogin_r(char *, size_t) {
 static char *scan = NULL; /* Private scan pointer. */
 
 int getopt(int argc, char *const argv[], const char *optstring) {
-	char c;
-	char *place;
-
-	optarg = NULL;
-
-	if (!scan || *scan == '\0') {
-		if (optind == 0)
-			optind++;
-
-		if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
-			return EOF;
-		if (argv[optind][1] == '-' && argv[optind][2] == '\0') {
-			optind++;
-			return EOF;
-		}
-
-		scan = argv[optind]+1;
-		optind++;
-	}
-
-	c = *scan++;
-	place = strchr(optstring, c);
-
-	if (!place || c == ':') {
-		fprintf(stderr, "%s: unknown option -%c\n", argv[0], c);
-		return '?';
-	}
-
-	place++;
-	if (*place == ':') {
-		if (*scan != '\0') {
-			optarg = scan;
-			scan = NULL;
-		} else if( optind < argc ) {
-			optarg = argv[optind];
-			optind++;
-		} else {
-			fprintf(stderr, "%s: option requires argument -%c\n", argv[0], c);
-			return ':';
-		}
-	}
-
-	return c;
+   char c;
+   char *place;
+
+   optarg = NULL;
+
+   if (!scan || *scan == '\0') {
+      if (optind == 0)
+         optind++;
+
+      if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\0')
+         return EOF;
+      if (argv[optind][1] == '-' && argv[optind][2] == '\0') {
+         optind++;
+         return EOF;
+      }
+
+      scan = argv[optind]+1;
+      optind++;
+   }
+
+   c = *scan++;
+   place = strchr(optstring, c);
+
+   if (!place || c == ':') {
+      fprintf(stderr, "%s: unknown option -%c\n", argv[0], c);
+      return '?';
+   }
+
+   place++;
+   if (*place == ':') {
+      if (*scan != '\0') {
+         optarg = scan;
+         scan = NULL;
+      } else if( optind < argc ) {
+         optarg = argv[optind];
+         optind++;
+      } else {
+         fprintf(stderr, "%s: option requires argument -%c\n", argv[0], c);
+         return ':';
+      }
+   }
+
+   return c;
 }
 
 pid_t getpgid(pid_t pid) {
-	pid_t pgid;
+   pid_t pgid;
 
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getpgid, -1);
-	if(int e = mlibc::sys_getpgid(pid, &pgid); e) {
-		errno = e;
-		return -1;
-	}
-	return pgid;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getpgid, -1);
+   if(int e = mlibc::sys_getpgid(pid, &pgid); e) {
+      errno = e;
+      return -1;
+   }
+   return pgid;
 }
 
 pid_t getpgrp(void) {
-	return getpgid(0);
+   return getpgid(0);
 }
 
 pid_t getsid(pid_t pid) {
-	if(!mlibc::sys_getsid) {
-		MLIBC_MISSING_SYSDEP();
-		return -1;
-	}
-	pid_t sid;
-	if(int e = mlibc::sys_getsid(pid, &sid); e) {
-		errno = e;
-		return -1;
-	}
-	return sid;
+   if(!mlibc::sys_getsid) {
+      MLIBC_MISSING_SYSDEP();
+      return -1;
+   }
+   pid_t sid;
+   if(int e = mlibc::sys_getsid(pid, &sid); e) {
+      errno = e;
+      return -1;
+   }
+   return sid;
 }
 
 int lchown(const char *path, uid_t uid, gid_t gid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
-	if(int e = mlibc::sys_fchownat(AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fchownat, -1);
+   if(int e = mlibc::sys_fchownat(AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int link(const char *old_path, const char *new_path) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_link, -1);
-	if(int e = mlibc::sys_link(old_path, new_path); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_link, -1);
+   if(int e = mlibc::sys_link(old_path, new_path); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_linkat, -1);
-	if(int e = mlibc::sys_linkat(olddirfd, old_path, newdirfd, new_path, flags); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_linkat, -1);
+   if(int e = mlibc::sys_linkat(olddirfd, old_path, newdirfd, new_path, flags); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 // Code take from musl
 int lockf(int fd, int op, off_t size) {
-	struct flock l = {
-		.l_type = F_WRLCK,
-		.l_whence = SEEK_CUR,
-		.l_start = 0,
-		.l_len = size,
-		.l_pid = 0,
-	};
-
-	switch(op) {
-		case F_TEST:
-			l.l_type = F_RDLCK;
-			if(fcntl(fd, F_GETLK, &l) < 0)
-				return -1;
-			if(l.l_type == F_UNLCK || l.l_pid == getpid())
-				return 0;
-			errno = EACCES;
-			return -1;
-		case F_ULOCK:
-			l.l_type = F_UNLCK;
-			[[fallthrough]];
-		case F_TLOCK:
-			return fcntl(fd, F_SETLK, &l);
-		case F_LOCK:
-			return fcntl(fd, F_SETLKW, &l);
-	}
-
-	errno = EINVAL;
-	return -1;
+   struct flock l = {
+      .l_type = F_WRLCK,
+      .l_whence = SEEK_CUR,
+      .l_start = 0,
+      .l_len = size,
+      .l_pid = 0,
+   };
+
+   switch(op) {
+      case F_TEST:
+         l.l_type = F_RDLCK;
+         if(fcntl(fd, F_GETLK, &l) < 0)
+            return -1;
+         if(l.l_type == F_UNLCK || l.l_pid == getpid())
+            return 0;
+         errno = EACCES;
+         return -1;
+      case F_ULOCK:
+         l.l_type = F_UNLCK;
+         [[fallthrough]];
+      case F_TLOCK:
+         return fcntl(fd, F_SETLK, &l);
+      case F_LOCK:
+         return fcntl(fd, F_SETLKW, &l);
+   }
+
+   errno = EINVAL;
+   return -1;
 }
 
 int nice(int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 long pathconf(const char *, int name) {
-	switch (name) {
-	case _PC_NAME_MAX:
-		return NAME_MAX;
-	default:
-		mlibc::infoLogger() << "missing pathconf() entry " << name << frg::endlog;
-		errno = EINVAL;
-		return -1;
-	}
+   switch (name) {
+   case _PC_NAME_MAX:
+      return NAME_MAX;
+   default:
+      mlibc::infoLogger() << "missing pathconf() entry " << name << frg::endlog;
+      errno = EINVAL;
+      return -1;
+   }
 }
 
 int pause(void) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pause, -1);
-	if(int e = mlibc::sys_pause(); e) {
-		errno = e;
-		return -1;
-	}
-	__ensure(!"There is no successful completion return value for pause");
-	__builtin_unreachable();
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pause, -1);
+   if(int e = mlibc::sys_pause(); e) {
+      errno = e;
+      return -1;
+   }
+   __ensure(!"There is no successful completion return value for pause");
+   __builtin_unreachable();
 }
 
 int pipe(int *fds) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pipe, -1);
-	if(int e = mlibc::sys_pipe(fds, 0); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pipe, -1);
+   if(int e = mlibc::sys_pipe(fds, 0); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int pipe2(int *fds, int flags) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pipe, -1);
-	if(int e = mlibc::sys_pipe(fds, flags); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pipe, -1);
+   if(int e = mlibc::sys_pipe(fds, flags); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 ssize_t pread(int fd, void *buf, size_t n, off_t off) {
-	ssize_t num_read;
+   ssize_t num_read;
 
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pread, -1);
-	if(int e = mlibc::sys_pread(fd, buf, n, off, &num_read); e) {
-		errno = e;
-		return -1;
-	}
-	return num_read;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pread, -1);
+   if(int e = mlibc::sys_pread(fd, buf, n, off, &num_read); e) {
+      errno = e;
+      return -1;
+   }
+   return num_read;
 }
 
 ssize_t pwrite(int fd, const void *buf, size_t n, off_t off) {
-	ssize_t num_written;
+   ssize_t num_written;
 
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pwrite, -1);
-	if(int e = mlibc::sys_pwrite(fd, buf, n, off, &num_written); e) {
-		errno = e;
-		return -1;
-	}
-	return num_written;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_pwrite, -1);
+   if(int e = mlibc::sys_pwrite(fd, buf, n, off, &num_written); e) {
+      errno = e;
+      return -1;
+   }
+   return num_written;
 }
 
 ssize_t readlink(const char *__restrict path, char *__restrict buffer, size_t max_size) {
-	ssize_t length;
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_readlink, -1);
-	if(int e = mlibc::sys_readlink(path, buffer, max_size, &length); e) {
-		errno = e;
-		return -1;
-	}
-	return length;
+   ssize_t length;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_readlink, -1);
+   if(int e = mlibc::sys_readlink(path, buffer, max_size, &length); e) {
+      errno = e;
+      return -1;
+   }
+   return length;
 }
 
 ssize_t readlinkat(int, const char *__restrict, char *__restrict, size_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int rmdir(const char *path) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_rmdir, -1);
-	if(int e = mlibc::sys_rmdir(path); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_rmdir, -1);
+   if(int e = mlibc::sys_rmdir(path); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int setegid(gid_t egid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setegid, 0);
-	if(int e = mlibc::sys_setegid(egid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setegid, 0);
+   if(int e = mlibc::sys_setegid(egid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int seteuid(uid_t euid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_seteuid, 0);
-	if(int e = mlibc::sys_seteuid(euid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_seteuid, 0);
+   if(int e = mlibc::sys_seteuid(euid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int setgid(gid_t gid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setgid, 0);
-	if(int e = mlibc::sys_setgid(gid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setgid, 0);
+   if(int e = mlibc::sys_setgid(gid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int setpgid(pid_t pid, pid_t pgid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setpgid, -1);
-	if(int e = mlibc::sys_setpgid(pid, pgid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setpgid, -1);
+   if(int e = mlibc::sys_setpgid(pid, pgid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 pid_t setpgrp(void) {
-	return setpgid(0, 0);
+   return setpgid(0, 0);
 }
 
 int setregid(gid_t rgid, gid_t egid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setregid, -1);
-	if(int e = mlibc::sys_setregid(rgid, egid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setregid, -1);
+   if(int e = mlibc::sys_setregid(rgid, egid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int setreuid(uid_t ruid, uid_t euid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setreuid, -1);
-	if(int e = mlibc::sys_setreuid(ruid, euid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setreuid, -1);
+   if(int e = mlibc::sys_setreuid(ruid, euid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 pid_t setsid(void) {
-	if(!mlibc::sys_setsid) {
-		MLIBC_MISSING_SYSDEP();
-		return -1;
-	}
-	pid_t sid;
-	if(int e = mlibc::sys_setsid(&sid); e) {
-		errno = e;
-		return -1;
-	}
-	return sid;
+   if(!mlibc::sys_setsid) {
+      MLIBC_MISSING_SYSDEP();
+      return -1;
+   }
+   pid_t sid;
+   if(int e = mlibc::sys_setsid(&sid); e) {
+      errno = e;
+      return -1;
+   }
+   return sid;
 }
 
 int setuid(uid_t uid) {
-	if(!mlibc::sys_setuid) {
-		MLIBC_MISSING_SYSDEP();
-		mlibc::infoLogger() << "mlibc: missing sysdep sys_setuid(). Returning 0" << frg::endlog;
-		return 0;
-	}
-	if(int e = mlibc::sys_setuid(uid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   if(!mlibc::sys_setuid) {
+      MLIBC_MISSING_SYSDEP();
+      mlibc::infoLogger() << "mlibc: missing sysdep sys_setuid(). Returning 0" << frg::endlog;
+      return 0;
+   }
+   if(int e = mlibc::sys_setuid(uid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 void swab(const void *__restrict, void *__restrict, ssize_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int symlink(const char *target_path, const char *link_path) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_symlink, -1);
-	if(int e = mlibc::sys_symlink(target_path, link_path); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_symlink, -1);
+   if(int e = mlibc::sys_symlink(target_path, link_path); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int symlinkat(const char *target_path, int dirfd, const char *link_path) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_symlinkat, -1);
-	if(int e = mlibc::sys_symlinkat(target_path, dirfd, link_path); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_symlinkat, -1);
+   if(int e = mlibc::sys_symlinkat(target_path, dirfd, link_path); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 void sync(void) {
-	if(!mlibc::sys_sync) {
-		MLIBC_MISSING_SYSDEP();
-	} else {
-		mlibc::sys_sync();
-	}
+   if(!mlibc::sys_sync) {
+      MLIBC_MISSING_SYSDEP();
+   } else {
+      mlibc::sys_sync();
+   }
 }
 
 long sysconf(int number) {
-	if(mlibc::sys_sysconf) {
-		long ret = 0;
-
-		int e = mlibc::sys_sysconf(number, &ret);
-
-		if(e && e != EINVAL) {
-			errno = e;
-			return -1;
-		}
-
-		if(e != EINVAL) {
-			return ret;
-		}
-	}
-
-	/* default return values, if not overriden by sysdep */
-	switch(number) {
-		case _SC_ARG_MAX:
-			// On linux, it is defined to 2097152 in most cases, so define it to be 2097152
-			return 2097152;
-		case _SC_PAGE_SIZE:
-			return mlibc::page_size;
-		case _SC_OPEN_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns fallback value 256\e[39m" << frg::endlog;
-			return 256;
-		case _SC_PHYS_PAGES:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_PHYS_PAGES) returns fallback value 1024\e[39m" << frg::endlog;
-			return 1024;
-		case _SC_NPROCESSORS_ONLN:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_NPROCESSORS_ONLN) returns fallback value 1\e[39m" << frg::endlog;
-			return 1;
-		case _SC_GETPW_R_SIZE_MAX:
-			return NSS_BUFLEN_PASSWD;
-		case _SC_GETGR_R_SIZE_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_GETGR_R_SIZE_MAX) returns fallback value 1024\e[39m" << frg::endlog;
-			return 1024;
-		case _SC_CHILD_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_CHILD_MAX) returns fallback value 25\e[39m" << frg::endlog;
-			// On linux, it is defined to 25 in most cases, so define it to be 25
-			return 25;
-		case _SC_JOB_CONTROL:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_JOB_CONTROL) returns fallback value 1\e[39m" << frg::endlog;
-			// If 1, job control is supported
-			return 1;
-		case _SC_CLK_TCK:
-			// TODO: This should be obsolete?
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_CLK_TCK) is obsolete and returns arbitrary value 1000000\e[39m" << frg::endlog;
-			return 1000000;
-		case _SC_NGROUPS_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_NGROUPS_MAX) returns fallback value 65536\e[39m" << frg::endlog;
-			// On linux, it is defined to 65536 in most cases, so define it to be 65536
-			return 65536;
-		case _SC_RE_DUP_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_RE_DUP_MAX) returns fallback value RE_DUP_MAX\e[39m" << frg::endlog;
-			return RE_DUP_MAX;
-		case _SC_LINE_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_LINE_MAX) returns fallback value 2048\e[39m" << frg::endlog;
-			// Linux defines it as 2048.
-			return 2048;
-		case _SC_XOPEN_CRYPT:
+   if(mlibc::sys_sysconf) {
+      long ret = 0;
+
+      int e = mlibc::sys_sysconf(number, &ret);
+
+      if(e && e != EINVAL) {
+         errno = e;
+         return -1;
+      }
+
+      if(e != EINVAL) {
+         return ret;
+      }
+   }
+
+   /* default return values, if not overriden by sysdep */
+   switch(number) {
+      case _SC_ARG_MAX:
+         // On linux, it is defined to 2097152 in most cases, so define it to be 2097152
+         return 2097152;
+      case _SC_PAGE_SIZE:
+         return mlibc::page_size;
+      case _SC_OPEN_MAX:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_OPEN_MAX) returns fallback value 256\e[39m" << frg::endlog;
+         return 256;
+      case _SC_PHYS_PAGES:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_PHYS_PAGES) returns fallback value 1024\e[39m" << frg::endlog;
+         return 1024;
+      case _SC_NPROCESSORS_ONLN:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_NPROCESSORS_ONLN) returns fallback value 1\e[39m" << frg::endlog;
+         return 1;
+      case _SC_GETPW_R_SIZE_MAX:
+         return NSS_BUFLEN_PASSWD;
+      case _SC_GETGR_R_SIZE_MAX:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_GETGR_R_SIZE_MAX) returns fallback value 1024\e[39m" << frg::endlog;
+         return 1024;
+      case _SC_CHILD_MAX:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_CHILD_MAX) returns fallback value 25\e[39m" << frg::endlog;
+         // On linux, it is defined to 25 in most cases, so define it to be 25
+         return 25;
+      case _SC_JOB_CONTROL:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_JOB_CONTROL) returns fallback value 1\e[39m" << frg::endlog;
+         // If 1, job control is supported
+         return 1;
+      case _SC_CLK_TCK:
+         // TODO: This should be obsolete?
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_CLK_TCK) is obsolete and returns arbitrary value 1000000\e[39m" << frg::endlog;
+         return 1000000;
+      case _SC_NGROUPS_MAX:
+         // On linux, it is defined to 65536 in most cases, so define it to be 65536
+         return 10;
+      case _SC_RE_DUP_MAX:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_RE_DUP_MAX) returns fallback value RE_DUP_MAX\e[39m" << frg::endlog;
+         return RE_DUP_MAX;
+      case _SC_LINE_MAX:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_LINE_MAX) returns fallback value 2048\e[39m" << frg::endlog;
+         // Linux defines it as 2048.
+         return 2048;
+      case _SC_XOPEN_CRYPT:
 #if __MLIBC_CRYPT_OPTION
-			return _XOPEN_CRYPT;
+         return _XOPEN_CRYPT;
 #else
-			return -1;
+         return -1;
 #endif /* __MLIBC_CRYPT_OPTION */
-		case _SC_NPROCESSORS_CONF:
-			// TODO: actually return a proper value for _SC_NPROCESSORS_CONF
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_NPROCESSORS_CONF) unconditionally returns fallback value 1\e[39m" << frg::endlog;
-			return 1;
-		case _SC_HOST_NAME_MAX:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_HOST_NAME_MAX) unconditionally returns fallback value 256\e[39m" << frg::endlog;
-			return 256;
-		default:
-			mlibc::infoLogger() << "\e[31mmlibc: sysconf() call is not implemented, number: " << number << "\e[39m" << frg::endlog;
-			errno = EINVAL;
-			return -1;
-	}
+      case _SC_NPROCESSORS_CONF:
+         // TODO: actually return a proper value for _SC_NPROCESSORS_CONF
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_NPROCESSORS_CONF) unconditionally returns fallback value 1\e[39m" << frg::endlog;
+         return 1;
+      case _SC_HOST_NAME_MAX:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf(_SC_HOST_NAME_MAX) unconditionally returns fallback value 256\e[39m" << frg::endlog;
+         return 256;
+      default:
+         mlibc::infoLogger() << "\e[31mmlibc: sysconf() call is not implemented, number: " << number << "\e[39m" << frg::endlog;
+         errno = EINVAL;
+         return -1;
+   }
 }
 
 pid_t tcgetpgrp(int fd) {
-	int pgrp;
-	if(ioctl(fd, TIOCGPGRP, &pgrp) < 0) {
-		return -1;
-	}
-	return pgrp;
+   int pgrp;
+   if(ioctl(fd, TIOCGPGRP, &pgrp) < 0) {
+      return -1;
+   }
+   return pgrp;
 }
 
 int tcsetpgrp(int fd, pid_t pgrp) {
-	return ioctl(fd, TIOCSPGRP, &pgrp);
+   return ioctl(fd, TIOCSPGRP, &pgrp);
 }
 
 int truncate(const char *, off_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 char *ttyname(int fd) {
-	const size_t size = 128;
-	static thread_local char buf[size];
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_ttyname, nullptr);
-	if(int e = mlibc::sys_ttyname(fd, buf, size); e) {
-		errno = e;
-		return nullptr;
-	}
-	return buf;
+   const size_t size = 128;
+   static thread_local char buf[size];
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_ttyname, nullptr);
+   if(int e = mlibc::sys_ttyname(fd, buf, size); e) {
+      errno = e;
+      return nullptr;
+   }
+   return buf;
 }
 
 int ttyname_r(int fd, char *buf, size_t size) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_ttyname, -1);
-	if(int e = mlibc::sys_ttyname(fd, buf, size); e) {
-		return e;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_ttyname, -1);
+   if(int e = mlibc::sys_ttyname(fd, buf, size); e) {
+      return e;
+   }
+   return 0;
 }
 
 int unlink(const char *path) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_unlinkat, -1);
-	if(int e = mlibc::sys_unlinkat(AT_FDCWD, path, 0); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_unlinkat, -1);
+   if(int e = mlibc::sys_unlinkat(AT_FDCWD, path, 0); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int unlinkat(int fd, const char *path, int flags) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_unlinkat, -1);
-	if(int e = mlibc::sys_unlinkat(fd, path, flags); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_unlinkat, -1);
+   if(int e = mlibc::sys_unlinkat(fd, path, flags); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int getpagesize() {
-	return mlibc::page_size;
+   return mlibc::page_size;
 }
 
 // Code taken from musl
 // GLIBC extension for stdin/stdout
 char *getpass(const char *prompt) {
-	int fdin, fdout;
-	struct termios s, t;
-	ssize_t l;
-	static char password[128];
-
-	if((fdin = open("/dev/tty", O_RDWR|O_NOCTTY|O_CLOEXEC)) < 0) {
-		fdin = STDIN_FILENO;
-		fdout = STDOUT_FILENO;
-	} else {
-		fdout = fdin;
-	}
-
-	tcgetattr(fdin, &t);
-	s = t;
-	t.c_lflag &= ~(ECHO | ISIG);
-	t.c_lflag |= ICANON;
-	t.c_iflag &= ~(INLCR | IGNCR);
-	t.c_iflag |= ICRNL;
-	tcsetattr(fdin, TCSAFLUSH, &t);
-	tcdrain(fdin);
-
-	dprintf(fdout, "%s", prompt);
-
-	l = read(fdin, password, sizeof password);
-	if(l >= 0) {
-		if((l > 0 && password[l - 1] == '\n') || l == sizeof password)
-			l--;
-		password[l] = 0;
-	}
-
-	tcsetattr(fdin, TCSAFLUSH, &s);
-
-	dprintf(fdout, "\n");
-	if(fdin != STDIN_FILENO) {
-		close(fdin);
-	}
-
-	return l < 0 ? 0 : password;
+   int fdin, fdout;
+   struct termios s, t;
+   ssize_t l;
+   static char password[128];
+
+   if((fdin = open("/dev/tty", O_RDWR|O_NOCTTY|O_CLOEXEC)) < 0) {
+      fdin = STDIN_FILENO;
+      fdout = STDOUT_FILENO;
+   } else {
+      fdout = fdin;
+   }
+
+   tcgetattr(fdin, &t);
+   s = t;
+   t.c_lflag &= ~(ECHO | ISIG);
+   t.c_lflag |= ICANON;
+   t.c_iflag &= ~(INLCR | IGNCR);
+   t.c_iflag |= ICRNL;
+   tcsetattr(fdin, TCSAFLUSH, &t);
+   tcdrain(fdin);
+
+   dprintf(fdout, "%s", prompt);
+
+   l = read(fdin, password, sizeof password);
+   if(l >= 0) {
+      if((l > 0 && password[l - 1] == '\n') || l == sizeof password)
+         l--;
+      password[l] = 0;
+   }
+
+   tcsetattr(fdin, TCSAFLUSH, &s);
+
+   dprintf(fdout, "\n");
+   if(fdin != STDIN_FILENO) {
+      close(fdin);
+   }
+
+   return l < 0 ? 0 : password;
 }
 
 char *get_current_dir_name(void) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 // This is a Linux extension
 pid_t gettid(void) {
-	if(!mlibc::sys_gettid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_gettid()");
-	}
-	return mlibc::sys_gettid();
+   if(!mlibc::sys_gettid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_gettid()");
+   }
+   return mlibc::sys_gettid();
 }
 
 int getentropy(void *buffer, size_t length) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getentropy, -1);
-	if(length > 256) {
-		errno = EIO;
-		return -1;
-	}
-	if(int e = mlibc::sys_getentropy(buffer, length); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getentropy, -1);
+   if(length > 256) {
+      errno = EIO;
+      return -1;
+   }
+   if(int e = mlibc::sys_getentropy(buffer, length); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 ssize_t write(int fd, const void *buf, size_t count) {
-	ssize_t bytes_written;
-	if(int e = mlibc::sys_write(fd, buf, count, &bytes_written); e) {
-		errno = e;
-		return (ssize_t)-1;
-	}
-	return bytes_written;
+   ssize_t bytes_written;
+   if(int e = mlibc::sys_write(fd, buf, count, &bytes_written); e) {
+      errno = e;
+      return (ssize_t)-1;
+   }
+   return bytes_written;
 }
 
 ssize_t read(int fd, void *buf, size_t count) {
-	ssize_t bytes_read;
-	if(int e = mlibc::sys_read(fd, buf, count, &bytes_read); e) {
-		errno = e;
-		return (ssize_t)-1;
-	}
-	return bytes_read;
+   ssize_t bytes_read;
+   if(int e = mlibc::sys_read(fd, buf, count, &bytes_read); e) {
+      errno = e;
+      return (ssize_t)-1;
+   }
+   return bytes_read;
 }
 
 off_t lseek(int fd, off_t offset, int whence) {
-	off_t new_offset;
-	if(int e = mlibc::sys_seek(fd, offset, whence, &new_offset); e) {
-		errno = e;
-		return (off_t)-1;
-	}
-	return new_offset;
+   off_t new_offset;
+   if(int e = mlibc::sys_seek(fd, offset, whence, &new_offset); e) {
+      errno = e;
+      return (off_t)-1;
+   }
+   return new_offset;
 }
 
 off64_t lseek64(int fd, off64_t offset, int whence) {
-	off64_t new_offset;
-	if(int e = mlibc::sys_seek(fd, offset, whence, &new_offset); e) {
-		errno = e;
-		return (off64_t)-1;
-	}
-	return new_offset;
+   off64_t new_offset;
+   if(int e = mlibc::sys_seek(fd, offset, whence, &new_offset); e) {
+      errno = e;
+      return (off64_t)-1;
+   }
+   return new_offset;
 }
 
 int close(int fd) {
-	return mlibc::sys_close(fd);
+   return mlibc::sys_close(fd);
 }
 
 unsigned int sleep(unsigned int secs) {
-	time_t seconds = secs;
-	long nanos = 0;
-	if(!mlibc::sys_sleep) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_sleep()");
-	}
-	mlibc::sys_sleep(&seconds, &nanos);
-	return seconds;
+   time_t seconds = secs;
+   long nanos = 0;
+   if(!mlibc::sys_sleep) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_sleep()");
+   }
+   mlibc::sys_sleep(&seconds, &nanos);
+   return seconds;
 }
 
 // In contrast to sleep() this functions returns 0/-1 on success/failure.
 int usleep(useconds_t usecs) {
-	time_t seconds = 0;
-	long nanos = usecs * 1000;
-	if(!mlibc::sys_sleep) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_sleep()");
-	}
-	return mlibc::sys_sleep(&seconds, &nanos);
+   time_t seconds = 0;
+   long nanos = usecs * 1000;
+   if(!mlibc::sys_sleep) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_sleep()");
+   }
+   return mlibc::sys_sleep(&seconds, &nanos);
 }
 
 int dup(int fd) {
-	int newfd;
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_dup, -1);
-	if(int e = mlibc::sys_dup(fd, 0, &newfd); e) {
-		errno = e;
-		return -1;
-	}
-	return newfd;
+   int newfd;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_dup, -1);
+   if(int e = mlibc::sys_dup(fd, 0, &newfd); e) {
+      errno = e;
+      return -1;
+   }
+   return newfd;
 }
 
 int dup2(int fd, int newfd) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_dup2, -1);
-	if(int e = mlibc::sys_dup2(fd, 0, newfd); e) {
-		errno = e;
-		return -1;
-	}
-	return newfd;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_dup2, -1);
+   if(int e = mlibc::sys_dup2(fd, 0, newfd); e) {
+      errno = e;
+      return -1;
+   }
+   return newfd;
 }
 
 pid_t fork(void) {
-	auto self = mlibc::get_current_tcb();
-	pid_t child;
+   auto self = mlibc::get_current_tcb();
+   pid_t child;
 
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fork, -1);
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_fork, -1);
 
-	auto hand = self->atforkEnd;
-	while (hand) {
-		if (hand->prepare)
-			hand->prepare();
+   auto hand = self->atforkEnd;
+   while (hand) {
+      if (hand->prepare)
+         hand->prepare();
 
-		hand = hand->prev;
-	}
+      hand = hand->prev;
+   }
 
-	if(int e = mlibc::sys_fork(&child); e) {
-		errno = e;
-		return -1;
-	}
+   if(int e = mlibc::sys_fork(&child); e) {
+      errno = e;
+      return -1;
+   }
 
-	hand = self->atforkBegin;
-	while (hand) {
-		if (!child) {
-			if (hand->child)
-				hand->child();
-		} else {
-			if (hand->parent)
-				hand->parent();
-		}
-		hand = hand->next;
-	}
+   hand = self->atforkBegin;
+   while (hand) {
+      if (!child) {
+         if (hand->child)
+            hand->child();
+      } else {
+         if (hand->parent)
+            hand->parent();
+      }
+      hand = hand->next;
+   }
 
-	return child;
+   return child;
 }
 
 pid_t vfork(void) {
-	pid_t child;
-	/*
-	 * Fork handlers established using pthread_atfork(3) are not
-	 * called when a multithreaded program employing the NPTL
-	 * threading library calls vfork().  Fork handlers are called
-	 * in this case in a program using the LinuxThreads threading
-	 * library.  (See pthreads(7) for a description of Linux
-	 * threading libraries.)
-	 *  - vfork(2), release 5.13 of the Linux man-pages project
-	 *
-	 *  as a result, we call sys_fork instead of running atforks
-	 */
-
-	/* deferring to fork as implementing vfork correctly requires assembly
-	 * to handle not mucking up the stack
-	 */
-	if(!mlibc::sys_fork) {
-		MLIBC_MISSING_SYSDEP();
-		errno = ENOSYS;
-		return -1;
-	}
-
-	if(int e = mlibc::sys_fork(&child); e) {
-		errno = e;
-		return -1;
-	}
-
-	return child;
+   pid_t child;
+   /*
+    * Fork handlers established using pthread_atfork(3) are not
+    * called when a multithreaded program employing the NPTL
+    * threading library calls vfork().  Fork handlers are called
+    * in this case in a program using the LinuxThreads threading
+    * library.  (See pthreads(7) for a description of Linux
+    * threading libraries.)
+    *  - vfork(2), release 5.13 of the Linux man-pages project
+    *
+    *  as a result, we call sys_fork instead of running atforks
+    */
+
+   /* deferring to fork as implementing vfork correctly requires assembly
+    * to handle not mucking up the stack
+    */
+   if(!mlibc::sys_fork) {
+      MLIBC_MISSING_SYSDEP();
+      errno = ENOSYS;
+      return -1;
+   }
+
+   if(int e = mlibc::sys_fork(&child); e) {
+      errno = e;
+      return -1;
+   }
+
+   return child;
 }
 
 int execve(const char *path, char *const argv[], char *const envp[]) {
-	char *null_list[] = {
-		nullptr
-	};
+   char *null_list[] = {
+      nullptr
+   };
 
-	if(!argv)
-		argv = null_list;
-	if(!envp)
-		envp = null_list;
+   if(!argv)
+      argv = null_list;
+   if(!envp)
+      envp = null_list;
 
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_execve, -1);
-	int e = mlibc::sys_execve(path, argv, envp);
-	__ensure(e && "sys_execve() is expected to fail if it returns");
-	errno = e;
-	return -1;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_execve, -1);
+   int e = mlibc::sys_execve(path, argv, envp);
+   __ensure(e && "sys_execve() is expected to fail if it returns");
+   errno = e;
+   return -1;
 }
 
 gid_t getgid(void) {
-	if(!mlibc::sys_getgid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_getgid()");
-	}
-	return mlibc::sys_getgid();
+   if(!mlibc::sys_getgid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_getgid()");
+   }
+   return mlibc::sys_getgid();
 }
 
 gid_t getegid(void) {
-	if(!mlibc::sys_getegid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_getegid()");
-	}
-	return mlibc::sys_getegid();
+   if(!mlibc::sys_getegid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_getegid()");
+   }
+   return mlibc::sys_getegid();
 }
 
 uid_t getuid(void) {
-	if(!mlibc::sys_getuid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_getuid()");
-	}
-	return mlibc::sys_getuid();
+   if(!mlibc::sys_getuid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_getuid()");
+   }
+   return mlibc::sys_getuid();
 }
 
 uid_t geteuid(void) {
-	if(!mlibc::sys_geteuid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_geteuid()");
-	}
-	return mlibc::sys_geteuid();
+   if(!mlibc::sys_geteuid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_geteuid()");
+   }
+   return mlibc::sys_geteuid();
 }
 
 pid_t getpid(void) {
-	if(!mlibc::sys_getpid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_getpid()");
-	}
-	return mlibc::sys_getpid();
+   if(!mlibc::sys_getpid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_getpid()");
+   }
+   return mlibc::sys_getpid();
 }
 
 pid_t getppid(void) {
-	if(!mlibc::sys_getppid) {
-		MLIBC_MISSING_SYSDEP();
-		__ensure(!"Cannot continue without sys_getppid()");
-	}
-	return mlibc::sys_getppid();
+   if(!mlibc::sys_getppid) {
+      MLIBC_MISSING_SYSDEP();
+      __ensure(!"Cannot continue without sys_getppid()");
+   }
+   return mlibc::sys_getppid();
 }
 
 int access(const char *path, int mode) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_access, -1);
-	if(int e = mlibc::sys_access(path, mode); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_access, -1);
+   if(int e = mlibc::sys_access(path, mode); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 char *getusershell(void) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 void setusershell(void) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 void endusershell(void) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int isatty(int fd) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_isatty, 0);
-	if(int e = mlibc::sys_isatty(fd); e) {
-		errno = e;
-		return 0;
-	}
-	return 1;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_isatty, 0);
+   if(int e = mlibc::sys_isatty(fd); e) {
+      errno = e;
+      return 0;
+   }
+   return 1;
 }
 
 int chroot(const char *ptr) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_chroot, -1);
-	if(int e = mlibc::sys_chroot(ptr); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_chroot, -1);
+   if(int e = mlibc::sys_chroot(ptr); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int daemon(int, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 char *ctermid(char *s) {
-	return s ? strcpy(s, "/dev/tty") : const_cast<char *>("/dev/tty");
+   return s ? strcpy(s, "/dev/tty") : const_cast<char *>("/dev/tty");
 }
 
 int setresuid(uid_t ruid, uid_t euid, uid_t suid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setresuid, -1);
-	if(int e = mlibc::sys_setresuid(ruid, euid, suid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setresuid, -1);
+   if(int e = mlibc::sys_setresuid(ruid, euid, suid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int setresgid(gid_t rgid, gid_t egid, gid_t sgid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setresgid, -1);
-	if(int e = mlibc::sys_setresgid(rgid, egid, sgid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_setresgid, -1);
+   if(int e = mlibc::sys_setresgid(rgid, egid, sgid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int getdomainname(char *, size_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int setdomainname(const char *, size_t) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 
 int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getresuid, -1);
-	if(int e = mlibc::sys_getresuid(ruid, euid, suid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getresuid, -1);
+   if(int e = mlibc::sys_getresuid(ruid, euid, suid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid) {
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getresgid, -1);
-	if(int e = mlibc::sys_getresgid(rgid, egid, sgid); e) {
-		errno = e;
-		return -1;
-	}
-	return 0;
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_getresgid, -1);
+   if(int e = mlibc::sys_getresgid(rgid, egid, sgid); e) {
+      errno = e;
+      return -1;
+   }
+   return 0;
 }
 
 #if __MLIBC_CRYPT_OPTION
 void encrypt(char[64], int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+   __ensure(!"Not implemented");
+   __builtin_unreachable();
 }
 #endif
 
 #if __MLIBC_BSD_OPTION
 void *sbrk(intptr_t increment) {
-	if(increment) {
-		errno = ENOMEM;
-		return (void *)-1;
-	}
-
-	MLIBC_CHECK_OR_ENOSYS(mlibc::sys_brk, (void *)-1);
-	void *out;
-	if(int e = mlibc::sys_brk(&out); e) {
-		errno = e;
-		return (void *)-1;
-	}
-	return out;
+   if(increment) {
+      errno = ENOMEM;
+      return (void *)-1;
+   }
+
+   MLIBC_CHECK_OR_ENOSYS(mlibc::sys_brk, (void *)-1);
+   void *out;
+   if(int e = mlibc::sys_brk(&out); e) {
+      errno = e;
+      return (void *)-1;
+   }
+   return out;
 }
 #endif
diff --git mlibc-clean/options/posix/include/fcntl.h mlibc-workdir/options/posix/include/fcntl.h
index 9983219..b43929d 100644
--- mlibc-clean/options/posix/include/fcntl.h
+++ mlibc-workdir/options/posix/include/fcntl.h
@@ -62,9 +62,6 @@ ssize_t vmsplice(int fd, const struct iovec *iov, size_t nr_segs, unsigned int f
 
 #define AT_NO_AUTOMOUNT 0x800
 
-#define F_SETPIPE_SZ 1031
-#define F_GETPIPE_SZ 1032
-
 #define FALLOC_FL_KEEP_SIZE 1
 #define FALLOC_FL_PUNCH_HOLE 2
 
diff --git mlibc-clean/options/posix/include/unistd.h mlibc-workdir/options/posix/include/unistd.h
index 6d11154..52963fb 100644
--- mlibc-clean/options/posix/include/unistd.h
+++ mlibc-workdir/options/posix/include/unistd.h
@@ -94,103 +94,117 @@ extern "C" {
 
 // MISSING: _PC macros
 // For now, use the Linux ABI for _PC constants.
-#define _PC_LINK_MAX		0
-#define _PC_MAX_CANON		1
-#define _PC_MAX_INPUT		2
-#define _PC_NAME_MAX		3
-#define _PC_PATH_MAX		4
-#define _PC_PIPE_BUF		5
-#define _PC_CHOWN_RESTRICTED	6
-#define _PC_NO_TRUNC		7
-#define _PC_VDISABLE		8
+#define _PC_LINK_MAX    0
+#define _PC_MAX_CANON      1
+#define _PC_MAX_INPUT      2
+#define _PC_NAME_MAX    3
+#define _PC_PATH_MAX    4
+#define _PC_PIPE_BUF    5
+#define _PC_CHOWN_RESTRICTED  6
+#define _PC_NO_TRUNC    7
+#define _PC_VDISABLE    8
 
 #define _PC_FILESIZEBITS 9
 #define _PC_SYMLINK_MAX 10
 
-// MISSING: remaining _SC_macros
-#define _SC_ARG_MAX 0
-#define _SC_GETPW_R_SIZE_MAX 1
-#define _SC_PHYS_PAGES 2
-#define _SC_PAGE_SIZE 3
-#define _SC_PAGESIZE _SC_PAGE_SIZE
-#define _SC_OPEN_MAX 5
+// Kernel-supported ABI SC flags
+// TODO: This should be moved to its own abi but the mlibc people wont let
+// me do so without CBT.
+#define _SC_PAGESIZE         1
+#define _SC_OPEN_MAX         2
+#define _SC_HOST_NAME_MAX    3
+#define _SC_AVPHYS_PAGES     4
+#define _SC_PHYS_PAGES       5
 #define _SC_NPROCESSORS_ONLN 6
-#define _SC_GETGR_R_SIZE_MAX 7
-
-#define _SC_CHILD_MAX 8
-#define _SC_CLK_TCK 9
-#define _SC_NGROUPS_MAX 10
-#define _SC_VERSION 11
-#define _SC_SAVED_IDS 12
-#define _SC_JOB_CONTROL 13
-#define _SC_HOST_NAME_MAX 14
-#define _SC_LINE_MAX 15
-#define _SC_XOPEN_CRYPT 16
-#define _SC_NPROCESSORS_CONF 17
-#define _SC_SYMLOOP_MAX 18
-#define _SC_TTY_NAME_MAX 19
-#define _SC_RE_DUP_MAX 20
-
-#define _SC_ATEXIT_MAX 21
-#define _SC_LOGIN_NAME_MAX 22
-#define _SC_THREAD_DESTRUCTOR_ITERATIONS 23
-#define _SC_THREAD_KEYS_MAX 24
-#define _SC_THREAD_STACK_MIN 25
-#define _SC_THREAD_THREADS_MAX 26
-#define _SC_TZNAME_MAX 27
-#define _SC_ASYNCHRONOUS_IO 28
-#define _SC_FSYNC 29
-#define _SC_MAPPED_FILES 30
-#define _SC_MEMLOCK 31
-#define _SC_MEMLOCK_RANGE 32
-#define _SC_MEMORY_PROTECTION 33
-#define _SC_MESSAGE_PASSING 34
-#define _SC_PRIORITY_SCHEDULING 35
-#define _SC_REALTIME_SIGNALS 36
-#define _SC_SEMAPHORES 37
-#define _SC_SHARED_MEMORY_OBJECTS 38
-#define _SC_SYNCHRONIZED_IO 39
-#define _SC_THREADS 40
-#define _SC_THREAD_ATTR_STACKADDR 41
-#define _SC_THREAD_ATTR_STACKSIZE 42
-#define _SC_THREAD_PRIORITY_SCHEDULING 43
-#define _SC_THREAD_PRIO_INHERIT 44
-#define _SC_THREAD_PRIO_PROTECT 45
-#define _SC_THREAD_PROCESS_SHARED 46
-#define _SC_THREAD_SAFE_FUNCTIONS 47
-#define _SC_TIMERS 48
-#define _SC_TIMER_MAX 49
-#define _SC_2_CHAR_TERM 50
-#define _SC_2_C_BIND 51
-#define _SC_2_C_DEV 52
-#define _SC_2_FORT_DEV 53
-#define _SC_2_FORT_RUN 54
-#define _SC_2_LOCALEDEF 55
-#define _SC_2_SW_DEV 56
-#define _SC_2_UPE 57
-#define _SC_2_VERSION 58
-#define _SC_CLOCK_SELECTION 59
-#define _SC_CPUTIME 60
-#define _SC_THREAD_CPUTIME 61
-#define _SC_MONOTONIC_CLOCK 62
-#define _SC_READER_WRITER_LOCKS 63
-#define _SC_SPIN_LOCKS 64
-#define _SC_REGEXP 65
-#define _SC_SHELL 66
-#define _SC_SPAWN 67
-#define _SC_2_PBS 68
-#define _SC_2_PBS_ACCOUNTING 69
-#define _SC_2_PBS_LOCATE 70
-#define _SC_2_PBS_TRACK 71
-#define _SC_2_PBS_MESSAGE 72
-#define _SC_STREAM_MAX 73
-#define _SC_AIO_LISTIO_MAX 74
-#define _SC_AIO_MAX 75
-#define _SC_DELAYTIMER_MAX 76
-#define _SC_MQ_OPEN_MAX 77
-#define _SC_MQ_PRIO_MAX 78
-#define _SC_RTSIG_MAX 79
-#define _SC_SIGQUEUE_MAX 80
+#define _SC_TOTAL_PAGES      7
+#define _SC_LIST_PROCS       8
+#define _SC_LIST_MOUNTS      9
+#define _SC_UNAME            10
+#define _SC_CHILD_MAX        11
+#define _SC_LIST_THREADS     12
+#define _SC_LIST_CLUSTERS    13
+#define _SC_LIST_NETINTER    14
+#define _SC_DUMPLOGS         15
+#define _SC_NGROUPS_MAX      16
+#define _SC_SYMLOOP_MAX      17
+
+// SC Aliases
+#define _SC_PAGE_SIZE _SC_PAGESIZE
+
+// The rest of libc-emulated SC macros
+// MISSING: remaining _SC_macros
+#define _SC_ARG_MAX                      18
+#define _SC_GETPW_R_SIZE_MAX             19
+#define _SC_GETGR_R_SIZE_MAX             20
+#define _SC_CLK_TCK                      21
+#define _SC_VERSION                      22
+#define _SC_SAVED_IDS                    23
+#define _SC_JOB_CONTROL                  24
+#define _SC_LINE_MAX                     25
+#define _SC_XOPEN_CRYPT                  26
+#define _SC_NPROCESSORS_CONF             27
+#define _SC_TTY_NAME_MAX                 28
+#define _SC_RE_DUP_MAX                   29
+#define _SC_ATEXIT_MAX                   30
+#define _SC_LOGIN_NAME_MAX               31
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS 32
+#define _SC_THREAD_KEYS_MAX              33
+#define _SC_THREAD_STACK_MIN             34
+#define _SC_THREAD_THREADS_MAX           35
+#define _SC_TZNAME_MAX                   36
+#define _SC_ASYNCHRONOUS_IO              37
+#define _SC_FSYNC                        38
+#define _SC_MAPPED_FILES                 39
+#define _SC_MEMLOCK                      40
+#define _SC_MEMLOCK_RANGE                41
+#define _SC_MEMORY_PROTECTION            42
+#define _SC_MESSAGE_PASSING              43
+#define _SC_PRIORITY_SCHEDULING          44
+#define _SC_REALTIME_SIGNALS             45
+#define _SC_SEMAPHORES                   46
+#define _SC_SHARED_MEMORY_OBJECTS        47
+#define _SC_SYNCHRONIZED_IO              48
+#define _SC_THREADS                      49
+#define _SC_THREAD_ATTR_STACKADDR        50
+#define _SC_THREAD_ATTR_STACKSIZE        51
+#define _SC_THREAD_PRIORITY_SCHEDULING   52
+#define _SC_THREAD_PRIO_INHERIT          53
+#define _SC_THREAD_PRIO_PROTECT          54
+#define _SC_THREAD_PROCESS_SHARED        55
+#define _SC_THREAD_SAFE_FUNCTIONS        56
+#define _SC_TIMERS                       57
+#define _SC_TIMER_MAX                    58
+#define _SC_2_CHAR_TERM                  59
+#define _SC_2_C_BIND                     60
+#define _SC_2_C_DEV                      61
+#define _SC_2_FORT_DEV                   62
+#define _SC_2_FORT_RUN                   63
+#define _SC_2_LOCALEDEF                  64
+#define _SC_2_SW_DEV                     65
+#define _SC_2_UPE                        66
+#define _SC_2_VERSION                    67
+#define _SC_CLOCK_SELECTION              68
+#define _SC_CPUTIME                      69
+#define _SC_THREAD_CPUTIME               70
+#define _SC_MONOTONIC_CLOCK              71
+#define _SC_READER_WRITER_LOCKS          72
+#define _SC_SPIN_LOCKS                   73
+#define _SC_REGEXP                       74
+#define _SC_SHELL                        75
+#define _SC_SPAWN                        76
+#define _SC_2_PBS                        78
+#define _SC_2_PBS_ACCOUNTING             79
+#define _SC_2_PBS_LOCATE                 80
+#define _SC_2_PBS_TRACK                  81
+#define _SC_2_PBS_MESSAGE                82
+#define _SC_STREAM_MAX                   83
+#define _SC_AIO_LISTIO_MAX               84
+#define _SC_AIO_MAX                      85
+#define _SC_DELAYTIMER_MAX               86
+#define _SC_MQ_OPEN_MAX                  88
+#define _SC_MQ_PRIO_MAX                  89
+#define _SC_RTSIG_MAX                    90
+#define _SC_SIGQUEUE_MAX                 91
 
 #define STDERR_FILENO 2
 #define STDIN_FILENO 0
@@ -344,11 +358,11 @@ void encrypt(char block[64], int flags);
 #endif
 
 #if __MLIBC_LINUX_OPTION
-#	include <bits/linux/linux_unistd.h>
+#  include <bits/linux/linux_unistd.h>
 #endif
 
 #if __MLIBC_BSD_OPTION
-#	include <bits/bsd/bsd_unistd.h>
+#  include <bits/bsd/bsd_unistd.h>
 #endif
 
 #endif // _UNISTD_H
diff --git mlibc-clean/options/rtdl/generic/linker.cpp mlibc-workdir/options/rtdl/generic/linker.cpp
index a0f2bf5..4c3a8c6 100644
--- mlibc-clean/options/rtdl/generic/linker.cpp
+++ mlibc-workdir/options/rtdl/generic/linker.cpp
@@ -514,18 +514,25 @@ void ObjectRepository::_fetchFromFile(SharedObject *object, int fd) {
 
 				void *map_pointer;
 				if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
-						total_map_size, prot | PROT_WRITE,
+						total_map_size, PROT_WRITE,
 						MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
 					__ensure(!"sys_vm_map failed");
 
 				seekOrDie(fd, phdr->p_offset);
 				readExactlyOrDie(fd, reinterpret_cast<char *>(map_address) + misalign,
 						phdr->p_filesz);
+
+				if (prot & PROT_EXEC) {
+				   prot = PROT_READ | PROT_EXEC;
+			   }
+				if (mlibc::sys_vm_protect (reinterpret_cast<void *>(map_address),
+				      total_map_size, prot))
+				   __ensure(!"vm_protect not feeling all there");
 			#endif
 			// Take care of removing superfluous permissions.
-			if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
-				if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
-					mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
+			//if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
+			//	if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
+			//		mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
 		}else if(phdr->p_type == PT_TLS) {
 			object->tlsSegmentSize = phdr->p_memsz;
 			object->tlsAlignment = phdr->p_align;
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index 7136150..4d0f40d 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -19,707 +19,743 @@
 namespace mlibc {
 
 void sys_libc_log(const char *message) {
-	ssize_t unused;
-	char new_line = '\n';
-	sys_write(2, message, strlen(message), &unused);
-	sys_write(2, &new_line, 1, &unused);
+   ssize_t unused;
+   char new_line = '\n';
+   sys_write(2, message, strlen(message), &unused);
+   sys_write(2, &new_line, 1, &unused);
 }
 
 void sys_libc_panic() {
-	ssize_t unused;
-	char const *message = "mlibc panicked unrecoverably\n";
-	sys_write(2, message, strlen(message), &unused);
-	sys_exit(1);
+   ssize_t unused;
+   char const *message = "mlibc panicked unrecoverably\n";
+   sys_write(2, message, strlen(message), &unused);
+   sys_exit(1);
 }
 
 void sys_exit(int status) {
-	int ret, errno;
-	SYSCALL1(SYSCALL_EXIT, status);
-	__builtin_unreachable();
+   int ret, errno;
+   SYSCALL1(SYSCALL_EXIT, status);
+   __builtin_unreachable();
 }
 
 int sys_tcb_set(void *pointer) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_ARCH_PRCTL, 1, pointer);
+   return errno;
 }
 
 int sys_open(const char *path, int flags, mode_t mode, int *fd) {
-	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+   return sys_openat(AT_FDCWD, path, flags, mode, fd);
 }
 
 int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
-	int ret, errno;
-
-	int path_len = strlen (path);
-	SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
-	if (ret != -1 && (flags & O_EXCL)) {
-		 SYSCALL1(SYSCALL_CLOSE, ret);
-		 return EEXIST;
-	}
-
-	if (ret == -1 && (flags & O_CREAT)) {
-		 SYSCALL5(SYSCALL_MAKENODE, AT_FDCWD, path, path_len, mode, 0);
-		 if (ret == -1) {
-			  return errno;
-		 }
-		 SYSCALL4(SYSCALL_OPEN,	AT_FDCWD, path, path_len, flags);
-	} else if (ret != -1 && (flags & O_TRUNC)) {
-		// If the file cannot be truncated, dont sweat it, some software
-		// depends on some things being truncate-able that ironclad does not
-		// allow. For example, some devices.
-		sys_ftruncate(ret, 0);
-	} else if (ret != -1 && (flags & O_DIRECTORY)) {
-		struct stat st;
-		sys_stat(fsfd_target::fd, ret, NULL, 0, &st);
-		if (!S_ISDIR (st.st_mode)) {
-			ret	= -1;
-			errno = ENOTDIR;
-		}
-	}
-
-	*fd = ret;
-	return errno;
+   int ret, errno;
+
+   int path_len = strlen (path);
+   SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
+   if (ret != -1 && (flags & O_EXCL)) {
+       SYSCALL1(SYSCALL_CLOSE, ret);
+       return EEXIST;
+   }
+
+   if (ret == -1 && (flags & O_CREAT)) {
+       SYSCALL5(SYSCALL_MAKENODE, AT_FDCWD, path, path_len, mode, 0);
+       if (ret == -1) {
+           return errno;
+       }
+       SYSCALL4(SYSCALL_OPEN, AT_FDCWD, path, path_len, flags);
+   } else if (ret != -1 && (flags & O_TRUNC)) {
+      // If the file cannot be truncated, dont sweat it, some software
+      // depends on some things being truncate-able that ironclad does not
+      // allow. For example, some devices.
+      sys_ftruncate(ret, 0);
+   } else if (ret != -1 && (flags & O_DIRECTORY)) {
+      struct stat st;
+      sys_stat(fsfd_target::fd, ret, NULL, 0, &st);
+      if (!S_ISDIR (st.st_mode)) {
+         ret   = -1;
+         errno = ENOTDIR;
+      }
+   }
+
+   *fd = ret;
+   return errno;
 }
 
 int sys_open_dir(const char *path, int *handle) {
-	return sys_open(path, O_RDONLY | O_DIRECTORY, 0660, handle);
+   return sys_open(path, O_RDONLY | O_DIRECTORY, 0660, handle);
 }
 
 int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
-	size_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_GETDENTS, handle, buffer, max_size);
-	if (errno != 0) {
-		return errno;
-	} else {
-		*bytes_read = ret;
-		return 0;
-	}
+   size_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_GETDENTS, handle, buffer, max_size);
+   if (errno != 0) {
+      return errno;
+   } else {
+      *bytes_read = ret;
+      return 0;
+   }
 }
 
 void sys_thread_exit() {
-	 int ret, errno;
-	 SYSCALL0(SYSCALL_EXIT_THREAD);
-	 __builtin_unreachable();
+    int ret, errno;
+    SYSCALL0(SYSCALL_EXIT_THREAD);
+    __builtin_unreachable();
 }
 
 int sys_close(int fd) {
-	int ret, errno;
-	SYSCALL1(SYSCALL_CLOSE, fd);
-	return errno;
+   int ret, errno;
+   SYSCALL1(SYSCALL_CLOSE, fd);
+   return errno;
 }
 
 void sys_sync() {
-	int ret, errno;
-	SYSCALL0(SYSCALL_SYNC);
-	if (ret != 0) {
-		sys_libc_log("mlibc: sync failed");
-	}
+   int ret, errno;
+   SYSCALL0(SYSCALL_SYNC);
+   if (ret != 0) {
+      sys_libc_log("mlibc: sync failed");
+   }
 }
 
 int sys_fsync(int fd) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_FSYNC, fd, 0);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_FSYNC, fd, 0);
+   return errno;
 }
 
 int sys_fdatasync(int fd) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_FSYNC, fd, 1);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_FSYNC, fd, 1);
+   return errno;
 }
 
 int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
-	ssize_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_READ, fd, buf, count);
-	*bytes_read = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_READ, fd, buf, count);
+   *bytes_read = ret;
+   return errno;
 }
 
 int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
-	ssize_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_WRITE, fd, buf, count);
-	*bytes_written = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_WRITE, fd, buf, count);
+   *bytes_written = ret;
+   return errno;
 }
 
 int sys_pread(int fd, void *buf, size_t n, off_t off, ssize_t *bytes_read) {
-	ssize_t ret;
-	int errno;
-	SYSCALL4(SYSCALL_PREAD, fd, buf, n, off);
-	*bytes_read = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL4(SYSCALL_PREAD, fd, buf, n, off);
+   *bytes_read = ret;
+   return errno;
 }
 
 int sys_pwrite(int fd, const void *buf, size_t n, off_t off, ssize_t *bytes_written) {
-	ssize_t ret;
-	int errno;
-	SYSCALL4(SYSCALL_WRITE, fd, buf, n, off);
-	*bytes_written = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL4(SYSCALL_WRITE, fd, buf, n, off);
+   *bytes_written = ret;
+   return errno;
 }
 
 int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
-	ssize_t ret;
-	int errno;
-	SYSCALL3(SYSCALL_SEEK, fd, offset, whence);
-	*new_offset = ret;
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL3(SYSCALL_SEEK, fd, offset, whence);
+   *new_offset = ret;
+   return errno;
 }
 
 int sys_ftruncate (int fd, size_t size) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_TRUNCATE, fd, size);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_TRUNCATE, fd, size);
+   return errno;
 }
 
 int sys_flock(int fd, int options) {
-	struct flock lock;
-	lock.l_whence = SEEK_SET;
-	lock.l_start = 0;
-	lock.l_len = (off_t)((uint64_t)-1);
-	lock.l_pid = sys_getpid();
-
-	switch (options) {
-		case LOCK_SH:
-			lock.l_type = F_RDLCK;
-			break;
-		case LOCK_EX:
-			lock.l_type = F_WRLCK;
-			break;
-		case LOCK_UN:
-			lock.l_type = F_UNLCK;
-			break;
-		default:
-			return -1;
-	}
-
-	int ret, errno;
-	SYSCALL3(SYSCALL_FCNTL, fd, F_SETLK, &lock);
-	return errno;
+   struct flock lock;
+   lock.l_whence = SEEK_SET;
+   lock.l_start = 0;
+   lock.l_len = (off_t)((uint64_t)-1);
+   lock.l_pid = sys_getpid();
+
+   switch (options) {
+      case LOCK_SH:
+         lock.l_type = F_RDLCK;
+         break;
+      case LOCK_EX:
+         lock.l_type = F_WRLCK;
+         break;
+      case LOCK_UN:
+         lock.l_type = F_UNLCK;
+         break;
+      default:
+         return -1;
+   }
+
+   int ret, errno;
+   SYSCALL3(SYSCALL_FCNTL, fd, F_SETLK, &lock);
+   return errno;
+}
+
+int sys_getpriority(int which, id_t who, int *value) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_GETPRIO, which, who);
+   *value = ret;
+   return errno;
+}
+
+int sys_setpriority(int which, id_t who, int value) {
+   int ret, errno;
+   SYSCALL3(SYSCALL_SETPRIO, which, who, value);
+   return errno;
 }
 
 int sys_getrusage(int scope, struct rusage *usage) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_GETRUSAGE, scope, usage);
+   int ret, errno;
+   SYSCALL2(SYSCALL_GETRUSAGE, scope, usage);
 
-	// Ironclad returns nanoseconds instead of microseconds for usage, so we
-	// have to compensate for that.
-	usage->ru_utime.tv_usec = usage->ru_utime.tv_usec / 1000;
-	usage->ru_stime.tv_usec = usage->ru_stime.tv_usec / 1000;
+   // Ironclad returns nanoseconds instead of microseconds for usage, so we
+   // have to compensate for that.
+   usage->ru_utime.tv_usec = usage->ru_utime.tv_usec / 1000;
+   usage->ru_stime.tv_usec = usage->ru_stime.tv_usec / 1000;
 
-	return errno;
+   return errno;
 }
 
 int sys_anon_allocate(size_t size, void **pointer) {
-	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON, 0, 0, pointer);
+   return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON, 0, 0, pointer);
 }
 
 int sys_anon_free(void *pointer, size_t size) {
-	return sys_vm_unmap(pointer, size);
+   return sys_vm_unmap(pointer, size);
 }
 
 int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
-	void *ret;
-	int errno;
-	SYSCALL6(SYSCALL_MMAP, hint, size, prot, flags, fd, offset);
-	*window = ret;
-	return errno;
+   void *ret;
+   int errno;
+   SYSCALL6(SYSCALL_MMAP, hint, size, prot, flags, fd, offset);
+   *window = ret;
+   return errno;
 }
 
 int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) {
-	(void)fd;
-	(void)size;
-	if (layer == SOL_SOCKET && number == SO_PEERCRED) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
-		*(int *)buffer = 4096;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_TYPE) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
-		*(int *)buffer = SOCK_STREAM;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_ERROR) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
-		*(int *)buffer = 0;
-		return 0;
-	} else {
-		mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
-	}
-
-	return 0;
+   (void)fd;
+   (void)size;
+   if (layer == SOL_SOCKET && number == SO_PEERCRED) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
+      *(int *)buffer = 0;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+      *(int *)buffer = 4096;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_TYPE) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
+      *(int *)buffer = SOCK_STREAM;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_ERROR) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
+      *(int *)buffer = 0;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
+      mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
+      *(int *)buffer = 0;
+      return 0;
+   } else {
+      mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+   }
+
+   return 0;
 }
 
 int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) {
-	(void)fd;
-	(void)buffer;
-	(void)size;
-	if (layer == SOL_SOCKET && number == SO_PASSCRED) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
-		mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == SOL_SOCKET && number == SO_REUSEADDR) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
-		return 0;
-	} else if (layer == AF_NETLINK && number == SO_ACCEPTCONN) {
-		mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
-		return 0;
-	} else {
-		mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
-	}
-
-	 return 0;
+   (void)fd;
+   (void)buffer;
+   (void)size;
+   if (layer == SOL_SOCKET && number == SO_PASSCRED) {
+      mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER) {
+      mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE) {
+      mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_SNDBUF) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_KEEPALIVE) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
+      return 0;
+   } else if (layer == SOL_SOCKET && number == SO_REUSEADDR) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
+      return 0;
+   } else if (layer == AF_NETLINK && number == SO_ACCEPTCONN) {
+      mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
+      return 0;
+   } else {
+      mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+   }
+
+    return 0;
 }
 
 int sys_vm_unmap(void *pointer, size_t size) {
-	int ret;
-	int errno;
-	SYSCALL2(SYSCALL_MUNMAP, pointer, size);
-	if (ret != 0) {
-		return errno;
-	} else {
-		return 0;
-	}
+   int ret;
+   int errno;
+   SYSCALL2(SYSCALL_MUNMAP, pointer, size);
+   if (ret != 0) {
+      return errno;
+   } else {
+      return 0;
+   }
 }
 
 int sys_vm_protect(void *pointer, size_t size, int prot) {
-	int ret;
-	int errno;
-	SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
-	if (ret != 0) {
-		return errno;
-	}
-	return 0;
+   int ret;
+   int errno;
+   SYSCALL3(SYSCALL_MPROTECT, pointer, size, prot);
+   if (ret != 0) {
+      return errno;
+   }
+   return 0;
 }
 
 pid_t sys_getpid() {
-	pid_t ret;
-	int errno;
-	SYSCALL0(SYSCALL_GETPID);
-	return ret;
+   pid_t ret;
+   int errno;
+   SYSCALL0(SYSCALL_GETPID);
+   return ret;
 }
 
 pid_t sys_getppid() {
-	pid_t ret;
-	int errno;
-	SYSCALL0(SYSCALL_GETPPID);
-	return ret;
+   pid_t ret;
+   int errno;
+   SYSCALL0(SYSCALL_GETPPID);
+   return ret;
+}
+
+int sys_getgroups(size_t size, const gid_t *list, int *retval) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_GETGROUPS, size, list);
+   *retval = ret;
+   return errno;
+}
+
+int sys_setgroups(size_t size, const gid_t *list) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGROUPS, size, list);
+   return errno;
 }
 
 int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
-	return 0;
+   return 0;
 }
 
 int sys_ptrace(long req, pid_t pid, void *addr, void *data, long *out) {
-	int ret, errno;
-	SYSCALL4(SYSCALL_PTRACE, req, pid, addr, data);
-	*out = (long)ret;
-	return errno;
+   int ret, errno;
+   SYSCALL4(SYSCALL_PTRACE, req, pid, addr, data);
+   *out = (long)ret;
+   return errno;
 }
 
 int sys_fcntl(int fd, int request, va_list args, int *result) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
-	*result = ret;
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_FCNTL, fd, request, va_arg(args, uint64_t));
+   *result = ret;
+   return errno;
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
-	return 0;
+   return 0;
 }
 
 int sys_isatty(int fd) {
-	struct termios t;
-	if (sys_tcgetattr(fd, &t) == 0) {
-		return 0;
-	} else {
-		return ENOTTY;
-	}
-}
-
-gid_t sys_getgid() {
-	// FIXME: Stub needed by mlibc.
-	return 0;
-}
-
-gid_t sys_getegid() {
-	// FIXME: Stub needed by mlibc.
-	return 0;
+   struct termios t;
+   if (sys_tcgetattr(fd, &t) == 0) {
+      return 0;
+   } else {
+      return ENOTTY;
+   }
 }
 
 int sys_getpgid(pid_t pid, pid_t *pgid) {
-	(void)pid;
-	// FIXME: Stub needed by mlibc.
-	*pgid = 0;
-	return 0;
+   (void)pid;
+   // FIXME: Stub needed by mlibc.
+   *pgid = 0;
+   return 0;
 }
 
 int sys_execve(const char *path, char *const argv[], char *const envp[]) {
-	int ret, errno, argv_len, envp_len;
-	for (argv_len = 0; argv[argv_len] != NULL; argv_len++);
-	for (envp_len = 0; envp[envp_len] != NULL; envp_len++);
+   int ret, errno, argv_len, envp_len;
+   for (argv_len = 0; argv[argv_len] != NULL; argv_len++);
+   for (envp_len = 0; envp[envp_len] != NULL; envp_len++);
 
-	size_t path_len = strlen (path);
-	SYSCALL6(SYSCALL_EXEC, path, path_len, argv, argv_len, envp, envp_len);
+   size_t path_len = strlen (path);
+   SYSCALL6(SYSCALL_EXEC, path, path_len, argv, argv_len, envp, envp_len);
 
-	if (ret == -1) {
-		return errno;
-	 }
+   if (ret == -1) {
+      return errno;
+    }
 
-	return 0;
+   return 0;
 }
 
 int sys_fork(pid_t *child) {
-	pid_t ret;
-	int errno;
+   pid_t ret;
+   int errno;
 
-	SYSCALL6(SYSCALL_CLONE, 0, 0, 0, 0, 0, 1);
+   SYSCALL6(SYSCALL_CLONE, 0, 0, 0, 0, 0, 1);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	if (child != NULL) {
-		*child = ret;
-	}
+   if (child != NULL) {
+      *child = ret;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_getrlimit(int resource, struct rlimit *limit) {
-	uint64_t ret, errno;
-	SYSCALL1(SYSCALL_GETRLIMIT, resource);
-	limit->rlim_cur = ret;
-	limit->rlim_max = ret;
-	return errno;
+   uint64_t ret, errno;
+   SYSCALL1(SYSCALL_GETRLIMIT, resource);
+   limit->rlim_cur = ret;
+   limit->rlim_max = ret;
+   return errno;
 }
 
 int sys_setrlimit(int resource, const struct rlimit *limit) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_SETRLIMIT, resource, limit->rlim_cur);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETRLIMIT, resource, limit->rlim_cur);
+   return errno;
 }
 
 int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
-	pid_t ret;
-	int errno;
+   pid_t ret;
+   int errno;
 
-	if(ru) {
-		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
-		return ENOSYS;
-	}
+   if(ru) {
+      mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
+      return ENOSYS;
+   }
 
-	SYSCALL3(SYSCALL_WAIT, pid, status, flags);
+   SYSCALL3(SYSCALL_WAIT, pid, status, flags);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	*ret_pid = ret;
-	return errno;
+   *ret_pid = ret;
+   return errno;
 }
 
 int sys_uname(struct utsname *buf) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL3(SYSCALL_SYSCONF, 10, buf, sizeof(struct utsname));
+   SYSCALL3(SYSCALL_SYSCONF, 10, buf, sizeof(struct utsname));
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 
 
 int sys_setpgid(pid_t pid, pid_t pgid) {
-	(void)pid;
-	(void)pgid;
-	mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
-	return 0;
+   (void)pid;
+   (void)pgid;
+   mlibc::infoLogger() << "mlibc: " << __func__ << " is a stub!" << frg::endlog;
+   return 0;
 }
 
 int sys_ttyname(int, char *, size_t) {
-	return ENOSYS;
+   return ENOSYS;
 }
 
 int sys_sethostname(const char *buff, size_t size) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL2(SYSCALL_SETHOSTNAME, buff, size);
+   SYSCALL2(SYSCALL_SETHOSTNAME, buff, size);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_chdir(const char *buff) {
-	int ret, errno;
+   int ret, errno;
 
-	size_t buff_len = strlen(buff);
-	SYSCALL4(SYSCALL_OPEN, AT_FDCWD, buff, buff_len, O_RDONLY);
-	if (ret == -1) {
-		return ENOENT;
-	}
+   size_t buff_len = strlen(buff);
+   SYSCALL4(SYSCALL_OPEN, AT_FDCWD, buff, buff_len, O_RDONLY);
+   if (ret == -1) {
+      return ENOENT;
+   }
 
-	SYSCALL1(SYSCALL_CHDIR, ret);
+   SYSCALL1(SYSCALL_CHDIR, ret);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_fchdir(int fd) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL1(SYSCALL_CHDIR, fd);
+   SYSCALL1(SYSCALL_CHDIR, fd);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	return 0;
+   return 0;
 }
 
 int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
-	int ret, errno;
+   int ret, errno;
 
-	SYSCALL3(SYSCALL_IOCTL, fd, request, arg);
+   SYSCALL3(SYSCALL_IOCTL, fd, request, arg);
 
-	if (ret == -1) {
-		return errno;
-	}
+   if (ret == -1) {
+      return errno;
+   }
 
-	*result = ret;
-	return 0;
+   *result = ret;
+   return 0;
 }
 
 void sys_yield(void) {
-	int ret, errno;
-	SYSCALL0(SYSCALL_SCHED_YIELD);
+   int ret, errno;
+   SYSCALL0(SYSCALL_SCHED_YIELD);
 }
 
 int sys_kill(int pid, int sig) {
-	int ret, errno;
-	if (sig == SIGKILL) {
-		SYSCALL1(SYSCALL_ACTUALLY_KILL, pid);
-	} else {
-		SYSCALL2(SYSCALL_SEND_SIGNAL, pid, sig);
-	}
+   int ret, errno;
+   if (sig == SIGKILL) {
+      SYSCALL1(SYSCALL_ACTUALLY_KILL, pid);
+   } else {
+      SYSCALL2(SYSCALL_SEND_SIGNAL, pid, sig);
+   }
 
-	return errno;
+   return errno;
 }
 
 int sys_dup(int fd, int flags, int *newfd) {
-	int ret, errno;
-	if (flags & O_CLOEXEC) {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, 0);
-	} else {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
-	}
-	*newfd = ret;
-	return errno;
+   int ret, errno;
+   if (flags & O_CLOEXEC) {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, 0);
+   } else {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
+   }
+   *newfd = ret;
+   return errno;
 }
 
 int sys_dup2(int fd, int flags, int newfd) {
-	if (sys_close(newfd) != 0) {
-		 return EBADFD;
-	}
+   if (sys_close(newfd) != 0) {
+       return EBADFD;
+   }
 
-	int ret, errno;
-	if (flags & O_CLOEXEC) {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
-	} else {
-		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
-	}
+   int ret, errno;
+   if (flags & O_CLOEXEC) {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD_CLOEXEC, newfd);
+   } else {
+      SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, newfd);
+   }
 
-	if (ret != -1 && ret != newfd) {
-		return EBADFD;
-	} else {
-		return errno;
-	}
+   if (ret != -1 && ret != newfd) {
+      return EBADFD;
+   } else {
+      return errno;
+   }
 }
 
 int sys_tcgetattr(int fd, struct termios *attr) {
-	 int ret;
+    int ret;
 
-	 if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
-		  return r;
-	 }
+    if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0) {
+        return r;
+    }
 
-	 return 0;
+    return 0;
 }
 
 int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
-	 int ret;
+    int ret;
 
-	 switch (optional_action) {
-		  case TCSANOW:
-				optional_action = TCSETS; break;
-		  case TCSADRAIN:
-				optional_action = TCSETSW; break;
-		  case TCSAFLUSH:
-				optional_action = TCSETSF; break;
-		  default:
-				__ensure(!"Unsupported tcsetattr");
-	 }
+    switch (optional_action) {
+        case TCSANOW:
+            optional_action = TCSETS; break;
+        case TCSADRAIN:
+            optional_action = TCSETSW; break;
+        case TCSAFLUSH:
+            optional_action = TCSETSF; break;
+        default:
+            __ensure(!"Unsupported tcsetattr");
+    }
 
-	 if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
-		  return r;
-	 }
+    if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0) {
+        return r;
+    }
 
-	 return 0;
+    return 0;
 }
 
 int sys_access(const char *path, int mode) {
-	int ret, errno;
-	size_t len = strlen(path);
-	SYSCALL5(SYSCALL_ACCESS, AT_FDCWD, path, len, mode, 0);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(path);
+   SYSCALL5(SYSCALL_ACCESS, AT_FDCWD, path, len, mode, 0);
+   return errno;
 }
 
 int sys_faccessat(int dirfd, const char *pathname, int mode, int flags) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL5(SYSCALL_ACCESS, dirfd, pathname, len, mode, flags);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL5(SYSCALL_ACCESS, dirfd, pathname, len, mode, flags);
+   return errno;
 }
 
 struct futex_item {
-	 uint64_t addr;
-	 uint32_t expected;
-	 uint32_t flags;
+    uint64_t addr;
+    uint32_t expected;
+    uint32_t flags;
 };
 
 int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
-	int ret, errno;
-	struct futex_item item = {.addr = (uint64_t)pointer, .expected = expected, .flags = 0};
-	if (time == NULL) {
-		 struct timespec t = {(time_t)-1, (time_t)-1};
-		 SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, &t);
-	} else {
-		 SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, time);
-	}
-	return errno;
+   int ret, errno;
+   struct futex_item item = {.addr = (uint64_t)pointer, .expected = expected, .flags = 0};
+   if (time == NULL) {
+       struct timespec t = {(time_t)-1, (time_t)-1};
+       SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, &t);
+   } else {
+       SYSCALL4(SYSCALL_FUTEX, 0b01, &item, 1, time);
+   }
+   return errno;
 }
 
 int sys_futex_wake(int *pointer) {
-	int ret, errno;
-	struct futex_item item = {.addr = (uint64_t)pointer, .expected = 0, .flags = 0};
-	struct timespec t = {(time_t)-1, (time_t)-1};
-	SYSCALL4(SYSCALL_FUTEX, 0b10, &item, 1, &t);
-	return errno;
+   int ret, errno;
+   struct futex_item item = {.addr = (uint64_t)pointer, .expected = 0, .flags = 0};
+   struct timespec t = {(time_t)-1, (time_t)-1};
+   SYSCALL4(SYSCALL_FUTEX, 0b10, &item, 1, &t);
+   return errno;
 }
 
 int sys_pipe(int *fds, int flags) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_PIPE, fds, flags);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_PIPE, fds, flags);
+   return errno;
 }
 
 int sys_getentropy(void *buffer, size_t length) {
-	ssize_t ret;
-	int errno;
-	SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
-	return errno;
+   ssize_t ret;
+   int errno;
+   SYSCALL2(SYSCALL_GETRANDOM, buffer, length);
+   return errno;
 }
 
 int sys_mkdir(const char *path, mode_t mode) {
-	return sys_mkdirat(AT_FDCWD, path, mode);
+   return sys_mkdirat(AT_FDCWD, path, mode);
 }
 
 int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
-	int ret, errno;
-	size_t path_len = strlen (path);
-	SYSCALL5(SYSCALL_MAKENODE, dirfd, path, path_len, S_IFDIR | mode, 0);
-	return errno;
+   int ret, errno;
+   size_t path_len = strlen (path);
+   SYSCALL5(SYSCALL_MAKENODE, dirfd, path, path_len, S_IFDIR | mode, 0);
+   return errno;
 }
 
 int sys_rmdir(const char* path){
-	int ret, errno;
-	size_t path_len = strlen (path);
-	SYSCALL3(SYSCALL_UNLINK, AT_FDCWD, path, path_len);
-	return errno;
+   int ret, errno;
+   size_t path_len = strlen (path);
+   SYSCALL3(SYSCALL_UNLINK, AT_FDCWD, path, path_len);
+   return errno;
 }
 
 int sys_unlinkat(int fd, const char *path, int flags) {
-	int ret, errno;
-	size_t path_len = strlen (path);
-	SYSCALL3(SYSCALL_UNLINK, fd, path, path_len);
-	return errno;
+   int ret, errno;
+   size_t path_len = strlen (path);
+   SYSCALL3(SYSCALL_UNLINK, fd, path, path_len);
+   return errno;
 }
 
 int sys_link(const char* srcpath, const char* destpath) {
-	int ret, errno;
-	size_t src_len = strlen (srcpath);
-	size_t dst_len = strlen (destpath);
-	SYSCALL6(SYSCALL_LINK, AT_FDCWD, srcpath, src_len, AT_FDCWD, destpath, dst_len);
-	return errno;
+   int ret, errno;
+   size_t src_len = strlen (srcpath);
+   size_t dst_len = strlen (destpath);
+   SYSCALL6(SYSCALL_LINK, AT_FDCWD, srcpath, src_len, AT_FDCWD, destpath, dst_len);
+   return errno;
 }
 
 int sys_socket(int domain, int type, int protocol, int *fd) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_SOCKET, domain, type, protocol);
-	if (ret != -1) {
-		*fd = ret;
-		return 0;
-	} else {
-		return errno;
-	}
+   int ret, errno;
+   SYSCALL3(SYSCALL_SOCKET, domain, type, protocol);
+   if (ret != -1) {
+      *fd = ret;
+      return 0;
+   } else {
+      return errno;
+   }
 }
 
 uid_t sys_getuid() {
-	uint64_t ret, errno;
-	SYSCALL0(SYSCALL_GETUID);
-	return (uid_t)ret;
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETUID);
+   return (uid_t)ret;
 }
 
 uid_t sys_geteuid() {
-	uint64_t ret, errno;
-	SYSCALL0(SYSCALL_GETEUID);
-	return (uid_t)ret;
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETEUID);
+   return (uid_t)ret;
 }
 
 int sys_setuid(uid_t uid) {
-	int ret, errno;
-	if (uid == 0) {
-		 SYSCALL2(SYSCALL_SETUIDS, uid, uid);
-	} else {
-		 SYSCALL2(SYSCALL_SETUIDS, uid, ((uint64_t)-1));
-	}
-	return ret;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETUIDS, uid, uid);
+   return ret;
 }
 
 int sys_seteuid(uid_t euid) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_SETUIDS, ((uint64_t)-1), euid);
-	return ret;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETUIDS, ((uint64_t)-1), euid);
+   return ret;
+}
+
+gid_t sys_getgid() {
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETGID);
+   return (gid_t)ret;
+}
+
+gid_t sys_getegid() {
+   uint64_t ret, errno;
+   SYSCALL0(SYSCALL_GETEGID);
+   return (gid_t)ret;
+}
+
+int sys_setgid(gid_t gid) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGIDS, gid, gid);
+   return ret;
+}
+
+int sys_setegid(gid_t egid) {
+   int ret, errno;
+   SYSCALL2(SYSCALL_SETGIDS, ((uint64_t)-1), egid);
+   return ret;
 }
 
 #ifndef MLIBC_BUILDING_RTDL
@@ -727,443 +763,493 @@ int sys_seteuid(uid_t euid) {
 extern "C" void __mlibc_thread_entry();
 
 int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
-	 int ret, errno;
-	 SYSCALL6(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb, 1);
+    int ret, errno;
+    SYSCALL6(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb, 1);
 
-	 if (ret == -1) {
-		  return errno;
-	 }
+    if (ret == -1) {
+        return errno;
+    }
 
-	 *tid_out = (pid_t)ret;
-	 return 0;
+    *tid_out = (pid_t)ret;
+    return 0;
 }
 
 int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size) {
-	// TODO guard
+   // TODO guard
 
-	mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+   mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
 
-	*guard_size = 0;
-	*stack_size = *stack_size ? *stack_size : 0x400000;
+   *guard_size = 0;
+   *stack_size = *stack_size ? *stack_size : 0x400000;
 
-	if (!*stack) {
-		*stack = (void *)((char *)mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size);
-		if (*stack == MAP_FAILED) {
-			return errno;
-		}
-	}
+   if (!*stack) {
+      *stack = (void *)((char *)mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size);
+      if (*stack == MAP_FAILED) {
+         return errno;
+      }
+   }
 
-	void **stack_it = (void **)*stack;
+   void **stack_it = (void **)*stack;
 
-	*--stack_it = arg;
-	*--stack_it = tcb;
-	*--stack_it = entry;
+   *--stack_it = arg;
+   *--stack_it = tcb;
+   *--stack_it = entry;
 
-	*stack = (void *)stack_it;
+   *stack = (void *)stack_it;
 
-	return 0;
+   return 0;
 }
 
 int sys_clock_getres(int clock, time_t *secs, long *nanos) {
-	struct timespec time;
-	int ret, errno;
-	SYSCALL3(SYSCALL_CLOCK, 0, clock, &time);
-	*secs  = time.tv_sec;
-	*nanos = time.tv_nsec;
-	return errno;
+   struct timespec time;
+   int ret, errno;
+   SYSCALL3(SYSCALL_CLOCK, 0, clock, &time);
+   *secs  = time.tv_sec;
+   *nanos = time.tv_nsec;
+   return errno;
 }
 
 int sys_clock_get(int clock, time_t *secs, long *nanos) {
-	struct timespec time;
-	int ret, errno;
-	SYSCALL3(SYSCALL_CLOCK, 1, clock, &time);
-	*secs  = time.tv_sec;
-	*nanos = time.tv_nsec;
-	return errno;
+   struct timespec time;
+   int ret, errno;
+   SYSCALL3(SYSCALL_CLOCK, 1, clock, &time);
+   *secs  = time.tv_sec;
+   *nanos = time.tv_nsec;
+   return errno;
 }
 
 int sys_clock_set(int clock, time_t secs, long nanos) {
-	struct timespec time = {.tv_sec = secs, .tv_nsec = nanos };
-	int ret, errno;
-	SYSCALL3(SYSCALL_CLOCK, 2, clock, &time);
-	return errno;
+   struct timespec time = {.tv_sec = secs, .tv_nsec = nanos };
+   int ret, errno;
+   SYSCALL3(SYSCALL_CLOCK, 2, clock, &time);
+   return errno;
 }
 
 int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addrlen) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_BIND, fd, addr_ptr, addrlen);
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_BIND, fd, addr_ptr, addrlen);
+   return errno;
 }
 
 int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addrlen) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_CONNECT, fd, addr_ptr, addrlen);
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_CONNECT, fd, addr_ptr, addrlen);
+   return errno;
 }
 
 int sys_listen(int fd, int backlog) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_LISTEN, fd, backlog);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_LISTEN, fd, backlog);
+   return errno;
 }
 
 int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length, int flags) {
-	int ret, errno;
-	SYSCALL4(SYSCALL_ACCEPT, fd, addr_ptr, addr_length, flags);
-	*newfd = ret;
-	return errno;
+   int ret, errno;
+   SYSCALL4(SYSCALL_ACCEPT, fd, addr_ptr, addr_length, flags);
+   *newfd = ret;
+   return errno;
 }
 
 
 int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_GETSOCKNAME, fd, addr_ptr, &max_addr_length);
-	*actual_length = max_addr_length;
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_GETSOCKNAME, fd, addr_ptr, &max_addr_length);
+   *actual_length = max_addr_length;
+   return errno;
 }
 
 int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
-	int ret, errno;
-	SYSCALL3(SYSCALL_GETPEERNAME, fd, addr_ptr, &max_addr_length);
-	*actual_length = max_addr_length;
-	return errno;
+   int ret, errno;
+   SYSCALL3(SYSCALL_GETPEERNAME, fd, addr_ptr, &max_addr_length);
+   *actual_length = max_addr_length;
+   return errno;
 }
 
 int sys_shutdown(int sockfd, int how) {
-	int ret, errno;
-	SYSCALL2(SYSCALL_SHUTDOWN, sockfd, how);
-	return errno;
+   int ret, errno;
+   SYSCALL2(SYSCALL_SHUTDOWN, sockfd, how);
+   return errno;
 }
 
 int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
-	if (hdr->msg_control != NULL) {
-		mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
-		return EINVAL;
-	}
+   if (hdr->msg_control != NULL) {
+      mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
+      return EINVAL;
+   }
 
-	int ret;
-	size_t count = 0;
-	int errno;
+   int ret;
+   size_t count = 0;
+   int errno;
 
-	for (int i = 0; i < hdr->msg_iovlen; i++) {
-		SYSCALL6(SYSCALL_RECVFROM, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
-					hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
-		if (ret == -1) {
-			return errno;
-		}
-		count += ret;
-	}
+   for (int i = 0; i < hdr->msg_iovlen; i++) {
+      SYSCALL6(SYSCALL_RECVFROM, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
+               hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
+      if (ret == -1) {
+         return errno;
+      }
+      count += ret;
+   }
 
-	*length = count;
-	return 0;
+   *length = count;
+   return 0;
 }
 
 int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
-	if (hdr->msg_control != NULL) {
-		mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
-		return EINVAL;
-	}
+   if (hdr->msg_control != NULL) {
+      mlibc::infoLogger() << "mlibc: recv() msg_control not supported!" << frg::endlog;
+      return EINVAL;
+   }
 
-	int ret;
-	size_t count = 0;
-	int errno;
+   int ret;
+   size_t count = 0;
+   int errno;
 
-	for (int i = 0; i < hdr->msg_iovlen; i++) {
-		SYSCALL6(SYSCALL_SENDTO, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
-					hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
-		if (ret == -1) {
-			return errno;
-		}
-		count += ret;
-	}
+   for (int i = 0; i < hdr->msg_iovlen; i++) {
+      SYSCALL6(SYSCALL_SENDTO, fd, hdr->msg_iov->iov_base, hdr->msg_iov->iov_len,
+               hdr->msg_flags, hdr->msg_name, hdr->msg_namelen);
+      if (ret == -1) {
+         return errno;
+      }
+      count += ret;
+   }
 
-	*length = count;
-	return 0;
+   *length = count;
+   return 0;
 }
 
 
 int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
-	// XXX: Ironclad has no sigprogmask so this is basically a weird ppoll poll
-	// chimeral abomination.
-	int ret, errno;
-	if (timeout == NULL) {
-		 struct timespec t = {.tv_sec = (time_t)-1, .tv_nsec = (time_t)-1};
-		 SYSCALL3(SYSCALL_POLL, fds, nfds, &t);
-	} else {
-		 SYSCALL3(SYSCALL_POLL, fds, nfds, timeout);
-	}
-	if (ret == -1) {
-		return errno;
-	}
-
-	*num_events = ret;
-	return errno;
+   // XXX: Ironclad has no sigprogmask so this is basically a weird ppoll poll
+   // chimeral abomination.
+   int ret, errno;
+   if (timeout == NULL) {
+       struct timespec t = {.tv_sec = (time_t)-1, .tv_nsec = (time_t)-1};
+       SYSCALL3(SYSCALL_POLL, fds, nfds, &t);
+   } else {
+       SYSCALL3(SYSCALL_POLL, fds, nfds, timeout);
+   }
+   if (ret == -1) {
+      return errno;
+   }
+
+   *num_events = ret;
+   return errno;
 }
 
 int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
-	struct timespec ts;
-	ts.tv_sec = timeout / 1000;
-	ts.tv_nsec = (timeout % 1000) * 1000000;
-	return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
+   struct timespec ts;
+   ts.tv_sec = timeout / 1000;
+   ts.tv_nsec = (timeout % 1000) * 1000000;
+   return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
 }
 
 int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set,
-		fd_set *except_set, const struct timespec *timeout,
-		const sigset_t *sigmask, int *num_events) {
-	struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
-	if (fds == NULL) {
-		return ENOMEM;
-	}
-
-	for (int i = 0; i < nfds; i++) {
-		struct pollfd *fd = &fds[i];
-
-		if (read_set && FD_ISSET(i, read_set)) {
-			fd->events |= POLLIN;
-		}
-		if (write_set && FD_ISSET(i, write_set)) {
-			fd->events |= POLLOUT;
-		}
-		if (except_set && FD_ISSET(i, except_set)) {
-			fd->events |= POLLPRI;
-		}
-
-		if (!fd->events) {
-			fd->fd = -1;
-			continue;
-		}
-		fd->fd = i;
-	}
-
-	int ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
-	if (ret != 0) {
-		free(fds);
-		return ret;
-	}
-
-	fd_set res_read_set, res_write_set, res_except_set;
-	FD_ZERO(&res_read_set);
-	FD_ZERO(&res_write_set);
-	FD_ZERO(&res_except_set);
-
-	for (int i = 0; i < nfds; i++) {
-		struct pollfd *fd = &fds[i];
-
-		if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0) {
-			FD_SET(i, &res_read_set);
-		}
-		if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0) {
-			FD_SET(i, &res_write_set);
-		}
-		if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) {
-			FD_SET(i, &res_except_set);
-		}
-	}
-
-	free(fds);
-	if (read_set) {
-		*read_set = res_read_set;
-	}
-	if (write_set) {
-		*write_set = res_write_set;
-	}
-	if (except_set) {
-		*except_set = res_except_set;
-	}
-
-	return 0;
+      fd_set *except_set, const struct timespec *timeout,
+      const sigset_t *sigmask, int *num_events) {
+   struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
+   if (fds == NULL) {
+      return ENOMEM;
+   }
+
+   for (int i = 0; i < nfds; i++) {
+      struct pollfd *fd = &fds[i];
+
+      if (read_set && FD_ISSET(i, read_set)) {
+         fd->events |= POLLIN;
+      }
+      if (write_set && FD_ISSET(i, write_set)) {
+         fd->events |= POLLOUT;
+      }
+      if (except_set && FD_ISSET(i, except_set)) {
+         fd->events |= POLLPRI;
+      }
+
+      if (!fd->events) {
+         fd->fd = -1;
+         continue;
+      }
+      fd->fd = i;
+   }
+
+   int ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
+   if (ret != 0) {
+      free(fds);
+      return ret;
+   }
+
+   fd_set res_read_set, res_write_set, res_except_set;
+   FD_ZERO(&res_read_set);
+   FD_ZERO(&res_write_set);
+   FD_ZERO(&res_except_set);
+
+   for (int i = 0; i < nfds; i++) {
+      struct pollfd *fd = &fds[i];
+
+      if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0) {
+         FD_SET(i, &res_read_set);
+      }
+      if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0) {
+         FD_SET(i, &res_write_set);
+      }
+      if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) {
+         FD_SET(i, &res_except_set);
+      }
+   }
+
+   free(fds);
+   if (read_set) {
+      *read_set = res_read_set;
+   }
+   if (write_set) {
+      *write_set = res_write_set;
+   }
+   if (except_set) {
+      *except_set = res_except_set;
+   }
+
+   return 0;
 }
 
 int sys_sleep(time_t *secs, long *nanos) {
-	struct timespec time = {.tv_sec = *secs, .tv_nsec = *nanos};
-	struct timespec rem  = {.tv_sec = 0, .tv_nsec = 0};
+   struct timespec time = {.tv_sec = *secs, .tv_nsec = *nanos};
+   struct timespec rem  = {.tv_sec = 0, .tv_nsec = 0};
 
-	int ret, errno;
-	SYSCALL4(SYSCALL_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, 0, &time, &rem);
-	*secs  = rem.tv_sec;
-	*nanos = rem.tv_nsec;
-	return errno;
+   int ret, errno;
+   SYSCALL4(SYSCALL_CLOCK_NANOSLEEP, CLOCK_MONOTONIC, 0, &time, &rem);
+   *secs  = rem.tv_sec;
+   *nanos = rem.tv_nsec;
+   return errno;
 }
 
 int sys_gethostname(char *buffer, size_t bufsize) {
-	struct utsname buf;
-	if (uname(&buf)) {
-		return -1;
-	}
+   struct utsname buf;
+   if (uname(&buf)) {
+      return -1;
+   }
 
-	strncpy(buffer, buf.nodename, bufsize);
-	return 0;
+   strncpy(buffer, buf.nodename, bufsize);
+   return 0;
 }
 
 int sys_utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags) {
-	int ret, errno;
-	if (pathname == NULL) {
-		pathname = "";
-		flags |= AT_EMPTY_PATH;
-	}
-
-	size_t path_len = strlen (pathname);
-	if (times == NULL) {
-		 time_t secs;
-		 long nsec;
-		 ret = sys_clock_get(CLOCK_REALTIME, &secs, &nsec);
-		 if (ret) {
-			  return ret;
-		 }
-		 struct timespec times2[2] = {0, 0};
-		 times2[0].tv_sec = secs;
-		 times2[0].tv_nsec = nsec;
-		 times2[1].tv_sec = secs;
-		 times2[1].tv_nsec = nsec;
-		 SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, &times2[0], flags);
-	} else {
-		SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, times, flags);
-	}
-
-	return errno;
+   int ret, errno;
+   if (pathname == NULL) {
+      pathname = "";
+      flags |= AT_EMPTY_PATH;
+   }
+
+   size_t path_len = strlen (pathname);
+   if (times == NULL) {
+       time_t secs;
+       long nsec;
+       ret = sys_clock_get(CLOCK_REALTIME, &secs, &nsec);
+       if (ret) {
+           return ret;
+       }
+       struct timespec times2[2] = {0, 0};
+       times2[0].tv_sec = secs;
+       times2[0].tv_nsec = nsec;
+       times2[1].tv_sec = secs;
+       times2[1].tv_nsec = nsec;
+       SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, &times2[0], flags);
+   } else {
+      SYSCALL5(SYSCALL_UTIMES, dirfd, pathname, path_len, times, flags);
+   }
+
+   return errno;
 }
 
 int sys_sysconf(int num, long *rret) {
-	long ret, errno;
+   long ret, errno;
 
-	// Translate the number for the POSIX compat of the sysconf.
-	int translated;
-	switch (num) {
-		case _SC_PAGE_SIZE:		  translated = 1;  break;
-		case _SC_OPEN_MAX:			translated = 2;  break;
-		case _SC_HOST_NAME_MAX:	 translated = 3;  break;
-		case _SC_NPROCESSORS_ONLN: translated = 6;  break;
-		case _SC_PHYS_PAGES:		 translated = 7;  break;
-		case _SC_CHILD_MAX:		  translated = 11; break;
+   // Translate the number for the POSIX compat of the sysconf.
+   int translated;
+   switch (num) {
+      case _SC_PAGE_SIZE:       translated = 1;  break;
+      case _SC_OPEN_MAX:         translated = 2;  break;
+      case _SC_HOST_NAME_MAX:  translated = 3;  break;
+      case _SC_NPROCESSORS_ONLN: translated = 6;  break;
+      case _SC_PHYS_PAGES:     translated = 7;  break;
+      case _SC_CHILD_MAX:       translated = 11; break;
 
-		// These are values that mlibc technically has to provide itself, but
-		// I personally dont like how ugly the hardcoded warnings look, so I just
-		// harcode them myself :)
-		case _SC_LINE_MAX: *rret = 4096; return 0;
+      // These are values that mlibc technically has to provide itself, but
+      // I personally dont like how ugly the hardcoded warnings look, so I just
+      // harcode them myself :)
+      case _SC_LINE_MAX: *rret = 4096; return 0;
 
-		// Default is for mlibc to handle it.
-		default: return EINVAL;
-	}
+      // Default is for mlibc to handle it.
+      default: return EINVAL;
+   }
 
-	SYSCALL3(SYSCALL_SYSCONF, translated, 0, 0);
-	*rret = ret;
-	return errno;
+   SYSCALL3(SYSCALL_SYSCONF, translated, 0, 0);
+   *rret = ret;
+   return errno;
 }
 
 int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
-	int ret, errno;
-	(void)flags;
-
-	switch (fsfdt) {
-		case fsfd_target::fd: {
-			SYSCALL5(SYSCALL_STAT, fd, "", 0, statbuf, AT_EMPTY_PATH);
-			break;
-		}
-		case fsfd_target::path: {
-			size_t len = strlen(path);
-			SYSCALL5(SYSCALL_STAT, AT_FDCWD, path, len, statbuf, flags);
-			break;
-		}
-		case fsfd_target::fd_path: {
-			size_t len = strlen(path);
-			SYSCALL5(SYSCALL_STAT, fd, path, len, statbuf, flags);
-			break;
-		}
-		default: {
-			__ensure(!"stat: Invalid fsfdt");
-			__builtin_unreachable();
-		}
-	}
-
-	return errno;
+   int ret, errno;
+   (void)flags;
+
+   switch (fsfdt) {
+      case fsfd_target::fd: {
+         SYSCALL5(SYSCALL_STAT, fd, "", 0, statbuf, AT_EMPTY_PATH);
+         break;
+      }
+      case fsfd_target::path: {
+         size_t len = strlen(path);
+         SYSCALL5(SYSCALL_STAT, AT_FDCWD, path, len, statbuf, flags);
+         break;
+      }
+      case fsfd_target::fd_path: {
+         size_t len = strlen(path);
+         SYSCALL5(SYSCALL_STAT, fd, path, len, statbuf, flags);
+         break;
+      }
+      default: {
+         __ensure(!"stat: Invalid fsfdt");
+         __builtin_unreachable();
+      }
+   }
+
+   return errno;
 }
 
 int sys_chmod(const char *pathname, mode_t mode) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL5(SYSCALL_FCHMOD, AT_FDCWD, pathname, len, mode, 0);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL5(SYSCALL_FCHMOD, AT_FDCWD, pathname, len, mode, 0);
+   return errno;
 }
 
 int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL5(SYSCALL_FCHMOD, fd, pathname, len, mode, flags);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL5(SYSCALL_FCHMOD, fd, pathname, len, mode, flags);
+   return errno;
 }
 
 int sys_fchmod(int fd, mode_t mode) {
-	int ret, errno;
-	SYSCALL5(SYSCALL_FCHMOD, fd, "", 0, mode, AT_EMPTY_PATH);
-	return errno;
+   int ret, errno;
+   SYSCALL5(SYSCALL_FCHMOD, fd, "", 0, mode, AT_EMPTY_PATH);
+   return errno;
 }
 
 int sys_chown(const char *pathname, uid_t uid, gid_t gid) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL6(SYSCALL_FCHOWN, AT_FDCWD, pathname, len, uid, gid, 0);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL6(SYSCALL_FCHOWN, AT_FDCWD, pathname, len, uid, gid, 0);
+   return errno;
 }
 
 int sys_fchownat(int fd, const char *pathname, uid_t uid, gid_t gid, int flags) {
-	int ret, errno;
-	size_t len = strlen(pathname);
-	SYSCALL6(SYSCALL_FCHOWN, fd, pathname, len, uid, gid, flags);
-	return errno;
+   int ret, errno;
+   size_t len = strlen(pathname);
+   SYSCALL6(SYSCALL_FCHOWN, fd, pathname, len, uid, gid, flags);
+   return errno;
 }
 
 int sys_fchown(int fd, uid_t uid, gid_t gid) {
-	int ret, errno;
-	SYSCALL6(SYSCALL_FCHOWN, fd, "", 0, uid, gid, AT_EMPTY_PATH);
-	return errno;
+   int ret, errno;
+   SYSCALL6(SYSCALL_FCHOWN, fd, "", 0, uid, gid, AT_EMPTY_PATH);
+   return errno;
 }
 
 int sys_umask(mode_t mode, mode_t *old) {
-	mode_t ret;
-	int errno;
-	SYSCALL1(SYSCALL_UMASK, mode);
-	*old = (mode_t)ret;
-	return errno;
+   mode_t ret;
+   int errno;
+   SYSCALL1(SYSCALL_UMASK, mode);
+   *old = (mode_t)ret;
+   return errno;
 }
 
 int sys_readlink(const char *path, void *buffer, size_t max_size, ssize_t *length) {
-	ssize_t ret;
-	int errno;
-	size_t path_len = strlen(path);
-	SYSCALL5(SYSCALL_READLINK, AT_FDCWD, path, path_len, buffer, max_size);
-	if (ret == -1) {
-		return errno;
-	} else {
-		*length = ret;
-		return 0;
-	}
+   ssize_t ret;
+   int errno;
+   size_t path_len = strlen(path);
+   SYSCALL5(SYSCALL_READLINK, AT_FDCWD, path, path_len, buffer, max_size);
+   if (ret == -1) {
+      return errno;
+   } else {
+      *length = ret;
+      return 0;
+   }
 }
 
 int sys_rename(const char *path, const char *new_path) {
-	int ret;
-	int errno;
-	size_t old_len = strlen(path);
-	size_t new_len = strlen(new_path);
-	SYSCALL7(SYSCALL_RENAME, AT_FDCWD, path, old_len, AT_FDCWD, new_path, new_len, 0);
-	return errno;
+   int ret;
+   int errno;
+   size_t old_len = strlen(path);
+   size_t new_len = strlen(new_path);
+   SYSCALL7(SYSCALL_RENAME, AT_FDCWD, path, old_len, AT_FDCWD, new_path, new_len, 0);
+   return errno;
 }
 
 int sys_renameat(int olddirfd, const char *old_path, int newdirfd, const char *new_path) {
-	int ret;
-	int errno;
-	size_t old_len = strlen(old_path);
-	size_t new_len = strlen(new_path);
-	SYSCALL7(SYSCALL_RENAME, olddirfd, old_path, old_len, newdirfd, new_path, new_len, 0);
-	return errno;
+   int ret;
+   int errno;
+   size_t old_len = strlen(old_path);
+   size_t new_len = strlen(new_path);
+   SYSCALL7(SYSCALL_RENAME, olddirfd, old_path, old_len, newdirfd, new_path, new_len, 0);
+   return errno;
 }
 
 int sys_mknodat(int dirfd, const char *path, mode_t mode, dev_t dev) {
-	int ret;
-	int errno;
-	size_t len = strlen(path);
-	SYSCALL5(SYSCALL_MAKENODE, dirfd, path, len, mode, dev);
-	return errno;
-}
+   int ret;
+   int errno;
+   size_t len = strlen(path);
+   SYSCALL5(SYSCALL_MAKENODE, dirfd, path, len, mode, dev);
+   return errno;
+}
+
+#define SC_LIST_MOUNTS 9
+struct mountinfo {
+    uint32_t type;
+    uint32_t flags;
+    char     source[20];
+    uint32_t source_length;
+    char     location[20];
+    uint32_t location_length;
+    uint64_t block_size;
+    uint64_t fragment_size;
+    uint64_t size_in_fragments;
+    uint64_t free_blocks;
+    uint64_t free_blocks_user;
+    uint64_t inode_count;
+    uint64_t free_inodes;
+    uint64_t free_inodes_user;
+    uint64_t max_filename;
+};
 
+int sys_statvfs(const char *path, struct statvfs *out) {
+   long ret, errno;
+   struct mountinfo *buffer = (mountinfo *)malloc(5 * sizeof(struct mountinfo));
+   SYSCALL3(SYSCALL_SYSCONF, SC_LIST_MOUNTS, buffer, 5 * sizeof(struct mountinfo));
+   if (errno) {
+      free(buffer);
+      return errno;
+   } else if (ret > 5) {
+      free(buffer);
+      return 1;
+   }
+
+   for (int i = 0; i < ret; i++) {
+      if (!strncmp(path, buffer[i].location, buffer[i].location_length)) {
+         out->f_bsize  = buffer[i].block_size;
+         out->f_frsize = buffer[i].fragment_size;
+         out->f_blocks = buffer[i].size_in_fragments;
+         out->f_bfree  = buffer[i].free_blocks;
+         out->f_bavail = buffer[i].free_blocks_user;
+         out->f_files  = buffer[i].inode_count;
+         out->f_ffree  = buffer[i].free_inodes;
+         out->f_favail = buffer[i].free_inodes_user;
+         out->f_fsid   = 0;
+         out->f_flag   = buffer[i].flags;
+         out->f_namemax = buffer[i].max_filename;
+         return 0;
+      }
+   }
+
+   return EINVAL;
+}
 #endif
 } // namespace mlibc
diff --git mlibc-clean/sysdeps/ironclad/generic/mount.cpp mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
index ff060e0..227bac0 100644
--- mlibc-clean/sysdeps/ironclad/generic/mount.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/mount.cpp
@@ -4,31 +4,17 @@
 #include <sys/syscall.h>
 #include <string.h>
 
-int mount(const char *source, const char *target,
-		const char *fstype, unsigned long flags, const void *data) {
-	int ret, errno;
-	size_t source_len = strlen(source);
-	size_t target_len = strlen(target);
-	int val;
-	if (!strcmp(fstype, "ext")) {
-		val = 1;
-	} else if (!strcmp(fstype, "fat32")) {
-		val = 2;
-	} else {
-		return EINVAL;
-	}
-
-	SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, val, flags);
-	return errno;
-}
-
-int umount(const char *target) {
-	return umount2(target, 0);
+int mount(const char *source, const char *target, int type, int flags) {
+   int ret;
+   size_t source_len = strlen(source);
+   size_t target_len = strlen(target);
+   SYSCALL6(SYSCALL_MOUNT, source, source_len, target, target_len, type, flags);
+   return ret;
 }
 
-int umount2(const char *target, int flags) {
-	int ret, errno;
-	size_t target_len = strlen(target);
-	SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
-	return errno;
+int umount(const char *target, int flags) {
+   int ret;
+   size_t target_len = strlen(target);
+   SYSCALL3(SYSCALL_UMOUNT, target, target_len, flags);
+   return ret;
 }
diff --git mlibc-clean/sysdeps/ironclad/include/sys/mount.h mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
index 71ae64d..51263fa 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/mount.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
@@ -5,12 +5,17 @@
 extern "C" {
 #endif
 
+#define MNT_EXT 1
+#define MNT_FAT 2
+
+#define MS_RDONLY   0b001
+#define MS_REMOUNT  0b010
+#define MS_RELATIME 0b100
+
 #define MNT_FORCE 1
 
-int mount(const char *source, const char *target,
-		const char *fstype, unsigned long flags, const void *data);
-int umount(const char *target);
-int umount2(const char *target, int flags);
+int mount(const char *source, const char *target, int type, int flags);
+int umount(const char *target, int flags);
 
 #ifdef __cplusplus
 }
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index b0227d5..51a1840 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -4,84 +4,84 @@
 #include <stddef.h>
 
 #define SYSCALL0(NUM) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM) \
-				  : "rcx", "r11", "memory"); \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL1(NUM, ARG0) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0) \
-				  : "rcx", "r11", "memory"); \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL2(NUM, ARG0, ARG1) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1) \
-				  : "rcx", "r11", "memory"); \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL3(NUM, ARG0, ARG1, ARG2) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2) \
-				  : "rcx", "r11", "memory"); \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL4(NUM, ARG0, ARG1, ARG2, ARG3) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12) \
-				  : "rcx", "r11", "memory"); \
+   register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+               "r"(arg_r12) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL5(NUM, ARG0, ARG1, ARG2, ARG3, ARG4) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8 asm("r8") = ARG4; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8) \
-				  : "rcx", "r11", "memory"); \
+   register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
+   register __typeof(ARG4) arg_r8 asm("r8") = ARG4; \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+               "r"(arg_r12), "r"(arg_r8) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8 asm("r8") = ARG4; \
-	register __typeof(ARG5) arg_r9 asm("r9") = ARG5; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
-				  : "rcx", "r11", "memory"); \
+   register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
+   register __typeof(ARG4) arg_r8 asm("r8") = ARG4; \
+   register __typeof(ARG5) arg_r9 asm("r9") = ARG5; \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+               "r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8  asm("r8")  = ARG4; \
-	register __typeof(ARG5) arg_r9  asm("r9")  = ARG5; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
-				  : "rcx", "r11", "memory"); \
+   register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
+   register __typeof(ARG4) arg_r8  asm("r8")  = ARG4; \
+   register __typeof(ARG5) arg_r9  asm("r9")  = ARG5; \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+               "r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL7(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8  asm("r8")  = ARG4; \
-	register __typeof(ARG5) arg_r9  asm("r9")  = ARG5; \
-	register __typeof(ARG6) arg_r10 asm("r10") = ARG6; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9), "r"(arg_r10) \
-				  : "rcx", "r11", "memory"); \
+   register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
+   register __typeof(ARG4) arg_r8  asm("r8")  = ARG4; \
+   register __typeof(ARG5) arg_r9  asm("r9")  = ARG5; \
+   register __typeof(ARG6) arg_r10 asm("r10") = ARG6; \
+   asm volatile ("syscall" \
+              : "=a"(ret), "=d"(errno) \
+              : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+               "r"(arg_r12), "r"(arg_r8), "r"(arg_r9), "r"(arg_r10) \
+              : "rcx", "r11", "memory"); \
 })
 
 #define SYSCALL_EXIT                  0
@@ -166,5 +166,12 @@
 #define SYSCALL_ACTUALLY_KILL        79
 #define SYSCALL_SIGNALPOST           80
 #define SYSCALL_SEND_SIGNAL          81
+#define SYSCALL_GETPRIO              82
+#define SYSCALL_SETPRIO              83
+#define SYSCALL_GETGID               84
+#define SYSCALL_GETEGID              85
+#define SYSCALL_SETGIDS              86
+#define SYSCALL_GETGROUPS            87
+#define SYSCALL_SETGROUPS            88
 
 #endif // _SYS_SYSCALL_H
