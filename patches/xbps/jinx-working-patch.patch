diff --git xbps-clean/bin/xbps-create/main.c xbps-workdir/bin/xbps-create/main.c
index 373e744..73ed280 100644
--- xbps-clean/bin/xbps-create/main.c
+++ xbps-workdir/bin/xbps-create/main.c
@@ -41,7 +41,7 @@
 #include <libgen.h>
 #include <locale.h>
 #include <dirent.h>
-
+#include <limits.h>
 #include <xbps.h>
 #include "queue.h"
 
diff --git xbps-clean/bin/xbps-install/util.c xbps-workdir/bin/xbps-install/util.c
index 7cabdd1..0182300 100644
--- xbps-clean/bin/xbps-install/util.c
+++ xbps-workdir/bin/xbps-install/util.c
@@ -32,7 +32,7 @@
 #include <strings.h>
 #include <sys/ioctl.h>
 #include <assert.h>
-
+#include <termios.h>
 #include <xbps.h>
 #include "defs.h"
 
diff --git xbps-clean/configure xbps-workdir/configure
index 57df730..ec499ae 100755
--- xbps-clean/configure
+++ xbps-workdir/configure
@@ -275,7 +275,7 @@ fi
 #
 # Check for some compiler warning flags.
 #
-for f in all extra error shadow "format=2" missing-prototypes \
+for f in all extra shadow "format=2" missing-prototypes \
 	missing-declarations nested-externs vla overlength-strings \
 	unsafe-loop-optimizations undef sign-compare \
 	missing-include-dirs old-style-definition \
@@ -677,7 +677,7 @@ fi
 # pkg-config is required to know dependencies for static linking.
 #
 printf "Checking for pkg-config ... "
-PKGCONFIG_BIN=$(_which pkg-config)
+PKGCONFIG_BIN="x86_64-ironclad-mlibc-pkg-config"
 if [ -z "$PKGCONFIG_BIN" ]; then
 	echo "not found, exiting."
 	exit 1
@@ -691,14 +691,14 @@ fi
 LIBARCHIVE_REQVER=3.3.3
 
 printf "Checking for libarchive >= ${LIBARCHIVE_REQVER}  via pkg-config ... "
-if ! pkg-config --atleast-version=${LIBARCHIVE_REQVER} libarchive; then
+if ! $PKGCONFIG_BIN --atleast-version=${LIBARCHIVE_REQVER} libarchive; then
 	echo "libarchive.pc file not found, exiting."
 	exit 1
 else
-	echo "found version $(pkg-config --modversion libarchive)."
-	echo "CFLAGS += $(pkg-config --cflags libarchive)" >>$CONFIG_MK
-	echo "LDFLAGS +=        $(pkg-config --libs libarchive)" >>$CONFIG_MK
-	echo "STATIC_LIBS +=    $(pkg-config --libs --static libarchive)" \
+	echo "found version $($PKGCONFIG_BIN --modversion libarchive)."
+	echo "CFLAGS += $($PKGCONFIG_BIN --cflags libarchive)" >>$CONFIG_MK
+	echo "LDFLAGS +=        $($PKGCONFIG_BIN --libs libarchive)" >>$CONFIG_MK
+	echo "STATIC_LIBS +=    $($PKGCONFIG_BIN --libs --static libarchive)" \
 		>>$CONFIG_MK
 fi
 
@@ -706,17 +706,17 @@ fi
 # libssl with pkg-config support is required.
 #
 printf "Checking for libssl via pkg-config ... "
-if pkg-config --exists 'libssl' && ! pkg-config --exists libtls ; then
-	echo "found OpenSSL version $(pkg-config --modversion libssl)."
-elif pkg-config --exists libssl libtls; then
-	echo "found LibreSSL version $(pkg-config --modversion libssl)."
+if $PKGCONFIG_BIN --exists 'libssl' && ! $PKGCONFIG_BIN --exists libtls ; then
+	echo "found OpenSSL version $($PKGCONFIG_BIN --modversion libssl)."
+elif $PKGCONFIG_BIN --exists libssl libtls; then
+	echo "found LibreSSL version $($PKGCONFIG_BIN --modversion libssl)."
 else
 	echo "libssl.pc file not found or incompatible version detected, exiting."
 	exit 1
 fi
-echo "CFLAGS += $(pkg-config --cflags libssl)" >>$CONFIG_MK
-echo "LDFLAGS +=        $(pkg-config --libs libssl)" >>$CONFIG_MK
-echo "STATIC_LIBS +=    $(pkg-config --libs --static libssl)" \
+echo "CFLAGS += $($PKGCONFIG_BIN --cflags libssl)" >>$CONFIG_MK
+echo "LDFLAGS +=        $($PKGCONFIG_BIN --libs libssl)" >>$CONFIG_MK
+echo "STATIC_LIBS +=    $($PKGCONFIG_BIN --libs --static libssl)" \
 	>>$CONFIG_MK
 
 #
@@ -734,13 +734,13 @@ fi
 #
 if [ "$BUILD_TESTS" = "yes" ]; then
 	printf "Checking for ATF via pkg-config ... "
-	if ! pkg-config --atleast-version=0.15 atf-c; then
+	if ! $PKGCONFIG_BIN --atleast-version=0.15 atf-c; then
 		echo "ATF >= 0.15 not found in PKG_CONFIG_LIBDIR, exiting."
 		exit 1
 	fi
-	echo "found version $(pkg-config --modversion atf-c)."
-	echo "TEST_CFLAGS += $(pkg-config --cflags atf-c)" >>$CONFIG_MK
-	echo "TEST_LDFLAGS += $(pkg-config --libs atf-c)" >>$CONFIG_MK
+	echo "found version $($PKGCONFIG_BIN --modversion atf-c)."
+	echo "TEST_CFLAGS += $($PKGCONFIG_BIN --cflags atf-c)" >>$CONFIG_MK
+	echo "TEST_LDFLAGS += $($PKGCONFIG_BIN --libs atf-c)" >>$CONFIG_MK
 	echo "BUILD_TESTS = yes" >>$CONFIG_MK
 	BUILD_TESTS_VALUE=yes
 else
diff --git xbps-clean/lib/Makefile xbps-workdir/lib/Makefile
index 847bfdd..f80c0f6 100644
--- xbps-clean/lib/Makefile
+++ xbps-workdir/lib/Makefile
@@ -93,8 +93,8 @@ install: all
 	install -d $(DESTDIR)$(LIBDIR)
 	install -m 644 libxbps.a $(DESTDIR)$(LIBDIR)
 	install -m 755 $(LIBXBPS_SHLIB) $(DESTDIR)$(LIBDIR)
-	cp -a libxbps.so $(DESTDIR)$(LIBDIR)
-	cp -a libxbps.so.$(LIBXBPS_MAJOR) $(DESTDIR)$(LIBDIR)
+	cp -dR libxbps.so $(DESTDIR)$(LIBDIR)
+	cp -dR libxbps.so.$(LIBXBPS_MAJOR) $(DESTDIR)$(LIBDIR)
 
 .PHONY: uninstall
 uninstall:
diff --git xbps-clean/lib/fetch/ftp.c xbps-workdir/lib/fetch/ftp.c
index 28296a0..f543ce1 100644
--- xbps-clean/lib/fetch/ftp.c
+++ xbps-workdir/lib/fetch/ftp.c
@@ -79,7 +79,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
-
+#include <strings.h>
 #include "fetch.h"
 #include "common.h"
 #include "ftperr.h"
@@ -147,7 +147,7 @@ unmappedaddr(struct sockaddr_in6 *sin6, socklen_t *len)
 	sin4->sin_port = port;
 	sin4->sin_family = AF_INET;
 	*len = sizeof(struct sockaddr_in);
-#ifndef __linux__
+#if !defined(__linux__) && !defined(__ironclad__)
 	sin4->sin_len = sizeof(struct sockaddr_in);
 #endif
 }
diff --git xbps-clean/lib/fetch/http.c xbps-workdir/lib/fetch/http.c
index f7b9142..d68b8f8 100644
--- xbps-clean/lib/fetch/http.c
+++ xbps-workdir/lib/fetch/http.c
@@ -78,7 +78,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
-
+#include <strings.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 
diff --git xbps-clean/lib/portableproplib/prop_object.c xbps-workdir/lib/portableproplib/prop_object.c
index 50cd918..515b70c 100644
--- xbps-clean/lib/portableproplib/prop_object.c
+++ xbps-workdir/lib/portableproplib/prop_object.c
@@ -91,7 +91,7 @@ _prop_object_externalize_start_tag(
 	    _prop_object_externalize_append_cstring(ctx, tag) == false ||
 	    _prop_object_externalize_append_char(ctx, '>') == false)
 		return (false);
-	
+
 	return (true);
 }
 
@@ -135,7 +135,7 @@ _prop_object_externalize_empty_tag(
 	    _prop_object_externalize_append_char(ctx, '>') == false ||
 	    _prop_object_externalize_append_char(ctx, '\n') == false)
 	    	return (false);
-	
+
 	return (true);
 }
 
@@ -404,7 +404,7 @@ _prop_object_internalize_find_tag(struct _prop_object_internalize_context *ctx,
 	    (taglen != ctx->poic_tagname_len ||
 	     memcmp(tag, ctx->poic_tagname, taglen) != 0))
 		return (false);
-	
+
 	/* Check for empty tag. */
 	if (*cp == '/') {
 		if (ctx->poic_tag_type != _PROP_TAG_TYPE_START)
@@ -445,14 +445,14 @@ _prop_object_internalize_find_tag(struct _prop_object_internalize_context *ctx,
 	}
 
 	ctx->poic_tagattr_len = cp - ctx->poic_tagattr;
-	
+
 	cp++;
 	if (*cp != '\"')
 		return (false);
 	cp++;
 	if (_PROP_EOF(*cp))
 		return (false);
-	
+
 	ctx->poic_tagattrval = cp;
 	while (*cp != '\"') {
 		if (_PROP_EOF(*cp))
@@ -460,7 +460,7 @@ _prop_object_internalize_find_tag(struct _prop_object_internalize_context *ctx,
 		cp++;
 	}
 	ctx->poic_tagattrval_len = cp - ctx->poic_tagattrval;
-	
+
 	cp++;
 	if (*cp != '>')
 		return (false);
@@ -482,7 +482,7 @@ _prop_object_internalize_decode_string(
 	const char *src;
 	size_t tarindex;
 	char c;
-	
+
 	tarindex = 0;
 	src = ctx->poic_cp;
 
@@ -541,7 +541,7 @@ _prop_object_internalize_decode_string(
 		*sizep = tarindex;
 	if (cpp != NULL)
 		*cpp = src;
-	
+
 	return (true);
 }
 
@@ -700,7 +700,7 @@ _prop_object_internalize_context_alloc(const char *xml)
 			   M_TEMP);
 	if (ctx == NULL)
 		return (NULL);
-	
+
 	ctx->poic_xml = ctx->poic_cp = xml;
 
 	/*
@@ -784,12 +784,12 @@ _prop_object_externalize_file_dirname(const char *path, char *result)
 	 */
 	if (path == NULL || *path == '\0')
 		goto singledot;
-	
+
 	/* String trailing slashes, if any. */
 	lastp = path + strlen(path) - 1;
 	while (lastp != path && *lastp == '/')
 		lastp--;
-	
+
 	/* Terminate path at the last occurrence of '/'. */
 	do {
 		if (*lastp == '/') {
@@ -929,7 +929,7 @@ _prop_object_internalize_map_file(const char *fname)
 	mf = _PROP_MALLOC(sizeof(*mf), M_TEMP);
 	if (mf == NULL)
 		return (NULL);
-	
+
 	fd = open(fname, O_RDONLY, 0400);
 	if (fd == -1) {
 		_PROP_FREE(mf, M_TEMP);
@@ -956,14 +956,14 @@ _prop_object_internalize_map_file(const char *fname)
 	if ((sb.st_size & pgmask) == 0)
 		need_guard = true;
 
-	mf->poimf_xml = mmap(NULL, need_guard ? mf->poimf_mapsize + pgsize
-			    		      : mf->poimf_mapsize,
-			    PROT_READ, MAP_SHARED, fd, (off_t)0);
-	(void) close(fd);
-	if (mf->poimf_xml == MAP_FAILED) {
+	mf->poimf_xml = malloc(need_guard ? mf->poimf_mapsize + pgsize : mf->poimf_mapsize);
+	if (mf->poimf_xml == NULL) {
 		_PROP_FREE(mf, M_TEMP);
 		return (NULL);
 	}
+	ssize_t rsz = read(fd, mf->poimf_xml, need_guard ? mf->poimf_mapsize + pgsize : mf->poimf_mapsize);
+	(void) close(fd);
+
 	(void)posix_madvise(mf->poimf_xml, mf->poimf_mapsize, POSIX_MADV_SEQUENTIAL);
 
 	if (need_guard) {
@@ -1035,7 +1035,7 @@ prop_object_release_emergency(prop_object_t obj)
 
 		/* Save pointerto unlock function */
 		unlock = po->po_type->pot_unlock;
-		
+
 		/* Dance a bit to make sure we always get the non-racy ocnt */
 		_PROP_ATOMIC_DEC32_NV(&po->po_refcnt, ocnt);
 		ocnt++;
@@ -1046,8 +1046,8 @@ prop_object_release_emergency(prop_object_t obj)
 				unlock();
 			break;
 		}
-		
-		_PROP_ASSERT(po->po_type);		
+
+		_PROP_ASSERT(po->po_type);
 		if ((po->po_type->pot_free)(NULL, &obj) ==
 		    _PROP_OBJECT_FREE_DONE) {
 			if (unlock != NULL)
@@ -1057,7 +1057,7 @@ prop_object_release_emergency(prop_object_t obj)
 
 		if (unlock != NULL)
 			unlock();
-		
+
 		parent = po;
 		_PROP_ATOMIC_INC32(&po->po_refcnt);
 	}
@@ -1079,7 +1079,7 @@ prop_object_release(prop_object_t obj)
 {
 	struct _prop_object *po;
 	struct _prop_stack stack;
-	void (*unlock)(void); 
+	void (*unlock)(void);
 	int ret;
 	uint32_t ocnt;
 
@@ -1095,7 +1095,7 @@ prop_object_release(prop_object_t obj)
 
 			/* Save pointer to object unlock function */
 			unlock = po->po_type->pot_unlock;
-			
+
 			_PROP_ATOMIC_DEC32_NV(&po->po_refcnt, ocnt);
 			ocnt++;
 			_PROP_ASSERT(ocnt != 0);
@@ -1106,7 +1106,7 @@ prop_object_release(prop_object_t obj)
 					unlock();
 				break;
 			}
-			
+
 			ret = (po->po_type->pot_free)(&stack, &obj);
 
 			if (unlock != NULL)
@@ -1114,7 +1114,7 @@ prop_object_release(prop_object_t obj)
 
 			if (ret == _PROP_OBJECT_FREE_DONE)
 				break;
-			
+
 			_PROP_ATOMIC_INC32(&po->po_refcnt);
 		} while (ret == _PROP_OBJECT_FREE_RECURSE);
 		if (ret == _PROP_OBJECT_FREE_FAILED)
@@ -1170,7 +1170,7 @@ prop_object_equals_with_error(prop_object_t obj1, prop_object_t obj2,
 
 	if (po1->po_type != po2->po_type)
 		return (false);
-    
+
  continue_subtree:
 	ret = (*po1->po_type->pot_equals)(obj1, obj2,
 					  &stored_pointer1, &stored_pointer2,
@@ -1202,7 +1202,7 @@ finish:
 		po1 = obj1;
 		(*po1->po_type->pot_equals_finish)(obj1, obj2);
 	}
-	return (false);		
+	return (false);
 }
 
 /*
