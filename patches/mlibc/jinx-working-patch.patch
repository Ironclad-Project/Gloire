diff --git mlibc-clean/abis/ironclad/signal.h mlibc-workdir/abis/ironclad/signal.h
index 3ecabad..b002dcf 100644
--- mlibc-clean/abis/ironclad/signal.h
+++ mlibc-workdir/abis/ironclad/signal.h
@@ -32,41 +32,41 @@ typedef void (*__sighandler) (int);
 #define SIG_DFL ((__sighandler)(void *)(-2))
 #define SIG_IGN ((__sighandler)(void *)(-3))
 
-#define SIGHUP 1
-#define SIGINT 2
-#define SIGQUIT 3
-#define SIGILL 4
-#define SIGTRAP 5
-#define SIGABRT 6
-#define SIGBUS 7
-#define SIGFPE 8
-#define SIGKILL 9
-#define SIGUSR1 10
-#define SIGSEGV 11
-#define SIGUSR2 12
-#define SIGPIPE 13
-#define SIGALRM 14
+#define SIGABRT 1
+#define SIGALRM 2
+#define SIGBUS  3
+#define SIGCHLD 4
+#define SIGCONT 5
+#define SIGFPE  6
+#define SIGHUP  7
+#define SIGILL  8
+#define SIGINT  9
+#define SIGKILL 10
+#define SIGPIPE 11
+#define SIGQUIT 12
+#define SIGSEGV 13
+#define SIGSTOP 14
 #define SIGTERM 15
-#define SIGSTKFLT 16
-#define SIGCHLD 17
-#define SIGCONT 18
-#define SIGSTOP 19
-#define SIGTSTP 20
-#define SIGTTIN 21
-#define SIGTTOU 22
-#define SIGURG 23
-#define SIGXCPU 24
-#define SIGXFSZ 25
+#define SIGTSTP 16
+#define SIGTTIN 17
+#define SIGTTOU 18
+#define SIGUSR1 19
+#define SIGUSR2 20
+#define SIGPOLL 21
+#define SIGPROF 22
+#define SIGSYS  23
+#define SIGTRAP 24
+#define SIGURG  25
 #define SIGVTALRM 26
-#define SIGPROF 27
-#define SIGWINCH 28
-#define SIGIO 29
-#define SIGPOLL SIGIO
-#define SIGPWR 30
-#define SIGSYS 31
-#define SIGRTMIN 32
-#define SIGRTMAX 33
-#define SIGCANCEL SIGSYS
+#define SIGXCPU 27
+#define SIGXFSZ 28
+
+/* These values are not kernel-related, and are emulated for userland by the */
+/* libc, we will map them to SIGUSR2, which userland wont be able to use. */
+#define SIGCANCEL SIGUSR2
+#define SIGWINCH SIGUSR2
+#define SIGIO    SIGUSR2
+#define SIGPWR   SIGUSR2
 
 /* siginfo->si_info constants */
 /* SIGBUS */
@@ -160,7 +160,7 @@ struct sigaction {
 	int sa_flags;
 };
 
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || (defined(__riscv) && __riscv_xlen == 64)
 /* TODO: This is wrong for AArch64. */
 
 typedef struct {
diff --git mlibc-clean/abis/ironclad/socket.h mlibc-workdir/abis/ironclad/socket.h
index d7754f4..1e38349 100644
--- mlibc-clean/abis/ironclad/socket.h
+++ mlibc-workdir/abis/ironclad/socket.h
@@ -48,14 +48,13 @@ struct cmsghdr {
 
 #define SCM_CREDENTIALS 0x02
 
-#define SOCK_DGRAM 1
-#define SOCK_RAW 2
-#define SOCK_SEQPACKET 3
-#define SOCK_STREAM 4
-#define SOCK_DCCP 5
-#define SOCK_NONBLOCK 0x10000
-#define SOCK_CLOEXEC 0x20000
-#define SOCK_RDM 0x40000
+#define SOCK_DGRAM     0b000000000000000001
+#define SOCK_RAW       0b000000000000000010
+#define SOCK_STREAM    0b000000000000000100
+#define SOCK_SEQPACKET 0b000000000000001000
+#define SOCK_NONBLOCK  0b001000000000000000
+#define SOCK_CLOEXEC   0b010000000000000000
+#define SOCK_CLOFORK   0b100000000000000000
 
 #define SOL_SOCKET 1
 #define SOL_IPV6 41
diff --git mlibc-clean/abis/ironclad/stat.h mlibc-workdir/abis/ironclad/stat.h
index 37f6aaa..7a507a0 100644
--- mlibc-clean/abis/ironclad/stat.h
+++ mlibc-workdir/abis/ironclad/stat.h
@@ -46,6 +46,8 @@
 extern "C" {
 #endif
 
+#define st_birthtim st_btim
+
 struct stat {
 	dev_t st_dev;
 	ino_t st_ino;
@@ -58,6 +60,7 @@ struct stat {
 	struct timespec st_atim;
 	struct timespec st_mtim;
 	struct timespec st_ctim;
+	struct timespec st_btim;
 	blksize_t st_blksize;
 	blkcnt_t st_blocks;
 };
diff --git mlibc-clean/abis/ironclad/termios.h mlibc-workdir/abis/ironclad/termios.h
index 475cd5b..32f23be 100644
--- mlibc-clean/abis/ironclad/termios.h
+++ mlibc-workdir/abis/ironclad/termios.h
@@ -18,6 +18,7 @@ typedef unsigned int tcflag_t;
 #define VSTOP    8
 #define VSUSP    9
 #define VTIME   10
+#define VLNEXT   15
 
 /* bitwise flags for c_iflag in struct termios */
 #define BRKINT  0x0001
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..1ce0414 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -2,8 +2,7 @@
 #include <bits/ensure.h>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git mlibc-clean/options/internal/generic/charset.cpp mlibc-workdir/options/internal/generic/charset.cpp
index c42b4f4..011d9c0 100644
--- mlibc-clean/options/internal/generic/charset.cpp
+++ mlibc-workdir/options/internal/generic/charset.cpp
@@ -91,9 +91,9 @@ bool charset::is_space(codepoint c) {
 bool charset::is_print(codepoint c) {
 	if(c <= 0x7F && is_ascii_superset())
 		return c >= 0x20 && c <= 0x7E;
-	if(c > 0x7F)
+	/*if(c > 0x7F)
 		mlibc::infoLogger() << "mlibc: charset::is_print() is not implemented"
-				" for the full Unicode charset" << frg::endlog;
+				" for the full Unicode charset" << frg::endlog;*/
 	return false;
 }
 
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 7e645e4..2f1e96b 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -528,9 +528,16 @@ int strcoll_l(const char *, const char *, locale_t) {
 	__builtin_unreachable();
 }
 
-int getloadavg(double *, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+#include <sys/syscall.h>
+
+int getloadavg(double *samples, int nsample) {
+	int ret;
+	int samples2[3];
+	SYSCALL3(SYSCALL_SYSCONF, 19, samples2, sizeof(samples2));
+	for (int i = 0; i < 3; i++) {
+		samples[i] = samples2[i] / 100.0;
+	}
+	return 3;
 }
 
 int getsubopt(char **__restrict__, char *const *__restrict__, char **__restrict__) {
diff --git mlibc-clean/options/posix/generic/posix_string.cpp mlibc-workdir/options/posix/generic/posix_string.cpp
index 838b85b..8b0beec 100644
--- mlibc-clean/options/posix/generic/posix_string.cpp
+++ mlibc-workdir/options/posix/generic/posix_string.cpp
@@ -94,8 +94,6 @@ char *strsignal(int sig) {
 	CASE_FOR(SIGSEGV)
 	CASE_FOR(SIGTERM)
 	CASE_FOR(SIGPROF)
-	CASE_FOR(SIGIO)
-	CASE_FOR(SIGPWR)
 	CASE_FOR(SIGALRM)
 	CASE_FOR(SIGBUS)
 	CASE_FOR(SIGCHLD)
@@ -116,7 +114,6 @@ char *strsignal(int sig) {
 	CASE_FOR(SIGVTALRM)
 	CASE_FOR(SIGXCPU)
 	CASE_FOR(SIGXFSZ)
-	CASE_FOR(SIGWINCH)
 	default:
 		mlibc::infoLogger() << "mlibc: Unknown signal number " << sig << frg::endlog;
 		s = "Unknown signal number";
diff --git mlibc-clean/options/posix/generic/sys-shm.cpp mlibc-workdir/options/posix/generic/sys-shm.cpp
index 3af7e90..a02d4a2 100644
--- mlibc-clean/options/posix/generic/sys-shm.cpp
+++ mlibc-workdir/options/posix/generic/sys-shm.cpp
@@ -2,23 +2,29 @@
 
 #include <bits/ensure.h>
 #include <mlibc/debug.hpp>
+#include <sys/syscall.h>
+#include <errno.h>
 
-void *shmat(int, const void *, int) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+void *shmat(int shmid, const void *shmaddr, int shmflg) {
+	void *ret;
+	SYSCALL3(SYSCALL_SHMAT, shmid, shmaddr, shmflg);
+	return ret;
 }
 
-int shmctl(int, int, struct shmid_ds *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+int shmctl(int shmid, int cmd, struct shmid_ds *buf) {
+	int ret;
+	SYSCALL3(SYSCALL_SHMCTL, shmid, cmd, buf);
+	return ret;
 }
 
-int shmdt(const void *) {
-	__ensure(!"Function is not implemented");
-	__builtin_unreachable();
+int shmdt(const void *shmaddr) {
+	int ret;
+	SYSCALL1(SYSCALL_SHMDT, shmaddr);
+	return ret;
 }
 
-int shmget(key_t, size_t, int) {
-	mlibc::infoLogger() << "mlibc: shmget() is a no-op!" << frg::endlog;
-	return -1;
+int shmget(key_t key, size_t size, int shmflg) {
+	int ret;
+	SYSCALL3(SYSCALL_SHMGET, key, size, shmflg);
+	return ret;
 }
diff --git mlibc-clean/options/posix/include/fcntl.h mlibc-workdir/options/posix/include/fcntl.h
index 65c6678..49c42e5 100644
--- mlibc-clean/options/posix/include/fcntl.h
+++ mlibc-workdir/options/posix/include/fcntl.h
@@ -74,9 +74,6 @@ ssize_t vmsplice(int __fd, const struct iovec *__iov, size_t __nr_segs, unsigned
 #define SPLICE_F_MORE 4
 #define SPLICE_F_GIFT 8
 
-#define F_SETPIPE_SZ 1031
-#define F_GETPIPE_SZ 1032
-
 #define FALLOC_FL_KEEP_SIZE 1
 #define FALLOC_FL_PUNCH_HOLE 2
 
diff --git mlibc-clean/options/posix/include/unistd.h mlibc-workdir/options/posix/include/unistd.h
index 97bbaae..34bc025 100644
--- mlibc-clean/options/posix/include/unistd.h
+++ mlibc-workdir/options/posix/include/unistd.h
@@ -103,135 +103,105 @@ extern "C" {
 #define _PC_FILESIZEBITS 9
 #define _PC_SYMLINK_MAX 10
 
+/* Kernel-supported ABI SC flags */
+/* TODO: This should be moved to its own abi but the mlibc people wont let */
+/* me do so without CBT. */
+#define _SC_PAGESIZE         1
+#define _SC_OPEN_MAX         2
+#define _SC_HOST_NAME_MAX    3
+#define _SC_AVPHYS_PAGES     4
+#define _SC_PHYS_PAGES       5
+#define _SC_NPROCESSORS_ONLN 6
+#define _SC_TOTAL_PAGES      7
+#define _SC_LIST_PROCS       8
+#define _SC_LIST_MOUNTS      9
+#define _SC_UNAME            10
+#define _SC_CHILD_MAX        11
+#define _SC_LIST_THREADS     12
+#define _SC_LIST_CLUSTERS    13
+#define _SC_LIST_NETINTER    14
+#define _SC_DUMPLOGS         15
+#define _SC_NGROUPS_MAX      16
+#define _SC_SYMLOOP_MAX      17
+
+/* SC Aliases */
+#define _SC_PAGE_SIZE _SC_PAGESIZE
+
+/* The rest of libc-emulated SC macros */
 /* MISSING: remaining _SC_macros */
-#define _SC_ARG_MAX 0
-#define _SC_CHILD_MAX 1
-#define _SC_CLK_TCK 2
-#define _SC_NGROUPS_MAX 3
-#define _SC_OPEN_MAX 4
-#define _SC_STREAM_MAX 5
-#define _SC_TZNAME_MAX 6
-#define _SC_JOB_CONTROL 7
-
-#define _SC_SAVED_IDS 8
-#define _SC_REALTIME_SIGNALS 9
-#define _SC_PRIORITY_SCHEDULING 10
-#define _SC_TIMERS 11
-#define _SC_ASYNCHRONOUS_IO 12
-#define _SC_PRIORITIZED_IO 13
-#define _SC_SYNCHRONIZED_IO 14
-#define _SC_FSYNC 15
-#define _SC_MAPPED_FILES 16
-#define _SC_MEMLOCK 17
-#define _SC_MEMLOCK_RANGE 18
-#define _SC_MEMORY_PROTECTION 19
-#define _SC_MESSAGE_PASSING 20
-#define _SC_SEMAPHORES 21
-#define _SC_SHARED_MEMORY_OBJECTS 22
-#define _SC_AIO_LISTIO_MAX 23
-#define _SC_AIO_MAX 24
-#define _SC_AIO_PRIO_DELTA_MAX 25
-#define _SC_DELAYTIMER_MAX 26
-#define _SC_MQ_OPEN_MAX 27
-#define _SC_MQ_PRIO_MAX 28
-#define _SC_VERSION 29
-#define _SC_PAGE_SIZE 30
-#define _SC_PAGESIZE _SC_PAGE_SIZE
-#define _SC_RTSIG_MAX 31
-#define _SC_SEM_NSEMS_MAX 32
-#define _SC_SEM_VALUE_MAX 33
-#define _SC_SIGQUEUE_MAX 34
-#define _SC_TIMER_MAX 35
-#define _SC_BC_BASE_MAX 36
-#define _SC_BC_DIM_MAX 37
-#define _SC_BC_SCALE_MAX 38
-#define _SC_BC_STRING_MAX 39
-#define _SC_COLL_WEIGHTS_MAX 40
-#define _SC_EXPR_NEST_MAX 42
-#define _SC_LINE_MAX 43
-#define _SC_RE_DUP_MAX 44
-#define _SC_2_VERSION 46
-#define _SC_2_C_BIND 47
-#define _SC_2_C_DEV 48
-#define _SC_2_FORT_DEV 49
-#define _SC_2_FORT_RUN 50
-#define _SC_2_SW_DEV 51
-#define _SC_2_LOCALEDEF 52
-#define _SC_IOV_MAX 60
-#define _SC_UIO_MAXIOV _SC_IOV_MAX
-#define _SC_THREADS 67
-#define _SC_THREAD_SAFE_FUNCTIONS 68
-#define _SC_GETGR_R_SIZE_MAX 69
-#define _SC_GETPW_R_SIZE_MAX 70
-#define _SC_LOGIN_NAME_MAX 71
-#define _SC_TTY_NAME_MAX 72
-#define _SC_THREAD_DESTRUCTOR_ITERATIONS 73
-#define _SC_THREAD_KEYS_MAX 74
-#define _SC_THREAD_STACK_MIN 75
-#define _SC_THREAD_THREADS_MAX 76
-#define _SC_THREAD_ATTR_STACKADDR 77
-#define _SC_THREAD_ATTR_STACKSIZE 78
-#define _SC_THREAD_PRIORITY_SCHEDULING 79
-#define _SC_THREAD_PRIO_INHERIT 80
-#define _SC_THREAD_PRIO_PROTECT 81
-#define _SC_THREAD_PROCESS_SHARED 82
-#define _SC_NPROCESSORS_CONF 83
-#define _SC_NPROCESSORS_ONLN 84
-#define _SC_PHYS_PAGES 85
-#define _SC_AVPHYS_PAGES 86
-#define _SC_ATEXIT_MAX 87
-#define _SC_PASS_MAX 88
-#define _SC_XOPEN_VERSION 89
-#define _SC_XOPEN_XCU_VERSION 90
-#define _SC_XOPEN_UNIX 91
-#define _SC_XOPEN_CRYPT 92
-#define _SC_XOPEN_ENH_I18N 93
-#define _SC_XOPEN_SHM 94
-#define _SC_2_CHAR_TERM 95
-#define _SC_2_UPE 97
-#define _SC_XOPEN_XPG2 98
-#define _SC_XOPEN_XPG3 99
-#define _SC_XOPEN_XPG4 100
-#define _SC_NZERO 109
-#define _SC_XBS5_ILP32_OFF32 125
-#define _SC_XBS5_ILP32_OFFBIG 126
-#define _SC_XBS5_LP64_OFF64 127
-#define _SC_XBS5_LPBIG_OFFBIG 128
-#define _SC_XOPEN_LEGACY 129
-#define _SC_XOPEN_REALTIME 130
-#define _SC_XOPEN_REALTIME_THREADS 131
-#define _SC_ADVISORY_INFO 132
-#define _SC_BARRIERS 133
-#define _SC_CLOCK_SELECTION 137
-#define _SC_CPUTIME 138
-#define _SC_THREAD_CPUTIME 139
-#define _SC_MONOTONIC_CLOCK 149
-#define _SC_READER_WRITER_LOCKS 153
-#define _SC_SPIN_LOCKS 154
-#define _SC_REGEXP 155
-#define _SC_SHELL 157
-#define _SC_SPAWN 159
-#define _SC_SPORADIC_SERVER 160
-#define _SC_THREAD_SPORADIC_SERVER 161
-#define _SC_TIMEOUTS 164
-#define _SC_TYPED_MEMORY_OBJECTS 165
-#define _SC_2_PBS 168
-#define _SC_2_PBS_ACCOUNTING 169
-#define _SC_2_PBS_LOCATE 170
-#define _SC_2_PBS_MESSAGE 171
-#define _SC_2_PBS_TRACK 172
-#define _SC_SYMLOOP_MAX 173
-#define _SC_STREAMS 174
-#define _SC_2_PBS_CHECKPOINT 175
-#define _SC_V6_ILP32_OFF32 176
-#define _SC_V6_ILP32_OFFBIG 177
-#define _SC_V6_LP64_OFF64 178
-#define _SC_V6_LPBIG_OFFBIG 179
-#define _SC_HOST_NAME_MAX 180
-#define _SC_TRACE 181
-#define _SC_TRACE_EVENT_FILTER 182
-#define _SC_TRACE_INHERIT 183
-#define _SC_TRACE_LOG 184
+#define _SC_ARG_MAX                      18
+#define _SC_GETPW_R_SIZE_MAX             19
+#define _SC_GETGR_R_SIZE_MAX             20
+#define _SC_CLK_TCK                      21
+#define _SC_VERSION                      22
+#define _SC_SAVED_IDS                    23
+#define _SC_JOB_CONTROL                  24
+#define _SC_LINE_MAX                     25
+#define _SC_XOPEN_CRYPT                  26
+#define _SC_NPROCESSORS_CONF             27
+#define _SC_TTY_NAME_MAX                 28
+#define _SC_RE_DUP_MAX                   29
+#define _SC_ATEXIT_MAX                   30
+#define _SC_LOGIN_NAME_MAX               31
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS 32
+#define _SC_THREAD_KEYS_MAX              33
+#define _SC_THREAD_STACK_MIN             34
+#define _SC_THREAD_THREADS_MAX           35
+#define _SC_TZNAME_MAX                   36
+#define _SC_ASYNCHRONOUS_IO              37
+#define _SC_FSYNC                        38
+#define _SC_MAPPED_FILES                 39
+#define _SC_MEMLOCK                      40
+#define _SC_MEMLOCK_RANGE                41
+#define _SC_MEMORY_PROTECTION            42
+#define _SC_MESSAGE_PASSING              43
+#define _SC_PRIORITY_SCHEDULING          44
+#define _SC_REALTIME_SIGNALS             45
+#define _SC_SEMAPHORES                   46
+#define _SC_SHARED_MEMORY_OBJECTS        47
+#define _SC_SYNCHRONIZED_IO              48
+#define _SC_THREADS                      49
+#define _SC_THREAD_ATTR_STACKADDR        50
+#define _SC_THREAD_ATTR_STACKSIZE        51
+#define _SC_THREAD_PRIORITY_SCHEDULING   52
+#define _SC_THREAD_PRIO_INHERIT          53
+#define _SC_THREAD_PRIO_PROTECT          54
+#define _SC_THREAD_PROCESS_SHARED        55
+#define _SC_THREAD_SAFE_FUNCTIONS        56
+#define _SC_TIMERS                       57
+#define _SC_TIMER_MAX                    58
+#define _SC_2_CHAR_TERM                  59
+#define _SC_2_C_BIND                     60
+#define _SC_2_C_DEV                      61
+#define _SC_2_FORT_DEV                   62
+#define _SC_2_FORT_RUN                   63
+#define _SC_2_LOCALEDEF                  64
+#define _SC_2_SW_DEV                     65
+#define _SC_2_UPE                        66
+#define _SC_2_VERSION                    67
+#define _SC_CLOCK_SELECTION              68
+#define _SC_CPUTIME                      69
+#define _SC_THREAD_CPUTIME               70
+#define _SC_MONOTONIC_CLOCK              71
+#define _SC_READER_WRITER_LOCKS          72
+#define _SC_SPIN_LOCKS                   73
+#define _SC_REGEXP                       74
+#define _SC_SHELL                        75
+#define _SC_SPAWN                        76
+#define _SC_2_PBS                        78
+#define _SC_2_PBS_ACCOUNTING             79
+#define _SC_2_PBS_LOCATE                 80
+#define _SC_2_PBS_TRACK                  81
+#define _SC_2_PBS_MESSAGE                82
+#define _SC_STREAM_MAX                   83
+#define _SC_AIO_LISTIO_MAX               84
+#define _SC_AIO_MAX                      85
+#define _SC_DELAYTIMER_MAX               86
+#define _SC_MQ_OPEN_MAX                  88
+#define _SC_MQ_PRIO_MAX                  89
+#define _SC_RTSIG_MAX                    90
+#define _SC_SIGQUEUE_MAX                 91
+#define _SC_IOV_MAX                      92
 
 #define STDERR_FILENO 2
 #define STDIN_FILENO 0
diff --git mlibc-clean/options/rtld/generic/linker.cpp mlibc-workdir/options/rtld/generic/linker.cpp
index ec11f1b..1bd9545 100644
--- mlibc-clean/options/rtld/generic/linker.cpp
+++ mlibc-workdir/options/rtld/generic/linker.cpp
@@ -573,18 +573,27 @@ frg::expected<LinkerError, void> ObjectRepository::_fetchFromFile(SharedObject *
 
 				void *map_pointer;
 				if(mlibc::sys_vm_map(reinterpret_cast<void *>(map_address),
-						total_map_size, prot | PROT_WRITE,
+						total_map_size, PROT_WRITE,
 						MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0, &map_pointer))
 					__ensure(!"sys_vm_map failed");
 
 				__ensure(trySeek(fd, phdr->p_offset));
 				__ensure(tryReadExactly(fd, reinterpret_cast<char *>(map_address) + misalign,
 						phdr->p_filesz));
+
+				if (prot & PROT_EXEC) {
+					prot = PROT_READ | PROT_EXEC;
+				}
+				if (mlibc::sys_vm_protect(reinterpret_cast<void *>(map_address), total_map_size, prot)) {
+					__ensure(!"vm_protect not feeling all there");
+				}
 			#endif
 			// Take care of removing superfluous permissions.
+			/*
 			if(mlibc::sys_vm_protect && ((prot & PROT_WRITE) == 0))
 				if(mlibc::sys_vm_protect(map_pointer, total_map_size, prot))
 					mlibc::infoLogger() << "mlibc: sys_vm_protect() failed in ld.so" << frg::endlog;
+			*/
 		}else if(phdr->p_type == PT_TLS) {
 			object->tlsSegmentSize = phdr->p_memsz;
 			object->tlsAlignment = phdr->p_align;
diff --git mlibc-workdir/sysdeps/ironclad/crt-riscv64/crt0.S mlibc-workdir/sysdeps/ironclad/crt-riscv64/crt0.S
new file mode 100644
index 0000000..9ee8625
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-riscv64/crt0.S
@@ -0,0 +1,18 @@
+.section .text
+.global _start
+_start:
+	.weak __global_pointer$
+	.hidden __global_pointer$
+	.option push
+	.option norelax
+	lla gp, __global_pointer$
+	.option pop
+
+	mv a0, sp
+	la a1, main
+	call __mlibc_entry@plt
+	unimp
+
+
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/ironclad/crt-riscv64/crti.S mlibc-workdir/sysdeps/ironclad/crt-riscv64/crti.S
new file mode 100644
index 0000000..69f23ea
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-riscv64/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	unimp
+
+.section .fini
+.global _fini
+_fini:
+	unimp
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-workdir/sysdeps/ironclad/crt-riscv64/crtn.S mlibc-workdir/sysdeps/ironclad/crt-riscv64/crtn.S
new file mode 100644
index 0000000..525efd6
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/crt-riscv64/crtn.S
@@ -0,0 +1,7 @@
+.section .init
+	unimp
+
+.section .fini
+	unimp
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/ironclad/generic/generic.cpp mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
index 0383452..cb3bdff 100644
--- mlibc-clean/sysdeps/ironclad/generic/generic.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/generic.cpp
@@ -1,4 +1,3 @@
-#include <mlibc-config.h>
 #include <bits/ensure.h>
 #include <mlibc/debug.hpp>
 #include <mlibc/all-sysdeps.hpp>
@@ -17,6 +16,10 @@
 #include <unistd.h>
 #include <sys/file.h>
 #include <mlibc/tcb.hpp>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdbool.h>
+#include <stddef.h>
 
 namespace mlibc {
 
@@ -71,8 +74,8 @@ int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 	int path_len = strlen (path);
 	SYSCALL4(SYSCALL_OPEN, dirfd, path, path_len, flags);
 	if (ret != -1 && (flags & O_EXCL)) {
-		 SYSCALL1(SYSCALL_CLOSE, ret);
-		 return EEXIST;
+		SYSCALL1(SYSCALL_CLOSE, ret);
+		return EEXIST;
 	}
 
 	if (ret == -1 && (flags & O_CREAT)) {
@@ -80,7 +83,7 @@ int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
 		 if (ret == -1) {
 			  return errno;
 		 }
-		 SYSCALL4(SYSCALL_OPEN,	AT_FDCWD, path, path_len, flags);
+		 SYSCALL4(SYSCALL_OPEN, AT_FDCWD, path, path_len, flags);
 	} else if (ret != -1 && (flags & O_TRUNC)) {
 		// If the file cannot be truncated, dont sweat it, some software
 		// depends on some things being truncate-able that ironclad does not
@@ -284,12 +287,6 @@ int sys_vm_unmap(void *pointer, size_t size) {
 	}
 }
 
-int sys_getcwd(char *buf, size_t size) {
-	buf[0] = '/';
-	buf[1] = '\0';
-	return 0;
-}
-
 int sys_vm_protect(void *pointer, size_t size, int prot) {
 	int ret;
 	int errno;
@@ -333,7 +330,9 @@ int sys_setgroups(size_t size, const gid_t *list) {
 }
 
 int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
-	return 0;
+	int ret, errno;
+	SYSCALL3(SYSCALL_SIGACTION, signum, act, oldact);
+	return errno;
 }
 
 int sys_ptrace(long req, pid_t pid, void *addr, void *data, long *out) {
@@ -351,7 +350,9 @@ int sys_fcntl(int fd, int request, va_list args, int *result) {
 }
 
 int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
-	return 0;
+	int ret, errno;
+	SYSCALL3(SYSCALL_SIGPROCMASK, how, set, retrieve);
+	return errno;
 }
 
 int sys_isatty(int fd) {
@@ -389,7 +390,7 @@ int sys_fork(pid_t *child) {
 	pid_t ret;
 	int errno;
 
-	SYSCALL6(SYSCALL_CLONE, 0, 0, 0, 0, 0, 1);
+	SYSCALL0(SYSCALL_FORK);
 
 	if (ret == -1) {
 		return errno;
@@ -530,12 +531,7 @@ void sys_yield(void) {
 
 int sys_kill(int pid, int sig) {
 	int ret, errno;
-	if (sig == SIGKILL) {
-		SYSCALL1(SYSCALL_ACTUALLY_KILL, pid);
-	} else {
-		SYSCALL2(SYSCALL_SEND_SIGNAL, pid, sig);
-	}
-
+	SYSCALL2(SYSCALL_SEND_SIGNAL, pid, sig);
 	return errno;
 }
 
@@ -546,7 +542,13 @@ int sys_dup(int fd, int flags, int *newfd) {
 	} else {
 		SYSCALL3(SYSCALL_FCNTL, fd, F_DUPFD, 0);
 	}
+
 	*newfd = ret;
+
+	if (errno == 0) {
+		SYSCALL3(SYSCALL_FCNTL, *newfd, F_SETFD, flags);
+	}
+
 	return errno;
 }
 
@@ -565,9 +567,13 @@ int sys_dup2(int fd, int flags, int newfd) {
 
 	if (ret != -1 && ret != newfd) {
 		return EBADFD;
-	} else {
-		return errno;
 	}
+
+	if (errno == 0) {
+		SYSCALL3(SYSCALL_FCNTL, newfd, F_SETFD, flags);
+	}
+
+	return errno;
 }
 
 int sys_tcgetattr(int fd, struct termios *attr) {
@@ -767,7 +773,7 @@ int sys_setregid(gid_t rgid, gid_t egid) {
 }
 
 int sys_setsid(pid_t *sid) {
-	return 0;
+	 return 0;
 }
 
 #ifndef MLIBC_BUILDING_RTLD
@@ -776,7 +782,7 @@ extern "C" void __mlibc_thread_entry();
 
 int sys_clone(void *tcb, pid_t *tid_out, void *stack) {
 	 int ret, errno;
-	 SYSCALL6(SYSCALL_CLONE, (uintptr_t)__mlibc_thread_entry, 0, stack, 0b10, tcb, 1);
+	 SYSCALL5(SYSCALL_CREATE_THREAD, (uintptr_t)__mlibc_thread_entry, 0, stack, tcb, 1);
 
 	 if (ret == -1) {
 		  return errno;
@@ -884,7 +890,7 @@ int sys_shutdown(int sockfd, int how) {
 }
 
 int sys_setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value) {
-	return ENOSYS;
+	 return ENOSYS;
 }
 
 int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
@@ -933,14 +939,12 @@ int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
 
 
 int sys_ppoll(struct pollfd *fds, int nfds, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
-	// XXX: Ironclad has no sigprogmask so this is basically a weird ppoll poll
-	// chimeral abomination.
 	int ret, errno;
 	if (timeout == NULL) {
 		 struct timespec t = {.tv_sec = (time_t)-1, .tv_nsec = (time_t)-1};
-		 SYSCALL3(SYSCALL_POLL, fds, nfds, &t);
+		 SYSCALL4(SYSCALL_PPOLL, fds, nfds, &t, sigmask);
 	} else {
-		 SYSCALL3(SYSCALL_POLL, fds, nfds, timeout);
+		 SYSCALL4(SYSCALL_PPOLL, fds, nfds, timeout, sigmask);
 	}
 	if (ret == -1) {
 		return errno;
@@ -1201,6 +1205,10 @@ int sys_mknodat(int dirfd, const char *path, mode_t mode, dev_t dev) {
 	return errno;
 }
 
+int sys_brk(void **out) {
+	return -1;
+}
+
 #define SC_LIST_MOUNTS 9
 struct mountinfo {
 	uint32_t type;
@@ -1262,5 +1270,173 @@ int sys_statvfs(const char *path, struct statvfs *out) {
 
 	return EINVAL;
 }
+
+int sys_getcwd(char *buf, size_t size) {
+  int fd = AT_FDCWD;
+  bool fd_needs_closing = false;
+  DIR *dirstream = NULL;
+  dev_t rootdev, thisdev;
+  ino_t rootino, thisino;
+  char *dir;
+  register char *dirp;
+  struct stat st;
+  size_t used;
+
+  if (size == 0 || buf == NULL) {
+      return EINVAL;
+  }
+
+  dir = buf;
+
+  dirp = dir + size;
+  *--dirp = '\0';
+
+  if (lstat (".", &st) < 0)
+    goto lose;
+  thisdev = st.st_dev;
+  thisino = st.st_ino;
+
+  if (lstat ("/", &st) < 0)
+    goto lose;
+  rootdev = st.st_dev;
+  rootino = st.st_ino;
+
+  while (!(thisdev == rootdev && thisino == rootino))
+    {
+      struct dirent *d;
+      dev_t dotdev;
+      ino_t dotino;
+      bool mount_point;
+      int parent_status;
+      size_t dirroom;
+      size_t namlen;
+      bool use_d_ino = true;
+
+      /* Look at the parent directory.  */
+      fd = openat (fd, "..", O_RDONLY);
+      if (fd < 0)
+        goto lose;
+      fd_needs_closing = true;
+      parent_status = fstat (fd, &st);
+      if (parent_status != 0)
+        goto lose;
+
+      if (dirstream && closedir (dirstream) != 0)
+        {
+          dirstream = NULL;
+          goto lose;
+        }
+
+      /* Figure out if this directory is a mount point.  */
+      dotdev = st.st_dev;
+      dotino = st.st_ino;
+      mount_point = dotdev != thisdev;
+
+      /* Search for the last directory.  */
+      dirstream = fdopendir (fd);
+      if (dirstream == NULL)
+        goto lose;
+      fd_needs_closing = false;
+      for (;;)
+        {
+          /* Clear errno to distinguish EOF from error if readdir returns
+             NULL.  */
+          errno = 0;
+          d = readdir (dirstream);
+
+          /* When we've iterated through all directory entries without finding
+             one with a matching d_ino, rewind the stream and consider each
+             name again, but this time, using lstat.  This is necessary in a
+             chroot on at least one system (glibc-2.3.6 + linux 2.6.12), where
+             .., ../.., ../../.., etc. all had the same device number, yet the
+             d_ino values for entries in / did not match those obtained
+             via lstat.  */
+          if (d == NULL && errno == 0 && use_d_ino)
+            {
+              use_d_ino = false;
+              rewinddir (dirstream);
+              d = readdir (dirstream);
+            }
+
+          if (d == NULL)
+            {
+              if (errno == 0)
+                /* EOF on dirstream, which can mean e.g., that the current
+                   directory has been removed.  */
+                errno = ENOENT;
+              goto lose;
+            }
+          if (d->d_name[0] == '.' &&
+              (d->d_name[1] == '\0' ||
+               (d->d_name[1] == '.' && d->d_name[2] == '\0')))
+            continue;
+
+          if (use_d_ino)
+            {
+              bool match = ((d->d_ino == thisino) || mount_point);
+              if (! match)
+                continue;
+            }
+
+          {
+            int entry_status;
+            entry_status = fstatat (fd, d->d_name, &st, AT_SYMLINK_NOFOLLOW);
+
+            /* We don't fail here if we cannot stat() a directory entry.
+               This can happen when (network) file systems fail.  If this
+               entry is in fact the one we are looking for we will find
+               out soon as we reach the end of the directory without
+               having found anything.  */
+            if (entry_status == 0 && S_ISDIR (st.st_mode)
+                && st.st_dev == thisdev && st.st_ino == thisino)
+              break;
+          }
+        }
+
+      dirroom = dirp - dir;
+      namlen = strlen (d->d_name);
+
+      if (dirroom <= namlen)
+        {
+          errno = ERANGE;
+          goto lose;
+        }
+      dirp -= namlen;
+      memcpy (dirp, d->d_name, namlen);
+      *--dirp = '/';
+
+      thisdev = dotdev;
+      thisino = dotino;
+    }
+
+  if (dirstream && closedir (dirstream) != 0)
+    {
+      dirstream = NULL;
+      goto lose;
+    }
+
+  if (dirp == &dir[size - 1])
+    *--dirp = '/';
+
+  used = dir + size - dirp;
+  memmove (dir, dirp, used);
+
+  return 0;
+
+ memory_exhausted:
+  errno = ENOMEM;
+ lose:
+  {
+    int save = errno;
+    if (dirstream)
+      closedir (dirstream);
+
+    if (fd_needs_closing)
+      close (fd);
+
+    errno = save;
+  }
+  return 1;
+}
 #endif
 } // namespace mlibc
diff --git mlibc-clean/sysdeps/ironclad/generic/pty.cpp mlibc-workdir/sysdeps/ironclad/generic/pty.cpp
index 1626e4b..3796ef5 100644
--- mlibc-clean/sysdeps/ironclad/generic/pty.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/pty.cpp
@@ -25,17 +25,41 @@ int openpty(int *mfd, int *sfd, char *name, const struct termios *ios, const str
 			return -1;
 		}
 	}
-	if (ios != NULL) {
+
+	if (ios == NULL) {
+		struct termios termios;
+		termios.c_iflag = BRKINT | IGNPAR | ICRNL | IXON | IMAXBEL;
+		termios.c_oflag = OPOST | ONLCR;
+		termios.c_cflag = CS8 | CREAD;
+		termios.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE;
+		termios.c_cc[VINTR] = CTRL('C');
+		termios.c_cc[VEOF] = CTRL('D');
+		termios.c_cc[VSUSP] = CTRL('Z');
+		termios.ibaud = 38400;
+		termios.obaud = 38400;
+		ret = tcsetattr(*mfd, TCSANOW, &termios);
+	} else {
 		ret = tcsetattr(*mfd, TCSANOW, ios);
-		if (ret) {
-			return -1;
-		}
 	}
-	if (win != NULL) {
-		ret = ioctl(*mfd, TIOCGWINSZ, win);
-		if (ret) {
-			return -1;
-		}
+	if (ret) {
+		return -1;
+	}
+
+	if (win == NULL) {
+		struct winsize win_size = {
+			.ws_row = 24,
+			.ws_col = 80,
+			.ws_xpixel = 24 * 16,
+			.ws_ypixel = 80 * 16
+		};
+		ret = ioctl(*mfd, TIOCSWINSZ, &win_size);
+	} else {
+		ret = ioctl(*mfd, TIOCSWINSZ, win);
 	}
+
+	if (ret) {
+		return -1;
+	}
+
 	return ret;
 }
diff --git mlibc-clean/sysdeps/ironclad/generic/thread.S mlibc-workdir/sysdeps/ironclad/generic/thread.S
index 47ab6a9..c18fefe 100644
--- mlibc-clean/sysdeps/ironclad/generic/thread.S
+++ mlibc-workdir/sysdeps/ironclad/generic/thread.S
@@ -1,3 +1,4 @@
+#if defined(__x86_64__)
 .section .text
 .global __mlibc_thread_entry
 __mlibc_thread_entry:
@@ -5,5 +6,12 @@ __mlibc_thread_entry:
 	pop %rsi
 	pop %rdx
 	call __mlibc_thread_trampoline
+#elif (defined(__riscv) && __riscv_xlen == 64)
+.section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+#else
+#error "Missing architecture specific code."
+#endif
 
 .section .note.GNU-stack,"",%progbits
diff --git mlibc-clean/sysdeps/ironclad/generic/thread.cpp mlibc-workdir/sysdeps/ironclad/generic/thread.cpp
index 1b2f040..94f08c2 100644
--- mlibc-clean/sysdeps/ironclad/generic/thread.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/thread.cpp
@@ -4,6 +4,7 @@
 #include <mlibc/all-sysdeps.hpp>
 #include <bits/ensure.h>
 #include <mlibc/tcb.hpp>
+#include <mlibc/arch-defs.hpp>
 
 extern "C" void __mlibc_thread_trampoline(void *(*fn)(void *), Tcb *tcb, void *arg) {
 	while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0) {
@@ -22,19 +23,16 @@ extern "C" void __mlibc_thread_trampoline(void *(*fn)(void *), Tcb *tcb, void *a
 
 namespace mlibc {
 	int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size, void **stack_base) {
-		// TODO guard
-
-		mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
-
-		*guard_size = 0;
+		*guard_size = mlibc::page_size;
 
 		*stack_size = *stack_size ? *stack_size : DEFAULT_STACK;
 
 		if (!*stack) {
-			*stack_base = mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+			*stack_base = mmap(NULL, *stack_size + mlibc::page_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
 			if (*stack_base == MAP_FAILED) {
 				return errno;
 			}
+			munmap(*stack_base + *stack_size, mlibc::page_size);
 		} else {
 			*stack_base = *stack;
 		}
diff --git mlibc-clean/sysdeps/ironclad/generic/utmpx.cpp mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp
index ec74e22..f4a08f8 100644
--- mlibc-clean/sysdeps/ironclad/generic/utmpx.cpp
+++ mlibc-workdir/sysdeps/ironclad/generic/utmpx.cpp
@@ -22,7 +22,10 @@ void endutxent(void) {
 
 void setutxent(void) {
 	if (utmpx_file < 0) {
-		utmpx_file = open(UTMPX_FILE, O_RDWR | O_CREAT, 0755);
+		utmpx_file = open(UTMPX_FILE, O_RDWR | O_CREAT, 0664);
+      if (utmpx_file < 0) {
+         utmpx_file = open(UTMPX_FILE, O_RDONLY);
+      }
 	} else {
 		lseek(utmpx_file, 0, SEEK_SET);
 	}
@@ -62,11 +65,8 @@ struct utmpx *pututxline(const struct utmpx *added) {
 }
 
 int utmpxname(const char *path) {
-	if (utmpx_file > 0) {
-		close(utmpx_file);
-	}
-
-	utmpx_file = open(path, O_RDWR | O_CREAT, 0755);
+	endutxent();
+	setutxent();
 	if (utmpx_file > 0) {
 		lseek(utmpx_file, 0, SEEK_END);
 		return 1;
diff --git mlibc-clean/sysdeps/ironclad/include/sys/mac.h mlibc-workdir/sysdeps/ironclad/include/sys/mac.h
index 4bf3d28..6b43225 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/mac.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mac.h
@@ -9,19 +9,23 @@
 extern "C" {
 #endif
 
-#define MAC_CAP_SCHED   0b00000000001
-#define MAC_CAP_SPAWN   0b00000000010
-#define MAC_CAP_ENTROPY 0b00000000100
-#define MAC_CAP_SYS_MEM 0b00000001000
-#define MAC_CAP_USE_NET 0b00000010000
-#define MAC_CAP_SYS_NET 0b00000100000
-#define MAC_CAP_SYS_MNT 0b00001000000
-#define MAC_CAP_SYS_PWR 0b00010000000
-#define MAC_CAP_PTRACE  0b00100000000
-#define MAC_CAP_SETUID  0b01000000000
-#define MAC_CAP_SYS_MAC 0b10000000000
-#define MAC_CAP_CLOCK  0b100000000000
-#define MAC_CAP_SIGNALALL 0b1000000000000
+#define MAC_CAP_SCHED     0b0000000000000001
+#define MAC_CAP_SPAWN     0b0000000000000010
+#define MAC_CAP_ENTROPY   0b0000000000000100
+#define MAC_CAP_SYS_MEM   0b0000000000001000
+#define MAC_CAP_USE_NET   0b0000000000010000
+#define MAC_CAP_SYS_NET   0b0000000000100000
+#define MAC_CAP_SYS_MNT   0b0000000001000000
+#define MAC_CAP_SYS_PWR   0b0000000010000000
+#define MAC_CAP_PTRACE    0b0000000100000000
+#define MAC_CAP_SETUID    0b0000001000000000
+#define MAC_CAP_SYS_MAC   0b0000010000000000
+#define MAC_CAP_CLOCK     0b0000100000000000
+#define MAC_CAP_SIGNALALL 0b0001000000000000
+#define MAC_CAP_SETGID    0b0010000000000000
+#define MAC_CAP_IPC       0b0100000000000000
+#define MAC_CAP_SYS_LOG   0b1000000000000000
+
 unsigned long get_mac_capabilities(void);
 int set_mac_capabilities(unsigned long request);
 
diff --git mlibc-clean/sysdeps/ironclad/include/sys/mount.h mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
index cce83e6..f62339f 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/mount.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/mount.h
@@ -7,10 +7,12 @@ extern "C" {
 
 #define MNT_EXT 1
 #define MNT_FAT 2
+#define MNT_DEV 3
 
-#define MS_RDONLY   0b001
-#define MS_REMOUNT  0b010
-#define MS_RELATIME 0b100
+#define MS_RDONLY   0b0001
+#define MS_REMOUNT  0b0010
+#define MS_RELATIME 0b0100
+#define MS_NOATIME  0b1000
 
 #define MNT_FORCE 1
 
diff --git mlibc-clean/sysdeps/ironclad/include/sys/syscall.h mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
index 150a59c..7de62c4 100644
--- mlibc-clean/sysdeps/ironclad/include/sys/syscall.h
+++ mlibc-workdir/sysdeps/ironclad/include/sys/syscall.h
@@ -1,89 +1,14 @@
 #ifndef _SYS_SYSCALL_H
 #define _SYS_SYSCALL_H
 
+#include <stdint.h>
 #include <stddef.h>
 
-#define SYSCALL0(NUM) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL1(NUM, ARG0) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL2(NUM, ARG0, ARG1) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL3(NUM, ARG0, ARG1, ARG2) ({ \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL4(NUM, ARG0, ARG1, ARG2, ARG3) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL5(NUM, ARG0, ARG1, ARG2, ARG3, ARG4) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8 asm("r8") = ARG4; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8 asm("r8") = ARG4; \
-	register __typeof(ARG5) arg_r9 asm("r9") = ARG5; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8  asm("r8")  = ARG4; \
-	register __typeof(ARG5) arg_r9  asm("r9")  = ARG5; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
-				  : "rcx", "r11", "memory"); \
-})
-
-#define SYSCALL7(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ({ \
-	register __typeof(ARG3) arg_r12 asm("r12") = ARG3; \
-	register __typeof(ARG4) arg_r8  asm("r8")  = ARG4; \
-	register __typeof(ARG5) arg_r9  asm("r9")  = ARG5; \
-	register __typeof(ARG6) arg_r10 asm("r10") = ARG6; \
-	asm volatile ("syscall" \
-				  : "=a"(ret), "=d"(errno) \
-				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
-					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9), "r"(arg_r10) \
-				  : "rcx", "r11", "memory"); \
-})
+#ifdef __cplusplus
+#  define __auto_type auto
+#endif
 
+// Syscall numbers are the same on all architectures.
 #define SYSCALL_EXIT                  0
 #define SYSCALL_ARCH_PRCTL            1
 #define SYSCALL_OPEN                  2
@@ -96,13 +21,13 @@
 #define SYSCALL_GETPID                9
 #define SYSCALL_GETPPID              10
 #define SYSCALL_EXEC                 11
-#define SYSCALL_CLONE                12
+#define SYSCALL_FORK                 12
 #define SYSCALL_WAIT                 13
 #define SYSCALL_SOCKET               14
 #define SYSCALL_SETHOSTNAME          15
 #define SYSCALL_UNLINK               16
 #define SYSCALL_STAT                 17
-#define SYSCALL_GETCWD               18
+#define SYSCALL_PIVOT_ROOT           18
 #define SYSCALL_CHDIR                19
 #define SYSCALL_IOCTL                20
 #define SYSCALL_SCHED_YIELD          21
@@ -141,7 +66,7 @@
 #define SYSCALL_GETRLIMIT            54
 #define SYSCALL_SETRLIMIT            55
 #define SYSCALL_ACCESS               56
-#define SYSCALL_POLL                 57
+#define SYSCALL_PPOLL                57
 #define SYSCALL_GETEUID              58
 #define SYSCALL_SETUIDS              59
 #define SYSCALL_FCHMOD               60
@@ -163,8 +88,8 @@
 #define SYSCALL_UTIMES               76
 #define SYSCALL_CREATE_TCLUSTER      77
 #define SYSCALL_SWITCH_TCLUSTER      78
-#define SYSCALL_ACTUALLY_KILL        79
-#define SYSCALL_SIGNALPOST           80
+#define SYSCALL_SIGPROCMASK          79
+#define SYSCALL_SIGACTION            80
 #define SYSCALL_SEND_SIGNAL          81
 #define SYSCALL_GETPRIO              82
 #define SYSCALL_SETPRIO              83
@@ -183,5 +108,212 @@
 #define SYSCALL_SETSOCKOPT           96
 #define SYSCALL_GETTIDID             97
 #define SYSCALL_SETTIDID             98
+#define SYSCALL_FAILURE_POLICY       99
+#define SYSCALL_CREATE_THREAD       100
+
+#if defined(__x86_64__)
+#define SYSCALL0(NUM) ({ \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL1(NUM, ARG0) ({ \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL2(NUM, ARG0, ARG1) ({ \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL3(NUM, ARG0, ARG1, ARG2) ({ \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL4(NUM, ARG0, ARG1, ARG2, ARG3) ({ \
+	register __auto_type arg_r12 asm("r12") = ARG3; \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+					"r"(arg_r12) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL5(NUM, ARG0, ARG1, ARG2, ARG3, ARG4) ({ \
+	register __auto_type arg_r12 asm("r12") = ARG3; \
+	register __auto_type arg_r8 asm("r8") = ARG4; \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+					"r"(arg_r12), "r"(arg_r8) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
+	register __auto_type arg_r12 asm("r12") = ARG3; \
+	register __auto_type arg_r8  asm("r8")  = ARG4; \
+	register __auto_type arg_r9  asm("r9")  = ARG5; \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9) \
+				  : "rcx", "r11", "memory"); \
+})
+
+#define SYSCALL7(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ({ \
+	register __auto_type arg_r12 asm("r12") = ARG3; \
+	register __auto_type arg_r8  asm("r8")  = ARG4; \
+	register __auto_type arg_r9  asm("r9")  = ARG5; \
+	register __auto_type arg_r10 asm("r10") = ARG6; \
+	asm volatile ("syscall" \
+				  : "=a"(ret), "=d"(errno) \
+				  : "a"(NUM), "D"(ARG0), "S"(ARG1), "d"(ARG2), \
+					"r"(arg_r12), "r"(arg_r8), "r"(arg_r9), "r"(arg_r10) \
+				  : "rcx", "r11", "memory"); \
+})
+#elif (defined(__riscv) && __riscv_xlen == 64)
+#define SYSCALL0(NUM) ({ \
+	register uint64_t snum asm("a7") = (NUM); \
+	register __typeof(ret) re asm("a0");      \
+	register uint64_t err asm("a1");          \
+	asm volatile ("ecall"                     \
+				  : "=r"(re), "=r"(err)       \
+				  : "r"(snum)                 \
+				  : "memory");                \
+	ret   = re;                               \
+	errno = err;                              \
+})
+
+#define SYSCALL1(NUM, ARG0) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0)             \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+
+#define SYSCALL2(NUM, ARG0, ARG1) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	register __auto_type arg1 asm("a1") = (ARG1); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0), "r"(arg1)  \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+
+#define SYSCALL3(NUM, ARG0, ARG1, ARG2) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	register __auto_type arg1 asm("a1") = (ARG1); \
+	register __auto_type arg2 asm("a2") = (ARG2); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0), "r"(arg1), \
+				    "r"(arg2)                        \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+
+#define SYSCALL4(NUM, ARG0, ARG1, ARG2, ARG3) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	register __auto_type arg1 asm("a1") = (ARG1); \
+	register __auto_type arg2 asm("a2") = (ARG2); \
+	register __auto_type arg3 asm("a3") = (ARG3); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0), "r"(arg1), \
+				    "r"(arg2), "r"(arg3)             \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+
+#define SYSCALL5(NUM, ARG0, ARG1, ARG2, ARG3, ARG4) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	register __auto_type arg1 asm("a1") = (ARG1); \
+	register __auto_type arg2 asm("a2") = (ARG2); \
+	register __auto_type arg3 asm("a3") = (ARG3); \
+	register __auto_type arg4 asm("a4") = (ARG4); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0), "r"(arg1), \
+				    "r"(arg2), "r"(arg3), "r"(arg4)  \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+
+#define SYSCALL6(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	register __auto_type arg1 asm("a1") = (ARG1); \
+	register __auto_type arg2 asm("a2") = (ARG2); \
+	register __auto_type arg3 asm("a3") = (ARG3); \
+	register __auto_type arg4 asm("a4") = (ARG4); \
+	register __auto_type arg5 asm("a5") = (ARG5); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0), "r"(arg1), \
+				    "r"(arg2), "r"(arg3), "r"(arg4), \
+				    "r"(arg5)                        \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+
+#define SYSCALL7(NUM, ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ({ \
+	register uint64_t snum asm("a7") = (NUM);        \
+	register __typeof(ret) re asm("a0");             \
+	register uint64_t err asm("a1");                 \
+	register __auto_type arg0 asm("a0") = (ARG0); \
+	register __auto_type arg1 asm("a1") = (ARG1); \
+	register __auto_type arg2 asm("a2") = (ARG2); \
+	register __auto_type arg3 asm("a3") = (ARG3); \
+	register __auto_type arg4 asm("a4") = (ARG4); \
+	register __auto_type arg5 asm("a5") = (ARG5); \
+	register __auto_type arg6 asm("a6") = (ARG6); \
+	asm volatile ("ecall"                            \
+				  : "=r"(re), "=r"(err)              \
+				  : "r"(snum), "r"(arg0), "r"(arg1), \
+				    "r"(arg2), "r"(arg3), "r"(arg4), \
+				    "r"(arg5), "r"(arg6)             \
+				  : "memory");                       \
+	ret   = re;                                      \
+	errno = err;                                     \
+})
+#else
+#error "Missing architecture specific code."
+#endif
 
 #endif /* _SYS_SYSCALL_H */
diff --git mlibc-workdir/sysdeps/ironclad/include/sys/sysmacros.h mlibc-workdir/sysdeps/ironclad/include/sys/sysmacros.h
new file mode 100644
index 0000000..9682d01
--- /dev/null
+++ mlibc-workdir/sysdeps/ironclad/include/sys/sysmacros.h
@@ -0,0 +1,33 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static unsigned int __mlibc_dev_major(
+		unsigned long long int __dev) {
+  return ((__dev >> 8) & 0xfff) | ((unsigned int)(__dev >> 32) & ~0xfff);
+}
+
+static unsigned int __mlibc_dev_minor(
+		unsigned long long int __dev) {
+  return (__dev & 0xff) | ((unsigned int)(__dev >> 12) & ~0xff);
+}
+
+static unsigned long long int __mlibc_dev_makedev(
+		unsigned int __major, unsigned int __minor) {
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+	  | (((unsigned long long int)(__minor & ~0xff)) << 12)
+	  | (((unsigned long long int)(__major & ~0xfff)) << 32));
+}
+
+#define major(dev) __mlibc_dev_major(dev)
+#define minor(dev) __mlibc_dev_minor(dev)
+#define makedev(major, minor) __mlibc_dev_makedev(major, minor)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SYS_SYSMACROS_H */
diff --git mlibc-clean/sysdeps/ironclad/meson.build mlibc-workdir/sysdeps/ironclad/meson.build
index 80e6efc..e659402 100644
--- mlibc-clean/sysdeps/ironclad/meson.build
+++ mlibc-workdir/sysdeps/ironclad/meson.build
@@ -80,6 +80,7 @@ if not no_headers
 		'include/sys/syscall.h',
 		'include/sys/reboot.h',
 		'include/sys/mount.h',
+		'include/sys/sysmacros.h',
 		'include/sys/ptrace.h',
 		subdir: 'sys'
 	)
@@ -105,7 +106,7 @@ if not headers_only
 	crt = custom_target('crt0',
 		build_by_default: true,
 		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
-		input: 'crt-x86_64/crt0.S',
+		input: 'crt-' + host_machine.cpu_family() / 'crt0.S',
 		output: 'crt0.o',
 		install: true,
 		install_dir: get_option('libdir')
@@ -114,7 +115,7 @@ if not headers_only
 	custom_target('crti',
 		build_by_default: true,
 		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
-		input: 'crt-x86_64/crti.S',
+		input: 'crt-' + host_machine.cpu_family() / 'crti.S',
 		output: 'crti.o',
 		install: true,
 		install_dir: get_option('libdir')
@@ -123,7 +124,7 @@ if not headers_only
 	custom_target('crtn',
 		build_by_default: true,
 		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
-		input: 'crt-x86_64/crtn.S',
+		input: 'crt-' + host_machine.cpu_family() / 'crtn.S',
 		output: 'crtn.o',
 		install: true,
 		install_dir: get_option('libdir')
